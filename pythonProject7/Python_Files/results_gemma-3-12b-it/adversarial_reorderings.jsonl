{"lang_cluster": "Python", "source_code": "\n# Works with: Python version 2.5\n\nfrom collections import deque\nstack = deque()\nstack.append(value) # pushing\nvalue = stack.pop()\nnot stack # is empty?\n\nfrom collections import deque\n\nclass Stack:\n    def __init__(self):\n        self._items = deque()\n    def append(self, item):\n        self._items.append(item)\n    def pop(self):\n        return self._items.pop()\n    def __nonzero__(self):\n        return bool(self._items)\n\nclass Stack:\n    def __init__(self):\n        self._first = None\n    def __nonzero__(self):\n        return self._first is not None \n    def append(self, value):\n        self._first = (value, self._first)\n    def pop(self):\n        if self._first is None:\n            raise IndexError(\"pop from empty stack\")\n        value, self._first = self._first\n        return value\n\nwhile not stack.empty():\n pass \nwhile stack:\n pass\n", "human_summarization": "implement a stack data structure supporting basic operations such as push, pop, and empty check. The stack follows a last in, first out (LIFO) access policy. The implementation can be done using a deque for faster performance or a linked list for a simpler interface.", "id": "4672", "incomplete_code": "from collections import deque\nstack = deque()\nstack.append(value)\nvalue = stack.pop()\nnot stack\nfrom collections import deque\n\nclass Stack:\n\n    def __init__(self):\n        pass\n\n    def append(self, item):\n        pass\n\n    def pop(self):\n        pass\n\n    def __nonzero__(self):\n        pass\n\nclass Stack:\n\n    def __init__(self):\n        pass\n\n    def __nonzero__(self):\n        pass\n\n    def append(self, value):\n        pass\n\n    def pop(self):\n        pass\nwhile not stack.empty():\n    pass\nwhile stack:\n    pass", "original_code": "\n# Works with: Python version 2.5\n\nfrom collections import deque\nstack = deque()\nstack.append(value) # pushing\nvalue = stack.pop()\nnot stack # is empty?\n\nfrom collections import deque\n\nclass Stack:\n    def __init__(self):\n        self._items = deque()\n    def append(self, item):\n        self._items.append(item)\n    def pop(self):\n        return self._items.pop()\n    def __nonzero__(self):\n        return bool(self._items)\n\nclass Stack:\n    def __init__(self):\n        self._first = None\n    def __nonzero__(self):\n        return self._first is not None \n    def append(self, value):\n        self._first = (value, self._first)\n    def pop(self):\n        if self._first is None:\n            raise IndexError(\"pop from empty stack\")\n        value, self._first = self._first\n        return value\n\nwhile not stack.empty():\n pass \nwhile stack:\n pass\n", "perturbed_code": "\nfrom collections import deque\nwhile stack:\n    pass\nstack = deque()\nstack.append(value)\nvalue = stack.pop()\n(not stack)\nfrom collections import deque\n\nclass Stack():\n\n    def __init__(self):\n        self._items = deque()\n\n    def append(self, item):\n        self._items.append(item)\n\n    def pop(self):\n        return self._items.pop()\n\n    def __nonzero__(self):\n        return bool(self._items)\n\nclass Stack():\n\n    def __init__(self):\n        self._first = None\n\n    def __nonzero__(self):\n        return (self._first is not None)\n\n    def append(self, value):\n        self._first = (value, self._first)\n\n    def pop(self):\n        if (self._first is None):\n            raise IndexError('pop from empty stack')\n        (value, self._first) = self._first\n        return value\nwhile (not stack.empty()):\n    pass\n", "incomplete_perturbed_code": "from collections import deque\nwhile stack:\n    pass\nstack = deque()\nstack.append(value)\nvalue = stack.pop()\nnot stack\nfrom collections import deque\n\nclass Stack:\n\n    def __init__(self):\n        pass\n\n    def append(self, item):\n        pass\n\n    def pop(self):\n        pass\n\n    def __nonzero__(self):\n        pass\n\nclass Stack:\n\n    def __init__(self):\n        pass\n\n    def __nonzero__(self):\n        pass\n\n    def append(self, value):\n        pass\n\n    def pop(self):\n        pass\nwhile not stack.empty():\n    pass", "adversarial_score": 4, "original_score": 4, "search_time_seconds": 50.9798367023468, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 4, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 20, "successful_llm_evaluations": 20, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 80, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 4}, "adversarial_completion": "from collections import deque\n\nclass Stack:\n\n    def __init__(self):\n        self._data = deque()\n\n    def __nonzero__(self):\n        return bool(self._data)\n\n    def append(self, value):\n        self._data.append(value)\n\n    def pop(self):\n        if not self._data:\n            return None  # Or raise an exception, e.g., IndexError\n        return self._data.pop()", "score_distribution_all_attempts": [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]}
{"lang_cluster": "Python", "source_code": "\n\nfrom collections import namedtuple, deque\nfrom pprint import pprint as pp\n \n \ninf = float('inf')\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\n \nclass Graph():\n    def __init__(self, edges):\n        self.edges = [Edge(*edge) for edge in edges]\n        # print(dir(self.edges[0]))\n        self.vertices = {e.start for e in self.edges} | {e.end for e in self.edges}\n \n    def dijkstra(self, source, dest):\n        assert source in self.vertices\n        dist = {vertex: inf for vertex in self.vertices}\n        previous = {vertex: None for vertex in self.vertices}\n        dist[source] = 0\n        q = self.vertices.copy()\n        neighbours = {vertex: set() for vertex in self.vertices}\n        for start, end, cost in self.edges:\n            neighbours[start].add((end, cost))\n            neighbours[end].add((start, cost))\n\n        #pp(neighbours)\n \n        while q:\n            # pp(q)\n            u = min(q, key=lambda vertex: dist[vertex])\n            q.remove(u)\n            if dist[u] == inf or u == dest:\n                break\n            for v, cost in neighbours[u]:\n                alt = dist[u] + cost\n                if alt < dist[v]:                                  # Relax (u,v,a)\n                    dist[v] = alt\n                    previous[v] = u\n        #pp(previous)\n        s, u = deque(), dest\n        while previous[u]:\n            s.appendleft(u)\n            u = previous[u]\n        s.appendleft(u)\n        return s\n \n \ngraph = Graph([(\"a\", \"b\", 7),  (\"a\", \"c\", 9),  (\"a\", \"f\", 14), (\"b\", \"c\", 10),\n               (\"b\", \"d\", 15), (\"c\", \"d\", 11), (\"c\", \"f\", 2),  (\"d\", \"e\", 6),\n               (\"e\", \"f\", 9)])\npp(graph.dijkstra(\"a\", \"e\"))\n\n\n", "human_summarization": "Implement Dijkstra's algorithm to find the shortest path from a given source node to all other nodes in a graph. The graph is represented by an adjacency matrix or list and a start node. The algorithm outputs a set of edges that depict the shortest path to each reachable node from the origin. The code also includes functionality to interpret the output and display the shortest path from the source node to specific nodes.", "id": "4678", "incomplete_code": "from collections import namedtuple, deque\nfrom pprint import pprint as pp\ninf = float('inf')\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\n\nclass Graph:\n\n    def __init__(self, edges):\n        pass\n\n    def dijkstra(self, source, dest):\n        pass\ngraph = Graph([('a', 'b', 7), ('a', 'c', 9), ('a', 'f', 14), ('b', 'c', 10), ('b', 'd', 15), ('c', 'd', 11), ('c', 'f', 2), ('d', 'e', 6), ('e', 'f', 9)])\npp(graph.dijkstra('a', 'e'))", "original_code": "\n\nfrom collections import namedtuple, deque\nfrom pprint import pprint as pp\n \n \ninf = float('inf')\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\n \nclass Graph():\n    def __init__(self, edges):\n        self.edges = [Edge(*edge) for edge in edges]\n        # print(dir(self.edges[0]))\n        self.vertices = {e.start for e in self.edges} | {e.end for e in self.edges}\n \n    def dijkstra(self, source, dest):\n        assert source in self.vertices\n        dist = {vertex: inf for vertex in self.vertices}\n        previous = {vertex: None for vertex in self.vertices}\n        dist[source] = 0\n        q = self.vertices.copy()\n        neighbours = {vertex: set() for vertex in self.vertices}\n        for start, end, cost in self.edges:\n            neighbours[start].add((end, cost))\n            neighbours[end].add((start, cost))\n\n        #pp(neighbours)\n \n        while q:\n            # pp(q)\n            u = min(q, key=lambda vertex: dist[vertex])\n            q.remove(u)\n            if dist[u] == inf or u == dest:\n                break\n            for v, cost in neighbours[u]:\n                alt = dist[u] + cost\n                if alt < dist[v]:                                  # Relax (u,v,a)\n                    dist[v] = alt\n                    previous[v] = u\n        #pp(previous)\n        s, u = deque(), dest\n        while previous[u]:\n            s.appendleft(u)\n            u = previous[u]\n        s.appendleft(u)\n        return s\n \n \ngraph = Graph([(\"a\", \"b\", 7),  (\"a\", \"c\", 9),  (\"a\", \"f\", 14), (\"b\", \"c\", 10),\n               (\"b\", \"d\", 15), (\"c\", \"d\", 11), (\"c\", \"f\", 2),  (\"d\", \"e\", 6),\n               (\"e\", \"f\", 9)])\npp(graph.dijkstra(\"a\", \"e\"))\n\n\n", "perturbed_code": "\nfrom pprint import pprint as pp\ninf = float('inf')\nfrom collections import namedtuple, deque\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\ngraph = Graph([('a', 'b', 7), ('a', 'c', 9), ('a', 'f', 14), ('b', 'c', 10), ('b', 'd', 15), ('c', 'd', 11), ('c', 'f', 2), ('d', 'e', 6), ('e', 'f', 9)])\n\nclass Graph():\n\n    def __init__(self, edges):\n        self.edges = [Edge(*edge) for edge in edges]\n        self.vertices = ({e.start for e in self.edges} | {e.end for e in self.edges})\n\n    def dijkstra(self, source, dest):\n        while previous[u]:\n            s.appendleft(u)\n            u = previous[u]\n        assert (source in self.vertices)\n        while q:\n            for (v, cost) in neighbours[u]:\n                alt = (cost + dist[u])\n                if (alt < dist[v]):\n                    dist[v] = alt\n                    previous[v] = u\n            if ((inf == dist[u]) or (u == dest)):\n                break\n            u = min(q, key=(lambda vertex: dist[vertex]))\n            q.remove(u)\n        for (start, end, cost) in self.edges:\n            neighbours[start].add((end, cost))\n            neighbours[end].add((start, cost))\n        dist = {vertex: inf for vertex in self.vertices}\n        previous = {vertex: None for vertex in self.vertices}\n        dist[source] = 0\n        q = self.vertices.copy()\n        neighbours = {vertex: set() for vertex in self.vertices}\n        (s, u) = (deque(), dest)\n        s.appendleft(u)\n        return s\npp(graph.dijkstra('a', 'e'))\n", "incomplete_perturbed_code": "from pprint import pprint as pp\ninf = float('inf')\nfrom collections import namedtuple, deque\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\ngraph = Graph([('a', 'b', 7), ('a', 'c', 9), ('a', 'f', 14), ('b', 'c', 10), ('b', 'd', 15), ('c', 'd', 11), ('c', 'f', 2), ('d', 'e', 6), ('e', 'f', 9)])\n\nclass Graph:\n\n    def __init__(self, edges):\n        pass\n\n    def dijkstra(self, source, dest):\n        pass\npp(graph.dijkstra('a', 'e'))", "adversarial_score": 2, "original_score": 3, "search_time_seconds": 460.80236887931824, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 78, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 81, "successful_llm_evaluations": 81, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 19, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 78}, "adversarial_completion": "from pprint import pprint as pp\ninf = float('inf')\nfrom collections import namedtuple, deque\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\ngraph = Graph([('a', 'b', 7), ('a', 'c', 9), ('a', 'f', 14), ('b', 'c', 10), ('b', 'd', 15), ('c', 'd', 11), ('c', 'f', 2), ('d', 'e', 6), ('e', 'f', 9)])\n\nclass Graph:\n\n    def __init__(self, edges):\n        self.edges = edges\n        self.adj = {}\n        for start, end, cost in edges:\n            if start not in self.adj:\n                self.adj[start] = []\n            self.adj[start].append((end, cost))\n\n    def dijkstra(self, source, dest):\n        dist = {node: inf for node in self.adj}\n        dist[source] = 0\n        prev = {node: None for node in self.adj}\n        pq = deque([(0, source)])\n\n        while pq:\n            d, u = pq.popleft()\n\n            if d > dist[u]:\n                continue\n\n            if u not in self.adj:\n                continue\n\n            for v, weight in self.adj[u]:\n                if dist[v] > dist[u] + weight:\n                    dist[v] = dist[u] + weight\n                    prev[v] = u\n                    pq.append((dist[v], v))\n                    pq = deque(sorted(pq, key=lambda x: x[0]))\n\n        path = {}\n        if dist[dest] == inf:\n            return None\n\n        curr = dest\n        while curr is not None:\n            path[curr] = prev[curr]\n            curr = prev[curr]\n\n        result = []\n        for node in self.adj:\n            if node != source and dist[node] != inf:\n                curr = node\n                path_edges = []\n                while prev[curr] is not None:\n                    path_edges.append(Edge(prev[curr], curr, 0))\n                    curr = prev[curr]\n                result.append(path_edges)\n        \n        return result\npp(graph.dijkstra('a', 'e'))", "score_distribution_all_attempts": [2, 3, 3, 3, 3, 2, 3, 2, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 2, 2, 3, 3, 2, 3, 2, 2, 3, 3, 2, 2, 2, 3, 3, 2, 2, 3, 2, 2, 2, 2, 3, 2, 2, 3, 3, 3, 2, 3, 3, 3, 2, 2, 3, 2, 3, 2, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 3, 3, 3, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3]}
{"lang_cluster": "Python", "source_code": "\n\nfrom collections import namedtuple\nfrom math import sqrt\n\nPt = namedtuple('Pt', 'x, y')\nCircle = Cir = namedtuple('Circle', 'x, y, r')\n\ndef circles_from_p1p2r(p1, p2, r):\n    'Following explanation at http://mathforum.org/library/drmath/view/53027.html'\n    if r == 0.0:\n        raise ValueError('radius of zero')\n    (x1, y1), (x2, y2) = p1, p2\n    if p1 == p2:\n        raise ValueError('coincident points gives infinite number of Circles')\n    # delta x, delta y between points\n    dx, dy = x2 - x1, y2 - y1\n    # dist between points\n    q = sqrt(dx**2 + dy**2)\n    if q > 2.0*r:\n        raise ValueError('separation of points > diameter')\n    # halfway point\n    x3, y3 = (x1+x2)/2, (y1+y2)/2\n    # distance along the mirror line\n    d = sqrt(r**2-(q/2)**2)\n    # One answer\n    c1 = Cir(x = x3 - d*dy/q,\n             y = y3 + d*dx/q,\n             r = abs(r))\n    # The other answer\n    c2 = Cir(x = x3 + d*dy/q,\n             y = y3 - d*dx/q,\n             r = abs(r))\n    return c1, c2\n\nif __name__ == '__main__':\n    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0),\n                      (Pt(0.0000, 2.0000), Pt(0.0000, 0.0000), 1.0),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0),\n                      (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:\n        print('Through points:\\n  %r,\\n  %r\\n  and radius %f\\nYou can construct the following circles:'\n              % (p1, p2, r))\n        try:\n            print('  %r\\n  %r\\n' % circles_from_p1p2r(p1, p2, r))\n        except ValueError as v:\n            print('  ERROR: %s\\n' % (v.args[0],))\n\n\n", "human_summarization": "The code defines a function that calculates and returns two circles that can be drawn through two given points with a specified radius. The function handles special cases such as when the radius is zero, the points are coincident, the points form a diameter, or the points are too far apart. The function raises a ValueError for these special cases and uses try-except to handle these exceptions. It also includes a task to calculate the total area of the circles. The function's output for specific inputs is also demonstrated.", "id": "4679", "incomplete_code": "from collections import namedtuple\nfrom math import sqrt\nPt = namedtuple('Pt', 'x, y')\nCircle = Cir = namedtuple('Circle', 'x, y, r')\n\ndef circles_from_p1p2r(p1, p2, r):\n    \"\"\"Following explanation at http://mathforum.org/library/drmath/view/53027.html\"\"\"\n    pass\nif __name__ == '__main__':\n    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0), (Pt(0.0, 2.0), Pt(0.0, 0.0), 1.0), (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0), (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5), (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:\n        print('Through points:\\n  %r,\\n  %r\\n  and radius %f\\nYou can construct the following circles:' % (p1, p2, r))\n        try:\n            print('  %r\\n  %r\\n' % circles_from_p1p2r(p1, p2, r))\n        except ValueError as v:\n            print('  ERROR: %s\\n' % (v.args[0],))", "original_code": "\n\nfrom collections import namedtuple\nfrom math import sqrt\n\nPt = namedtuple('Pt', 'x, y')\nCircle = Cir = namedtuple('Circle', 'x, y, r')\n\ndef circles_from_p1p2r(p1, p2, r):\n    'Following explanation at http://mathforum.org/library/drmath/view/53027.html'\n    if r == 0.0:\n        raise ValueError('radius of zero')\n    (x1, y1), (x2, y2) = p1, p2\n    if p1 == p2:\n        raise ValueError('coincident points gives infinite number of Circles')\n    # delta x, delta y between points\n    dx, dy = x2 - x1, y2 - y1\n    # dist between points\n    q = sqrt(dx**2 + dy**2)\n    if q > 2.0*r:\n        raise ValueError('separation of points > diameter')\n    # halfway point\n    x3, y3 = (x1+x2)/2, (y1+y2)/2\n    # distance along the mirror line\n    d = sqrt(r**2-(q/2)**2)\n    # One answer\n    c1 = Cir(x = x3 - d*dy/q,\n             y = y3 + d*dx/q,\n             r = abs(r))\n    # The other answer\n    c2 = Cir(x = x3 + d*dy/q,\n             y = y3 - d*dx/q,\n             r = abs(r))\n    return c1, c2\n\nif __name__ == '__main__':\n    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0),\n                      (Pt(0.0000, 2.0000), Pt(0.0000, 0.0000), 1.0),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0),\n                      (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:\n        print('Through points:\\n  %r,\\n  %r\\n  and radius %f\\nYou can construct the following circles:'\n              % (p1, p2, r))\n        try:\n            print('  %r\\n  %r\\n' % circles_from_p1p2r(p1, p2, r))\n        except ValueError as v:\n            print('  ERROR: %s\\n' % (v.args[0],))\n\n\n", "perturbed_code": "\nfrom math import sqrt\nfrom collections import namedtuple\nPt = namedtuple('Pt', 'x, y')\nCircle = Cir = namedtuple('Circle', 'x, y, r')\n\ndef circles_from_p1p2r(p1, p2, r):\n    if (q > (r * 2.0)):\n        raise ValueError('separation of points > diameter')\n    'Following explanation at http://mathforum.org/library/drmath/view/53027.html'\n    if (p2 == p1):\n        raise ValueError('coincident points gives infinite number of Circles')\n    if (r == 0.0):\n        raise ValueError('radius of zero')\n    ((x1, y1), (x2, y2)) = (p1, p2)\n    (dx, dy) = ((x2 - x1), (y2 - y1))\n    q = sqrt(((dy ** 2) + (dx ** 2)))\n    (x3, y3) = (((x1 + x2) / 2), ((y1 + y2) / 2))\n    d = sqrt(((r ** 2) - ((q / 2) ** 2)))\n    c1 = Cir(x=(x3 - ((d * dy) / q)), y=(((dx * d) / q) + y3), r=abs(r))\n    c2 = Cir(x=(x3 + ((d * dy) / q)), y=(y3 - ((d * dx) / q)), r=abs(r))\n    return (c1, c2)\nif (__name__ == '__main__'):\n    for (p1, p2, r) in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0), (Pt(0.0, 2.0), Pt(0.0, 0.0), 1.0), (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0), (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5), (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:\n        print(('Through points:\\n  %r,\\n  %r\\n  and radius %f\\nYou can construct the following circles:' % (p1, p2, r)))\n        try:\n            print(('  %r\\n  %r\\n' % circles_from_p1p2r(p1, p2, r)))\n        except ValueError as v:\n            print(('  ERROR: %s\\n' % (v.args[0],)))\n", "incomplete_perturbed_code": "from math import sqrt\nfrom collections import namedtuple\nPt = namedtuple('Pt', 'x, y')\nCircle = Cir = namedtuple('Circle', 'x, y, r')\n\ndef circles_from_p1p2r(p1, p2, r):\n    pass\nif __name__ == '__main__':\n    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0), (Pt(0.0, 2.0), Pt(0.0, 0.0), 1.0), (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0), (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5), (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:\n        print('Through points:\\n  %r,\\n  %r\\n  and radius %f\\nYou can construct the following circles:' % (p1, p2, r))\n        try:\n            print('  %r\\n  %r\\n' % circles_from_p1p2r(p1, p2, r))\n        except ValueError as v:\n            print('  ERROR: %s\\n' % (v.args[0],))", "adversarial_score": 2, "original_score": 3, "search_time_seconds": 542.1127769947052, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 100, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 100, "successful_llm_evaluations": 100, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 0, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 100}, "adversarial_completion": "from math import sqrt\nfrom collections import namedtuple\nPt = namedtuple('Pt', 'x, y')\nCircle = Cir = namedtuple('Circle', 'x, y, r')\n\ndef circles_from_p1p2r(p1, p2, r):\n    \"\"\"\n    Calculates and returns two circles that can be drawn through two given points with a specified radius.\n\n    Args:\n        p1 (Pt): The first point.\n        p2 (Pt): The second point.\n        r (float): The radius of the circles.\n\n    Returns:\n        tuple: A tuple containing two Circle namedtuples representing the circles.\n\n    Raises:\n        ValueError: If the radius is zero, the points are coincident, the points form a diameter, or the points are too far apart.\n    \"\"\"\n    if r == 0:\n        raise ValueError(\"Radius cannot be zero.\")\n    if p1 == p2:\n        raise ValueError(\"Points cannot be coincident.\")\n\n    x1, y1 = p1.x, p1.y\n    x2, y2 = p2.x, p2.y\n\n    d = sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    if d > 2 * r:\n        raise ValueError(\"Points are too far apart.\")\n    if d == 2 * r:\n        mid_x = (x1 + x2) / 2\n        mid_y = (y1 + y2) / 2\n        return (Cir(mid_x, mid_y, r),)\n\n    mid_x = (x1 + x2) / 2\n    mid_y = (y1 + y2) / 2\n    h = sqrt(r**2 - (d/2)**2)\n    \n    x_offset = h * (y2 - y1) / d\n    y_offset = h * (x1 - x2) / d\n\n    circle1_x = mid_x + x_offset\n    circle1_y = mid_y + y_offset\n    circle2_x = mid_x - x_offset\n    circle2_y = mid_y - y_offset\n\n    return (Cir(circle1_x, circle1_y, r), Cir(circle2_x, circle2_y, r))\nif __name__ == '__main__':\n    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0), (Pt(0.0, 2.0), Pt(0.0, 0.0), 1.0), (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0), (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5), (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:\n        print('Through points:\\n  %r,\\n  %r\\n  and radius %f\\nYou can construct the following circles:' % (p1, p2, r))\n        try:\n            print('  %r\\n  %r\\n' % circles_from_p1p2r(p1, p2, r))\n        except ValueError as v:\n            print('  ERROR: %s\\n' % (v.args[0],))", "score_distribution_all_attempts": [3, 2, 3, 2, 2, 3, 2, 3, 3, 3, 3, 3, 3, 2, 3, 2, 3, 3, 2, 2, 3, 3, 2, 2, 3, 3, 2, 2, 2, 3, 2, 3, 3, 3, 2, 2, 2, 2, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 2, 3, 3, 2, 3, 2, 3, 3, 3, 2, 3, 2, 2, 3, 2, 3, 2, 3, 3, 3, 2, 3, 2, 2, 3, 2, 3, 2, 2, 2, 3, 3, 3, 2, 3, 3, 2, 3, 3, 2, 2, 2]}
{"lang_cluster": "Python", "source_code": "k8 = [\t14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7 ] \nk7 = [\t15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10 ]\nk6 = [\t10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8 ]\nk5 = [\t 7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15 ]\nk4 = [\t 2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9 ]\nk3 = [\t12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11 ]\nk2 = [\t 4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1 ]\nk1 = [\t13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7 ]\n \nk87 = [0] * 256\nk65 = [0] * 256\nk43 = [0] * 256\nk21 = [0] * 256\n \ndef kboxinit():\n\tfor i in range(256):\n\t\tk87[i] = k8[i >> 4] << 4 | k7[i & 15]\n\t\tk65[i] = k6[i >> 4] << 4 | k5[i & 15]\n\t\tk43[i] = k4[i >> 4] << 4 | k3[i & 15]\n\t\tk21[i] = k2[i >> 4] << 4 | k1[i & 15]\n \ndef f(x):\n\tx = ( k87[x>>24 & 255] << 24 | k65[x>>16 & 255] << 16 |\n\t      k43[x>> 8 & 255] <<  8 | k21[x & 255] )\n\treturn x<<11 | x>>(32-11)\n\n", "human_summarization": "Implement the main step of the GOST 28147-89 symmetric encryption algorithm, which involves taking a 64-bit block of text and one of the eight 32-bit encryption key elements, using a replacement table, and returning an encrypted block.", "id": "4680", "incomplete_code": "k8 = [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7]\nk7 = [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10]\nk6 = [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8]\nk5 = [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15]\nk4 = [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9]\nk3 = [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11]\nk2 = [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1]\nk1 = [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7]\nk87 = [0] * 256\nk65 = [0] * 256\nk43 = [0] * 256\nk21 = [0] * 256\n\ndef kboxinit():\n    pass\n\ndef f(x):\n    pass", "original_code": "k8 = [\t14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7 ] \nk7 = [\t15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10 ]\nk6 = [\t10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8 ]\nk5 = [\t 7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15 ]\nk4 = [\t 2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9 ]\nk3 = [\t12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11 ]\nk2 = [\t 4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1 ]\nk1 = [\t13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7 ]\n \nk87 = [0] * 256\nk65 = [0] * 256\nk43 = [0] * 256\nk21 = [0] * 256\n \ndef kboxinit():\n\tfor i in range(256):\n\t\tk87[i] = k8[i >> 4] << 4 | k7[i & 15]\n\t\tk65[i] = k6[i >> 4] << 4 | k5[i & 15]\n\t\tk43[i] = k4[i >> 4] << 4 | k3[i & 15]\n\t\tk21[i] = k2[i >> 4] << 4 | k1[i & 15]\n \ndef f(x):\n\tx = ( k87[x>>24 & 255] << 24 | k65[x>>16 & 255] << 16 |\n\t      k43[x>> 8 & 255] <<  8 | k21[x & 255] )\n\treturn x<<11 | x>>(32-11)\n\n", "perturbed_code": "\nk43 = ([0] * 256)\nk1 = [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7]\nk4 = [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9]\nk21 = ([0] * 256)\nk87 = (256 * [0])\nk8 = [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7]\n\ndef kboxinit():\n    for i in range(256):\n        k87[i] = ((k8[(i >> 4)] << 4) | k7[(i & 15)])\n        k21[i] = ((k2[(i >> 4)] << 4) | k1[(i & 15)])\n        k43[i] = ((k4[(i >> 4)] << 4) | k3[(15 & i)])\n        k65[i] = ((k6[(i >> 4)] << 4) | k5[(i & 15)])\nk5 = [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15]\nk3 = [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11]\nk7 = [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10]\nk2 = [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1]\nk6 = [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8]\nk65 = (256 * [0])\n\ndef f(x):\n    x = (k21[(x & 255)] | (((k65[(255 & (x >> 16))] << 16) | (k87[((x >> 24) & 255)] << 24)) | (k43[(255 & (x >> 8))] << 8)))\n    return ((x >> (32 - 11)) | (x << 11))\n", "incomplete_perturbed_code": "k43 = [0] * 256\nk1 = [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7]\nk4 = [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9]\nk21 = [0] * 256\nk87 = 256 * [0]\nk8 = [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7]\n\ndef kboxinit():\n    pass\nk5 = [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15]\nk3 = [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11]\nk7 = [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10]\nk2 = [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1]\nk6 = [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8]\nk65 = 256 * [0]\n\ndef f(x):\n    pass", "adversarial_score": 2, "original_score": 2, "search_time_seconds": 1728.4446954727173, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 100, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 100, "successful_llm_evaluations": 100, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 0, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 100}, "adversarial_completion": "k43 = [0] * 256\nk1 = [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7]\nk4 = [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9]\nk21 = [0] * 256\nk87 = 256 * [0]\nk8 = [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7]\n\ndef kboxinit():\n    for i in range(256):\n        k21[i] = k1[i % 16] ^ k4[i % 16]\n\nk5 = [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15]\nk3 = [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11]\nk7 = [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10]\nk2 = [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1]\nk6 = [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8]\nk65 = 256 * [0]\n\ndef f(x):\n    return kboxinit()\n    \n    return 0", "score_distribution_all_attempts": [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]}
{"lang_cluster": "Python", "source_code": "\nLibrary: NumPy\n\n#!/usr/bin/env python3\n\nimport numpy as np\n\ndef qr(A):\n    m, n = A.shape\n    Q = np.eye(m)\n    for i in range(n - (m == n)):\n        H = np.eye(m)\n        H[i:, i:] = make_householder(A[i:, i])\n        Q = np.dot(Q, H)\n        A = np.dot(H, A)\n    return Q, A\n\ndef make_householder(a):\n    v = a / (a[0] + np.copysign(np.linalg.norm(a), a[0]))\n    v[0] = 1\n    H = np.eye(a.shape[0])\n    H -= (2 / np.dot(v, v)) * np.dot(v[:, None], v[None, :])\n    return H\n\n# task 1: show qr decomp of wp example\na = np.array(((\n    (12, -51,   4),\n    ( 6, 167, -68),\n    (-4,  24, -41),\n)))\n\nq, r = qr(a)\nprint('q:\\n', q.round(6))\nprint('r:\\n', r.round(6))\n\n# task 2: use qr decomp for polynomial regression example\ndef polyfit(x, y, n):\n    return lsqr(x[:, None]**np.arange(n + 1), y.T)\n\ndef lsqr(a, b):\n    q, r = qr(a)\n    _, n = r.shape\n    return np.linalg.solve(r[:n, :], np.dot(q.T, b)[:n])\n\nx = np.array((0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\ny = np.array((1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321))\n\nprint('\\npolyfit:\\n', polyfit(x, y, 2))\n\n\n", "human_summarization": "implement QR decomposition of a matrix using the method of Householder reflections. The code demonstrates the decomposition on a given example matrix and shows its usage for solving linear least squares problems. The code also includes a reimplementation of the Numpy's QR function to illustrate the construction and use of Householder reflections.", "id": 4686, "incomplete_code": "Library: NumPy\nimport numpy as np\n\ndef qr(A):\n    pass\n\ndef make_householder(a):\n    pass\na = np.array(((12, -51, 4), (6, 167, -68), (-4, 24, -41)))\nq, r = qr(a)\nprint('q:\\n', q.round(6))\nprint('r:\\n', r.round(6))\n\ndef polyfit(x, y, n):\n    pass\n\ndef lsqr(a, b):\n    pass\nx = np.array((0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\ny = np.array((1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321))\nprint('\\npolyfit:\\n', polyfit(x, y, 2))", "original_code": "\nLibrary: NumPy\n\n#!/usr/bin/env python3\n\nimport numpy as np\n\ndef qr(A):\n    m, n = A.shape\n    Q = np.eye(m)\n    for i in range(n - (m == n)):\n        H = np.eye(m)\n        H[i:, i:] = make_householder(A[i:, i])\n        Q = np.dot(Q, H)\n        A = np.dot(H, A)\n    return Q, A\n\ndef make_householder(a):\n    v = a / (a[0] + np.copysign(np.linalg.norm(a), a[0]))\n    v[0] = 1\n    H = np.eye(a.shape[0])\n    H -= (2 / np.dot(v, v)) * np.dot(v[:, None], v[None, :])\n    return H\n\n# task 1: show qr decomp of wp example\na = np.array(((\n    (12, -51,   4),\n    ( 6, 167, -68),\n    (-4,  24, -41),\n)))\n\nq, r = qr(a)\nprint('q:\\n', q.round(6))\nprint('r:\\n', r.round(6))\n\n# task 2: use qr decomp for polynomial regression example\ndef polyfit(x, y, n):\n    return lsqr(x[:, None]**np.arange(n + 1), y.T)\n\ndef lsqr(a, b):\n    q, r = qr(a)\n    _, n = r.shape\n    return np.linalg.solve(r[:n, :], np.dot(q.T, b)[:n])\n\nx = np.array((0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\ny = np.array((1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321))\n\nprint('\\npolyfit:\\n', polyfit(x, y, 2))\n\n\n", "perturbed_code": "\nLibrary: NumPy\n\n#!/usr/bin/env python3\n\nimport numpy as np\n\ndef qr(A):\n    m, n = A.shape\n    Q = np.eye(m)\n    for i in range(n - (m == n)):\n        H = np.eye(m)\n        H[i:, i:] = make_householder(A[i:, i])\n        Q = np.dot(Q, H)\n        A = np.dot(H, A)\n    return Q, A\n\ndef make_householder(a):\n    v = a / (a[0] + np.copysign(np.linalg.norm(a), a[0]))\n    v[0] = 1\n    H = np.eye(a.shape[0])\n    H -= (2 / np.dot(v, v)) * np.dot(v[:, None], v[None, :])\n    return H\n\n# task 1: show qr decomp of wp example\na = np.array(((\n    (12, -51,   4),\n    ( 6, 167, -68),\n    (-4,  24, -41),\n)))\n\nq, r = qr(a)\nprint('q:\\n', q.round(6))\nprint('r:\\n', r.round(6))\n\n# task 2: use qr decomp for polynomial regression example\ndef polyfit(x, y, n):\n    return lsqr(x[:, None]**np.arange(n + 1), y.T)\n\ndef lsqr(a, b):\n    q, r = qr(a)\n    _, n = r.shape\n    return np.linalg.solve(r[:n, :], np.dot(q.T, b)[:n])\n\nx = np.array((0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\ny = np.array((1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321))\n\nprint('\\npolyfit:\\n', polyfit(x, y, 2))\n\n\n", "adversarial_score": Infinity, "original_score": 3, "notes": "No valid adversarial evaluations"}
{"lang_cluster": "Python", "source_code": "\n\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = list(set(items))\n\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nhelperset = set()\nfor x in items:\n    if x not in helperset:\n        unique.append(x)\n        helperset.add(x)\n\nimport itertools\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = [k for k,g in itertools.groupby(sorted(items))]\n\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nfor x in items:\n    if x not in unique:\n        unique.append(x)\n\nfrom collections import OrderedDict as od\n\nprint(list(od.fromkeys([1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']).keys()))\n\nfrom itertools import (groupby)\n\n\n# nubByKey\u00a0:: (a -> b) -> [a] -> [a]\ndef nubByKey(k, xs):\n    return list(list(v)[0] for _, v in groupby(sorted(xs, key=k), key=k))\n\n\nxs = [\n    'apple', 'apple',\n    'ampersand', 'aPPLE', 'Apple',\n    'orange', 'ORANGE', 'Orange', 'orange', 'apple'\n]\nfor k in [\n    id,                      # default case sensitive uniqueness\n    lambda x: x.lower(),     # case-insensitive uniqueness\n    lambda x: x[0],          # unique first character (case-sensitive)\n    lambda x: x[0].lower(),  # unique first character (case-insensitive)\n]:\n    print (\n        nubByKey(k, xs)\n    )\n\n", "human_summarization": "implement methods to remove duplicate elements from an array. The methods include using a hash table, sorting and removing consecutive duplicates, and checking each element against the rest of the list. Additionally, the codes handle cases where elements are hashable or comparable, and provide a brute-force method when both conditions fail. The codes also consider the order of elements and offer solutions using the OrderedDict module. The codes can handle different types of uniqueness and duplication, including case-insensitivity with strings and uniqueness with respect to a dictionary key. The codes also allow the use of an equality predicate or a key function to define uniqueness.", "id": "4687", "incomplete_code": "items = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = list(set(items))\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nhelperset = set()\nfor x in items:\n    if x not in helperset:\n        unique.append(x)\n        helperset.add(x)\nimport itertools\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = [k for k, g in itertools.groupby(sorted(items))]\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nfor x in items:\n    if x not in unique:\n        unique.append(x)\nfrom collections import OrderedDict as od\nprint(list(od.fromkeys([1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']).keys()))\nfrom itertools import groupby\n\ndef nubByKey(k, xs):\n    pass\nxs = ['apple', 'apple', 'ampersand', 'aPPLE', 'Apple', 'orange', 'ORANGE', 'Orange', 'orange', 'apple']\nfor k in [id, lambda x: x.lower(), lambda x: x[0], lambda x: x[0].lower()]:\n    print(nubByKey(k, xs))", "original_code": "\n\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = list(set(items))\n\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nhelperset = set()\nfor x in items:\n    if x not in helperset:\n        unique.append(x)\n        helperset.add(x)\n\nimport itertools\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = [k for k,g in itertools.groupby(sorted(items))]\n\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nfor x in items:\n    if x not in unique:\n        unique.append(x)\n\nfrom collections import OrderedDict as od\n\nprint(list(od.fromkeys([1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']).keys()))\n\nfrom itertools import (groupby)\n\n\n# nubByKey\u00a0:: (a -> b) -> [a] -> [a]\ndef nubByKey(k, xs):\n    return list(list(v)[0] for _, v in groupby(sorted(xs, key=k), key=k))\n\n\nxs = [\n    'apple', 'apple',\n    'ampersand', 'aPPLE', 'Apple',\n    'orange', 'ORANGE', 'Orange', 'orange', 'apple'\n]\nfor k in [\n    id,                      # default case sensitive uniqueness\n    lambda x: x.lower(),     # case-insensitive uniqueness\n    lambda x: x[0],          # unique first character (case-sensitive)\n    lambda x: x[0].lower(),  # unique first character (case-insensitive)\n]:\n    print (\n        nubByKey(k, xs)\n    )\n\n", "perturbed_code": "\nfor k in [id, (lambda x: x.lower()), (lambda x: x[0]), (lambda x: x[0].lower())]:\n    print(nubByKey(k, xs))\nfor x in items:\n    if (x not in unique):\n        unique.append(x)\nfor x in items:\n    if (x not in helperset):\n        unique.append(x)\n        helperset.add(x)\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = list(set(items))\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nhelperset = set()\nimport itertools\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = [k for (k, g) in itertools.groupby(sorted(items))]\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nfrom collections import OrderedDict as od\nprint(list(od.fromkeys([1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']).keys()))\nfrom itertools import groupby\n\ndef nubByKey(k, xs):\n    return list((list(v)[0] for (_, v) in groupby(sorted(xs, key=k), key=k)))\nxs = ['apple', 'apple', 'ampersand', 'aPPLE', 'Apple', 'orange', 'ORANGE', 'Orange', 'orange', 'apple']\n", "incomplete_perturbed_code": "for k in [id, lambda x: x.lower(), lambda x: x[0], lambda x: x[0].lower()]:\n    print(nubByKey(k, xs))\nfor x in items:\n    if x not in unique:\n        unique.append(x)\nfor x in items:\n    if x not in helperset:\n        unique.append(x)\n        helperset.add(x)\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = list(set(items))\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nhelperset = set()\nimport itertools\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = [k for k, g in itertools.groupby(sorted(items))]\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nfrom collections import OrderedDict as od\nprint(list(od.fromkeys([1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']).keys()))\nfrom itertools import groupby\n\ndef nubByKey(k, xs):\n    pass\nxs = ['apple', 'apple', 'ampersand', 'aPPLE', 'Apple', 'orange', 'ORANGE', 'Orange', 'orange', 'apple']", "adversarial_score": 3, "original_score": 5, "search_time_seconds": 193.8659553527832, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 1, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 20, "successful_llm_evaluations": 20, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 80, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 1}, "adversarial_completion": "from itertools import groupby\n\ndef nubByKey(k, xs):\n    return [x[0] for x in groupby(sorted(xs, key=k))]\nxs = ['apple', 'apple', 'ampersand', 'aPPLE', 'Apple', 'orange', 'ORANGE', 'Orange', 'orange', 'apple']\nfor k in [id, lambda x: x.lower(), lambda x: x[0], lambda x: x[0].lower()]:\n    print(nubByKey(k, xs))\nfor x in items:\n    if x not in unique:\n        unique.append(x)\nfor x in items:\n    if x not in helperset:\n        unique.append(x)\n        helperset.add(x)\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = list(set(items))\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nhelperset = set()\nimport itertools\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = [k for k, g in itertools.groupby(sorted(items))]\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nfrom collections import OrderedDict as od\nprint(list(od.fromkeys([1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']).keys()))", "score_distribution_all_attempts": [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]}
{"lang_cluster": "Python", "source_code": "\ndef quickSort(arr):\n    less = []\n    pivotList = []\n    more = []\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr[0]\n        for i in arr:\n            if i < pivot:\n                less.append(i)\n            elif i > pivot:\n                more.append(i)\n            else:\n                pivotList.append(i)\n        less = quickSort(less)\n        more = quickSort(more)\n        return less + pivotList + more\n\na = [4, 65, 2, -31, 0, 99, 83, 782, 1]\na = quickSort(a)\n\ndef qsort(L):\n    return (qsort([y for y in L[1:] if y <  L[0]]) + \n            [L[0]] + \n            qsort([y for y in L[1:] if y >= L[0]])) if len(L) > 1 else L\n\ndef qsort(list):\n    if not list:\n        return []\n    else:\n        pivot = list[0]\n        less = [x for x in list[1:]   if x <  pivot]\n        more = [x for x in list[1:] if x >= pivot]\n        return qsort(less) + [pivot] + qsort(more)\n\nfrom random import *\n\ndef qSort(a):\n    if len(a) <= 1:\n        return a\n    else:\n        q = choice(a)\n        return qSort([elem for elem in a if elem < q]) + [q] * a.count(q) + qSort([elem for elem in a if elem > q])\n\ndef quickSort(a):\n    if len(a) <= 1:\n        return a\n    else:\n        less = []\n        more = []\n        pivot = choice(a)\n        for i in a:\n            if i < pivot:\n                less.append(i)\n            if i > pivot:\n                more.append(i)\n        less = quickSort(less)\n        more = quickSort(more)\n        return less + [pivot] * a.count(pivot) + more\n\ndef qsort(array):\n    if len(array) < 2:\n        return array\n    head, *tail = array\n    less = qsort([i for i in tail if i < head])\n    more = qsort([i for i in tail if i >= head])\n    return less + [head] + more\n\ndef quicksort(array):\n    _quicksort(array, 0, len(array) - 1)\n\ndef _quicksort(array, start, stop):\n    if stop - start > 0:\n        pivot, left, right = array[start], start, stop\n        while left <= right:\n            while array[left] < pivot:\n                left += 1\n            while array[right] > pivot:\n                right -= 1\n            if left <= right:\n                array[left], array[right] = array[right], array[left]\n                left += 1\n                right -= 1\n        _quicksort(array, start, right)\n        _quicksort(array, left, stop)\n", "human_summarization": "implement the quicksort algorithm to sort an array or list of elements. The elements have a strict weak order and the index of the array can be of any type. The algorithm works by choosing a pivot element and dividing the rest of the elements into two partitions based on their relation to the pivot. It then recursively sorts both partitions and combines them with the pivot to form the sorted array. The algorithm also includes an optimized version that works in place by swapping elements within the array to avoid additional memory allocation. The pivot selection method is not specified.", "id": "4688", "incomplete_code": "def quickSort(arr):\n    pass\na = [4, 65, 2, -31, 0, 99, 83, 782, 1]\na = quickSort(a)\n\ndef qsort(L):\n    pass\n\ndef qsort(list):\n    pass\nfrom random import *\n\ndef qSort(a):\n    pass\n\ndef quickSort(a):\n    pass\n\ndef qsort(array):\n    pass\n\ndef quicksort(array):\n    pass\n\ndef _quicksort(array, start, stop):\n    pass", "original_code": "\ndef quickSort(arr):\n    less = []\n    pivotList = []\n    more = []\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr[0]\n        for i in arr:\n            if i < pivot:\n                less.append(i)\n            elif i > pivot:\n                more.append(i)\n            else:\n                pivotList.append(i)\n        less = quickSort(less)\n        more = quickSort(more)\n        return less + pivotList + more\n\na = [4, 65, 2, -31, 0, 99, 83, 782, 1]\na = quickSort(a)\n\ndef qsort(L):\n    return (qsort([y for y in L[1:] if y <  L[0]]) + \n            [L[0]] + \n            qsort([y for y in L[1:] if y >= L[0]])) if len(L) > 1 else L\n\ndef qsort(list):\n    if not list:\n        return []\n    else:\n        pivot = list[0]\n        less = [x for x in list[1:]   if x <  pivot]\n        more = [x for x in list[1:] if x >= pivot]\n        return qsort(less) + [pivot] + qsort(more)\n\nfrom random import *\n\ndef qSort(a):\n    if len(a) <= 1:\n        return a\n    else:\n        q = choice(a)\n        return qSort([elem for elem in a if elem < q]) + [q] * a.count(q) + qSort([elem for elem in a if elem > q])\n\ndef quickSort(a):\n    if len(a) <= 1:\n        return a\n    else:\n        less = []\n        more = []\n        pivot = choice(a)\n        for i in a:\n            if i < pivot:\n                less.append(i)\n            if i > pivot:\n                more.append(i)\n        less = quickSort(less)\n        more = quickSort(more)\n        return less + [pivot] * a.count(pivot) + more\n\ndef qsort(array):\n    if len(array) < 2:\n        return array\n    head, *tail = array\n    less = qsort([i for i in tail if i < head])\n    more = qsort([i for i in tail if i >= head])\n    return less + [head] + more\n\ndef quicksort(array):\n    _quicksort(array, 0, len(array) - 1)\n\ndef _quicksort(array, start, stop):\n    if stop - start > 0:\n        pivot, left, right = array[start], start, stop\n        while left <= right:\n            while array[left] < pivot:\n                left += 1\n            while array[right] > pivot:\n                right -= 1\n            if left <= right:\n                array[left], array[right] = array[right], array[left]\n                left += 1\n                right -= 1\n        _quicksort(array, start, right)\n        _quicksort(array, left, stop)\n", "perturbed_code": "\n\ndef quickSort(arr):\n    if (len(arr) <= 1):\n        return arr\n    else:\n        for i in arr:\n            if (i < pivot):\n                less.append(i)\n            elif (i > pivot):\n                more.append(i)\n            else:\n                pivotList.append(i)\n        less = quickSort(less)\n        more = quickSort(more)\n        return ((pivotList + less) + more)\n        pivot = arr[0]\n    more = []\n    less = []\n    pivotList = []\na = [4, 65, 2, (- 31), 0, 99, 83, 782, 1]\n\ndef qsort(L):\n    return ((qsort([y for y in L[1:] if (y >= L[0])]) + ([L[0]] + qsort([y for y in L[1:] if (y < L[0])]))) if (len(L) > 1) else L)\n\ndef qsort(list):\n    if (not list):\n        return []\n    else:\n        pivot = list[0]\n        less = [x for x in list[1:] if (x < pivot)]\n        more = [x for x in list[1:] if (x >= pivot)]\n        return ((qsort(less) + [pivot]) + qsort(more))\nfrom random import *\n\ndef qSort(a):\n    if (len(a) <= 1):\n        return a\n    else:\n        q = choice(a)\n        return (((a.count(q) * [q]) + qSort([elem for elem in a if (elem < q)])) + qSort([elem for elem in a if (elem > q)]))\n\ndef quickSort(a):\n    if (len(a) <= 1):\n        return a\n    else:\n        for i in a:\n            if (i > pivot):\n                more.append(i)\n            if (i < pivot):\n                less.append(i)\n        less = []\n        more = []\n        pivot = choice(a)\n        less = quickSort(less)\n        more = quickSort(more)\n        return ((less + (a.count(pivot) * [pivot])) + more)\n\ndef qsort(array):\n    if (len(array) < 2):\n        return array\n    (head, *tail) = array\n    less = qsort([i for i in tail if (i < head)])\n    more = qsort([i for i in tail if (i >= head)])\n    return (([head] + less) + more)\n\ndef quicksort(array):\n    _quicksort(array, 0, (len(array) - 1))\n\ndef _quicksort(array, start, stop):\n    if ((stop - start) > 0):\n        (pivot, left, right) = (array[start], start, stop)\n        while (left <= right):\n            if (left <= right):\n                (array[left], array[right]) = (array[right], array[left])\n                left += 1\n                right -= 1\n            while (array[right] > pivot):\n                right -= 1\n            while (array[left] < pivot):\n                left += 1\n        _quicksort(array, start, right)\n        _quicksort(array, left, stop)\na = quickSort(a)\n", "incomplete_perturbed_code": "def quickSort(arr):\n    pass\na = [4, 65, 2, -31, 0, 99, 83, 782, 1]\n\ndef qsort(L):\n    pass\n\ndef qsort(list):\n    pass\nfrom random import *\n\ndef qSort(a):\n    pass\n\ndef quickSort(a):\n    pass\n\ndef qsort(array):\n    pass\n\ndef quicksort(array):\n    pass\n\ndef _quicksort(array, start, stop):\n    pass\na = quickSort(a)", "adversarial_score": 4, "original_score": 4, "search_time_seconds": 431.0876212120056, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 100, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 100, "successful_llm_evaluations": 100, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 0, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 100}, "adversarial_completion": "def quickSort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quickSort(left) + middle + quickSort(right)\na = [4, 65, 2, -31, 0, 99, 83, 782, 1]\n\ndef qsort(L):\n    if len(L) <= 1:\n        return L\n    pivot = L[0]\n    less = [i for i in L[1:] if i <= pivot]\n    greater = [i for i in L[1:] if i > pivot]\n    return qsort(less) + [pivot] + qsort(greater)\n\ndef qsort(list):\n    if len(list) <= 1:\n        return list\n    pivot = list[len(list) // 2]\n    less = [i for i in list if i < pivot]\n    equal = [i for i in list if i == pivot]\n    greater = [i for i in list if i > pivot]\n    return qsort(less) + equal + qsort(greater)\nfrom random import *\n\ndef qSort(a):\n    if len(a) <= 1:\n        return a\n    pivot = a[randint(0, len(a) - 1)]\n    i = 0\n    j = len(a) - 1\n    while i <= j:\n        while a[i] < pivot:\n            i += 1\n        while a[j] > pivot:\n            j -= 1\n        if i <= j:\n            a[i], a[j] = a[j], a[i]\n            i += 1\n            j -= 1\n    return qSort(a[:j+1]) + [pivot] + qSort(a[i:])\n\ndef quickSort(a):\n    if len(a) <= 1:\n        return a\n    pivot = a[len(a) // 2]\n    less = [i for i in a if i < pivot]\n    equal = [i for i in a if i == pivot]\n    greater = [i for i in a if i > pivot]\n    return quickSort(less) + equal + quickSort(greater)\n\ndef qsort(array):\n    if len(array) <= 1:\n        return array\n    pivot = array[0]\n    less = []\n    equal = []\n    greater = []\n    for x in array:\n        if x < pivot:\n            less.append(x)\n        elif x == pivot:\n            equal.append(x)\n        else:\n            greater.append(x)\n    return qsort(less) + equal + qsort(greater)\n\ndef quicksort(array):\n    if len(array) <= 1:\n        return array\n    pivot = array[len(array) // 2]\n    less = [i for i in array if i < pivot]\n    equal = [i for i in array if i == pivot]\n    greater = [i for i in array if i > pivot]\n    return quicksort(less) + equal + quicksort(greater)\n\ndef _quicksort(array, start, stop):\n    if start < stop:\n        pivot_index = partition(array, start, stop)\n        _quicksort(array, start, pivot_index - 1)\n        _quicksort(array, pivot_index + 1, stop)\n\ndef partition(array, start, stop):\n    pivot = array[stop]\n    i = start - 1\n    for j in range(start, stop):\n        if array[j] <= pivot:\n            i += 1\n            array[i], array[j] = array[j], array[i]\n    array[i + 1], array[stop] = array[stop], array[i + 1]\n    return i + 1\na = quickSort(a)", "score_distribution_all_attempts": [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]}
{"lang_cluster": "Python", "source_code": "\n# Works with: Python version 2.7+ and 3.1+\nimport collections, sys\n\ndef filecharcount(openfile):\n    return sorted(collections.Counter(c for l in openfile for c in l).items())\n\nf = open(sys.argv[1])\nprint(filecharcount(f))\n\n\n# Works with: Python version 3\n'''Character counting as a fold'''\n\nfrom functools import reduce\nfrom itertools import repeat\nfrom os.path import expanduser\n\n\n# charCounts\u00a0:: String -> Dict Char Int\ndef charCounts(s):\n    '''A dictionary of\n       (character, frequency) mappings\n    '''\n    def tally(dct, c):\n        dct[c] = 1 + dct[c] if c in dct else 1\n        return dct\n    return reduce(tally, list(s), {})\n\n\n# TEST ----------------------------------------------------\n# main\u00a0:: IO ()\ndef main():\n    '''Listing in descending order of frequency.'''\n\n    print(\n        tabulated(\n            'Descending order of frequency:\\n'\n        )(compose(repr)(fst))(compose(str)(snd))(\n            5\n        )(stet)(\n            sorted(\n                charCounts(\n                    readFile('~/Code/charCount/readme.txt')\n                ).items(),\n                key=swap,\n                reverse=True\n            )\n        )\n    )\n\n\n# GENERIC -------------------------------------------------\n\n# chunksOf\u00a0:: Int -> [a] -> [[a]]\ndef chunksOf(n):\n    '''A series of lists of length n,\n       subdividing the contents of xs.\n       Where the length of xs is not evenly divible,\n       the final list will be shorter than n.'''\n    return lambda xs: reduce(\n        lambda a, i: a + [xs[i:n + i]],\n        range(0, len(xs), n), []\n    ) if 0 < n else []\n\n\n# compose (<<<)\u00a0:: (b -> c) -> (a -> b) -> a -> c\ndef compose(g):\n    '''Right to left function composition.'''\n    return lambda f: lambda x: g(f(x))\n\n\n# fst\u00a0:: (a, b) -> a\ndef fst(tpl):\n    '''First member of a pair.'''\n    return tpl[0]\n\n\n# readFile\u00a0:: FilePath -> IO String\ndef readFile(fp):\n    '''The contents of any file at the path\n       derived by expanding any ~ in fp.'''\n    with open(expanduser(fp), 'r', encoding='utf-8') as f:\n        return f.read()\n\n\n# paddedMatrix\u00a0:: a -> [[a]] -> [[a]]\ndef paddedMatrix(v):\n    ''''A list of rows padded to equal length\n        (where needed) with instances of the value v.'''\n    def go(rows):\n        return paddedRows(\n            len(max(rows, key=len))\n        )(v)(rows)\n    return lambda rows: go(rows) if rows else []\n\n\n# paddedRows\u00a0:: Int -> a -> [[a]] -[[a]]\ndef paddedRows(n):\n    '''A list of rows padded (but never truncated)\n       to length n with copies of value v.'''\n    def go(v, xs):\n        def pad(x):\n            d = n - len(x)\n            return (x + list(repeat(v, d))) if 0 < d else x\n        return list(map(pad, xs))\n    return lambda v: lambda xs: go(v, xs) if xs else []\n\n\n# showColumns\u00a0:: Int -> [String] -> String\ndef showColumns(n):\n    '''A column-wrapped string\n       derived from a list of rows.'''\n    def go(xs):\n        def fit(col):\n            w = len(max(col, key=len))\n\n            def pad(x):\n                return x.ljust(4 + w, ' ')\n            return ''.join(map(pad, col)).rstrip()\n\n        q, r = divmod(len(xs), n)\n        return '\\n'.join(map(\n            fit,\n            zip(*paddedMatrix('')(\n                chunksOf(q + int(bool(r)))(xs)\n            ))\n        ))\n    return lambda xs: go(xs)\n\n\n# snd\u00a0:: (a, b) -> b\ndef snd(tpl):\n    '''Second member of a pair.'''\n    return tpl[1]\n\n\n# stet\u00a0:: a -> a\ndef stet(x):\n    '''The identity function.\n       The usual 'id' is reserved in Python.'''\n    return x\n\n\n# swap\u00a0:: (a, b) -> (b, a)\ndef swap(tpl):\n    '''The swapped components of a pair.'''\n    return (tpl[1], tpl[0])\n\n\n# tabulated\u00a0:: String -> (a -> String) ->\n#                        (b -> String) ->\n#                        Int ->\n#                        (a -> b) -> [a] -> String\ndef tabulated(s):\n    '''Heading -> x display function -> fx display function ->\n          number of columns -> f -> value list -> tabular string.'''\n    def go(xShow, fxShow, intCols, f, xs):\n        def mxw(fshow, g):\n            return max(map(compose(len)(fshow), map(g, xs)))\n        w = mxw(xShow, lambda x: x)\n        fw = mxw(fxShow, f)\n        return s + '\\n' + showColumns(intCols)([\n            xShow(x).rjust(w, ' ') + ' -> ' + (\n                fxShow(f(x)).rjust(fw, ' ')\n            )\n            for x in xs\n        ])\n    return lambda xShow: lambda fxShow: lambda nCols: (\n        lambda f: lambda xs: go(\n            xShow, fxShow, nCols, f, xs\n        )\n    )\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\n\n", "human_summarization": "open a text file, count the frequency of each letter (A to Z), and print the results. The counting process is expressed using fold/reduce. The code can be imported into other Python scripts or used as a standalone script. It avoids unnecessary complexity by not using a numerically indexed array and by eliminating the need for converting letters into list indices.", "id": "4705", "incomplete_code": "import collections, sys\n\ndef filecharcount(openfile):\n    pass\nf = open(sys.argv[1])\nprint(filecharcount(f))\n'Character counting as a fold'\nfrom functools import reduce\nfrom itertools import repeat\nfrom os.path import expanduser\n\ndef charCounts(s):\n    \"\"\"A dictionary of\n       (character, frequency) mappings\n    \"\"\"\n    pass\n\ndef main():\n    \"\"\"Listing in descending order of frequency.\"\"\"\n    pass\n\ndef chunksOf(n):\n    \"\"\"A series of lists of length n,\n       subdividing the contents of xs.\n       Where the length of xs is not evenly divible,\n       the final list will be shorter than n.\"\"\"\n    pass\n\ndef compose(g):\n    \"\"\"Right to left function composition.\"\"\"\n    pass\n\ndef fst(tpl):\n    \"\"\"First member of a pair.\"\"\"\n    pass\n\ndef readFile(fp):\n    \"\"\"The contents of any file at the path\n       derived by expanding any ~ in fp.\"\"\"\n    pass\n\ndef paddedMatrix(v):\n    \"\"\"'A list of rows padded to equal length\n        (where needed) with instances of the value v.\"\"\"\n    pass\n\ndef paddedRows(n):\n    \"\"\"A list of rows padded (but never truncated)\n       to length n with copies of value v.\"\"\"\n    pass\n\ndef showColumns(n):\n    \"\"\"A column-wrapped string\n       derived from a list of rows.\"\"\"\n    pass\n\ndef snd(tpl):\n    \"\"\"Second member of a pair.\"\"\"\n    pass\n\ndef stet(x):\n    \"\"\"The identity function.\n       The usual 'id' is reserved in Python.\"\"\"\n    pass\n\ndef swap(tpl):\n    \"\"\"The swapped components of a pair.\"\"\"\n    pass\n\ndef tabulated(s):\n    \"\"\"Heading -> x display function -> fx display function ->\n          number of columns -> f -> value list -> tabular string.\"\"\"\n    pass\nif __name__ == '__main__':\n    main()", "original_code": "\n# Works with: Python version 2.7+ and 3.1+\nimport collections, sys\n\ndef filecharcount(openfile):\n    return sorted(collections.Counter(c for l in openfile for c in l).items())\n\nf = open(sys.argv[1])\nprint(filecharcount(f))\n\n\n# Works with: Python version 3\n'''Character counting as a fold'''\n\nfrom functools import reduce\nfrom itertools import repeat\nfrom os.path import expanduser\n\n\n# charCounts\u00a0:: String -> Dict Char Int\ndef charCounts(s):\n    '''A dictionary of\n       (character, frequency) mappings\n    '''\n    def tally(dct, c):\n        dct[c] = 1 + dct[c] if c in dct else 1\n        return dct\n    return reduce(tally, list(s), {})\n\n\n# TEST ----------------------------------------------------\n# main\u00a0:: IO ()\ndef main():\n    '''Listing in descending order of frequency.'''\n\n    print(\n        tabulated(\n            'Descending order of frequency:\\n'\n        )(compose(repr)(fst))(compose(str)(snd))(\n            5\n        )(stet)(\n            sorted(\n                charCounts(\n                    readFile('~/Code/charCount/readme.txt')\n                ).items(),\n                key=swap,\n                reverse=True\n            )\n        )\n    )\n\n\n# GENERIC -------------------------------------------------\n\n# chunksOf\u00a0:: Int -> [a] -> [[a]]\ndef chunksOf(n):\n    '''A series of lists of length n,\n       subdividing the contents of xs.\n       Where the length of xs is not evenly divible,\n       the final list will be shorter than n.'''\n    return lambda xs: reduce(\n        lambda a, i: a + [xs[i:n + i]],\n        range(0, len(xs), n), []\n    ) if 0 < n else []\n\n\n# compose (<<<)\u00a0:: (b -> c) -> (a -> b) -> a -> c\ndef compose(g):\n    '''Right to left function composition.'''\n    return lambda f: lambda x: g(f(x))\n\n\n# fst\u00a0:: (a, b) -> a\ndef fst(tpl):\n    '''First member of a pair.'''\n    return tpl[0]\n\n\n# readFile\u00a0:: FilePath -> IO String\ndef readFile(fp):\n    '''The contents of any file at the path\n       derived by expanding any ~ in fp.'''\n    with open(expanduser(fp), 'r', encoding='utf-8') as f:\n        return f.read()\n\n\n# paddedMatrix\u00a0:: a -> [[a]] -> [[a]]\ndef paddedMatrix(v):\n    ''''A list of rows padded to equal length\n        (where needed) with instances of the value v.'''\n    def go(rows):\n        return paddedRows(\n            len(max(rows, key=len))\n        )(v)(rows)\n    return lambda rows: go(rows) if rows else []\n\n\n# paddedRows\u00a0:: Int -> a -> [[a]] -[[a]]\ndef paddedRows(n):\n    '''A list of rows padded (but never truncated)\n       to length n with copies of value v.'''\n    def go(v, xs):\n        def pad(x):\n            d = n - len(x)\n            return (x + list(repeat(v, d))) if 0 < d else x\n        return list(map(pad, xs))\n    return lambda v: lambda xs: go(v, xs) if xs else []\n\n\n# showColumns\u00a0:: Int -> [String] -> String\ndef showColumns(n):\n    '''A column-wrapped string\n       derived from a list of rows.'''\n    def go(xs):\n        def fit(col):\n            w = len(max(col, key=len))\n\n            def pad(x):\n                return x.ljust(4 + w, ' ')\n            return ''.join(map(pad, col)).rstrip()\n\n        q, r = divmod(len(xs), n)\n        return '\\n'.join(map(\n            fit,\n            zip(*paddedMatrix('')(\n                chunksOf(q + int(bool(r)))(xs)\n            ))\n        ))\n    return lambda xs: go(xs)\n\n\n# snd\u00a0:: (a, b) -> b\ndef snd(tpl):\n    '''Second member of a pair.'''\n    return tpl[1]\n\n\n# stet\u00a0:: a -> a\ndef stet(x):\n    '''The identity function.\n       The usual 'id' is reserved in Python.'''\n    return x\n\n\n# swap\u00a0:: (a, b) -> (b, a)\ndef swap(tpl):\n    '''The swapped components of a pair.'''\n    return (tpl[1], tpl[0])\n\n\n# tabulated\u00a0:: String -> (a -> String) ->\n#                        (b -> String) ->\n#                        Int ->\n#                        (a -> b) -> [a] -> String\ndef tabulated(s):\n    '''Heading -> x display function -> fx display function ->\n          number of columns -> f -> value list -> tabular string.'''\n    def go(xShow, fxShow, intCols, f, xs):\n        def mxw(fshow, g):\n            return max(map(compose(len)(fshow), map(g, xs)))\n        w = mxw(xShow, lambda x: x)\n        fw = mxw(fxShow, f)\n        return s + '\\n' + showColumns(intCols)([\n            xShow(x).rjust(w, ' ') + ' -> ' + (\n                fxShow(f(x)).rjust(fw, ' ')\n            )\n            for x in xs\n        ])\n    return lambda xShow: lambda fxShow: lambda nCols: (\n        lambda f: lambda xs: go(\n            xShow, fxShow, nCols, f, xs\n        )\n    )\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\n\n", "perturbed_code": "\nimport collections, sys\n\ndef filecharcount(openfile):\n    return sorted(collections.Counter((c for l in openfile for c in l)).items())\nf = open(sys.argv[1])\n'Character counting as a fold'\nfrom functools import reduce\nfrom itertools import repeat\nfrom os.path import expanduser\n\ndef charCounts(s):\n    'A dictionary of\\n       (character, frequency) mappings\\n    '\n\n    def tally(dct, c):\n        dct[c] = ((dct[c] + 1) if (c in dct) else 1)\n        return dct\n    return reduce(tally, list(s), {})\n\ndef main():\n    'Listing in descending order of frequency.'\n    print(tabulated('Descending order of frequency:\\n')(compose(repr)(fst))(compose(str)(snd))(5)(stet)(sorted(charCounts(readFile('~/Code/charCount/readme.txt')).items(), key=swap, reverse=True)))\n\ndef chunksOf(n):\n    'A series of lists of length n,\\n       subdividing the contents of xs.\\n       Where the length of xs is not evenly divible,\\n       the final list will be shorter than n.'\n    return (lambda xs: (reduce((lambda a, i: (a + [xs[i:(i + n)]])), range(0, len(xs), n), []) if (0 < n) else []))\n\ndef compose(g):\n    'Right to left function composition.'\n    return (lambda f: (lambda x: g(f(x))))\n\ndef fst(tpl):\n    'First member of a pair.'\n    return tpl[0]\n\ndef readFile(fp):\n    'The contents of any file at the path\\n       derived by expanding any ~ in fp.'\n    with open(expanduser(fp), 'r', encoding='utf-8') as f:\n        return f.read()\n\ndef paddedMatrix(v):\n    \"'A list of rows padded to equal length\\n        (where needed) with instances of the value v.\"\n\n    def go(rows):\n        return paddedRows(len(max(rows, key=len)))(v)(rows)\n    return (lambda rows: (go(rows) if rows else []))\n\ndef paddedRows(n):\n    'A list of rows padded (but never truncated)\\n       to length n with copies of value v.'\n\n    def go(v, xs):\n\n        def pad(x):\n            d = (n - len(x))\n            return ((x + list(repeat(v, d))) if (0 < d) else x)\n        return list(map(pad, xs))\n    return (lambda v: (lambda xs: (go(v, xs) if xs else [])))\n\ndef showColumns(n):\n    'A column-wrapped string\\n       derived from a list of rows.'\n\n    def go(xs):\n\n        def fit(col):\n            w = len(max(col, key=len))\n\n            def pad(x):\n                return x.ljust((w + 4), ' ')\n            return ''.join(map(pad, col)).rstrip()\n        (q, r) = divmod(len(xs), n)\n        return '\\n'.join(map(fit, zip(*paddedMatrix('')(chunksOf((int(bool(r)) + q))(xs)))))\n    return (lambda xs: go(xs))\n\ndef snd(tpl):\n    'Second member of a pair.'\n    return tpl[1]\n\ndef stet(x):\n    \"The identity function.\\n       The usual 'id' is reserved in Python.\"\n    return x\n\ndef swap(tpl):\n    'The swapped components of a pair.'\n    return (tpl[1], tpl[0])\n\ndef tabulated(s):\n    'Heading -> x display function -> fx display function ->\\n          number of columns -> f -> value list -> tabular string.'\n\n    def go(xShow, fxShow, intCols, f, xs):\n\n        def mxw(fshow, g):\n            return max(map(compose(len)(fshow), map(g, xs)))\n        w = mxw(xShow, (lambda x: x))\n        fw = mxw(fxShow, f)\n        return (('\\n' + s) + showColumns(intCols)([((' -> ' + xShow(x).rjust(w, ' ')) + fxShow(f(x)).rjust(fw, ' ')) for x in xs]))\n    return (lambda xShow: (lambda fxShow: (lambda nCols: (lambda f: (lambda xs: go(xShow, fxShow, nCols, f, xs))))))\nif (__name__ == '__main__'):\n    main()\nprint(filecharcount(f))\n", "incomplete_perturbed_code": "import collections, sys\n\ndef filecharcount(openfile):\n    pass\nf = open(sys.argv[1])\n'Character counting as a fold'\nfrom functools import reduce\nfrom itertools import repeat\nfrom os.path import expanduser\n\ndef charCounts(s):\n    \"\"\"A dictionary of\n       (character, frequency) mappings\n    \"\"\"\n    pass\n\ndef main():\n    \"\"\"Listing in descending order of frequency.\"\"\"\n    pass\n\ndef chunksOf(n):\n    \"\"\"A series of lists of length n,\n       subdividing the contents of xs.\n       Where the length of xs is not evenly divible,\n       the final list will be shorter than n.\"\"\"\n    pass\n\ndef compose(g):\n    \"\"\"Right to left function composition.\"\"\"\n    pass\n\ndef fst(tpl):\n    \"\"\"First member of a pair.\"\"\"\n    pass\n\ndef readFile(fp):\n    \"\"\"The contents of any file at the path\n       derived by expanding any ~ in fp.\"\"\"\n    pass\n\ndef paddedMatrix(v):\n    \"\"\"'A list of rows padded to equal length\n        (where needed) with instances of the value v.\"\"\"\n    pass\n\ndef paddedRows(n):\n    \"\"\"A list of rows padded (but never truncated)\n       to length n with copies of value v.\"\"\"\n    pass\n\ndef showColumns(n):\n    \"\"\"A column-wrapped string\n       derived from a list of rows.\"\"\"\n    pass\n\ndef snd(tpl):\n    \"\"\"Second member of a pair.\"\"\"\n    pass\n\ndef stet(x):\n    \"\"\"The identity function.\n       The usual 'id' is reserved in Python.\"\"\"\n    pass\n\ndef swap(tpl):\n    \"\"\"The swapped components of a pair.\"\"\"\n    pass\n\ndef tabulated(s):\n    \"\"\"Heading -> x display function -> fx display function ->\n          number of columns -> f -> value list -> tabular string.\"\"\"\n    pass\nif __name__ == '__main__':\n    main()\nprint(filecharcount(f))", "adversarial_score": 3, "original_score": 3, "search_time_seconds": 379.3198161125183, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 97, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 98, "successful_llm_evaluations": 98, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 2, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 97}, "adversarial_completion": "import collections, sys\n\ndef filecharcount(openfile):\n    \"\"\"Counts the frequency of each letter (A to Z) in a file.\"\"\"\n    counts = collections.Counter(c.upper() for c in openfile.read() if 'A' <= c.upper() <= 'Z')\n    return counts\nf = open(sys.argv[1])\n'Character counting as a fold'\nfrom functools import reduce\nfrom itertools import repeat\nfrom os.path import expanduser\n\ndef charCounts(s):\n    \"\"\"A dictionary of\n       (character, frequency) mappings\n    \"\"\"\n    return collections.Counter(c.upper() for c in s if 'A' <= c.upper() <= 'Z')\n\ndef main():\n    \"\"\"Listing in descending order of frequency.\"\"\"\n    counts = charCounts(readFile(sys.argv[1]))\n    sorted_counts = sorted(counts.items(), key=lambda item: item[1], reverse=True)\n    for char, count in sorted_counts:\n        print(f\"{char}: {count}\")\n\ndef chunksOf(n):\n    \"\"\"A series of lists of length n,\n       subdividing the contents of xs.\n       Where the length of xs is not evenly divible,\n       the final list will be shorter than n.\"\"\"\n    it = iter(range(len(xs)))\n    while True:\n        chunk = [xs[i] for i in range(next(it), min(next(it, len(xs)), next(it) + n))]\n        if not chunk:\n            return\n        yield chunk\n\ndef compose(g):\n    \"\"\"Right to left function composition.\"\"\"\n    def composed(f):\n        return lambda x: g(f(x))\n    return composed\n\ndef fst(tpl):\n    \"\"\"First member of a pair.\"\"\"\n    return tpl[0]\n\ndef readFile(fp):\n    \"\"\"The contents of any file at the path\n       derived by expanding any ~ in fp.\"\"\"\n    from os.path import expanduser\n    fp = expanduser(fp)\n    with open(fp, 'r') as f:\n        return f.read()\n\ndef paddedMatrix(v):\n    \"\"\"'A list of rows padded to equal length\n        (where needed) with instances of the value v.\"\"\"\n    max_len = max(len(row) for row in matrix)\n    return [row + [v] * (max_len - len(row)) for row in matrix]\n\ndef paddedRows(n):\n    \"\"\"A list of rows padded (but never truncated)\n       to length n with copies of value v.\"\"\"\n    return [row + [v] * (n - len(row)) for row in rows]\n\ndef showColumns(n):\n    \"\"\"A column-wrapped string\n       derived from a list of rows.\"\"\"\n    return '\\n'.join(''.join(row[i] for row in matrix) for i in range(n))\n\ndef snd(tpl):\n    \"\"\"Second member of a pair.\"\"\"\n    return tpl[1]\n\ndef stet(x):\n    \"\"\"The identity function.\n       The usual 'id' is reserved in Python.\"\"\"\n    return x\n\ndef swap(tpl):\n    \"\"\"The swapped components of a pair.\"\"\"\n    return tpl[1], tpl[0]\n\ndef tabulated(s):\n    \"\"\"Heading -> x display function -> fx display function ->\n          number of columns -> f -> value list -> tabular string.\"\"\"\n    heading = s\n    fx = stet\n    f = stet\n    num_cols = len(values)\n    return heading + '\\n' + showColumns(num_cols)\nif __name__ == '__main__':\n    main()\nprint(filecharcount(f))", "score_distribution_all_attempts": [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]}
{"lang_cluster": "Python", "source_code": "\nFile:Fractal-tree-python.png\nLibrary: pygame\nimport pygame, math\n\npygame.init()\nwindow = pygame.display.set_mode((600, 600))\npygame.display.set_caption(\"Fractal Tree\")\nscreen = pygame.display.get_surface()\n\ndef drawTree(x1, y1, angle, depth):\n    fork_angle = 20\n    base_len = 10.0\n    if depth > 0:\n        x2 = x1 + int(math.cos(math.radians(angle)) * depth * base_len)\n        y2 = y1 + int(math.sin(math.radians(angle)) * depth * base_len)\n        pygame.draw.line(screen, (255,255,255), (x1, y1), (x2, y2), 2)\n        drawTree(x2, y2, angle - fork_angle, depth - 1)\n        drawTree(x2, y2, angle + fork_angle, depth - 1)\n\ndef input(event):\n    if event.type == pygame.QUIT:\n        exit(0)\n\ndrawTree(300, 550, -90, 9)\npygame.display.flip()\nwhile True:\n    input(pygame.event.wait())\n\n", "human_summarization": "generate and draw a fractal tree by first drawing the trunk, then splitting the trunk at the end by a certain angle to form two branches, and repeating this process until a desired level of branching is reached.", "id": "4707", "incomplete_code": "File: Fractal - tree - python.png\nLibrary: pygame\nimport pygame, math\npygame.init()\nwindow = pygame.display.set_mode((600, 600))\npygame.display.set_caption('Fractal Tree')\nscreen = pygame.display.get_surface()\n\ndef drawTree(x1, y1, angle, depth):\n    pass\n\ndef input(event):\n    pass\ndrawTree(300, 550, -90, 9)\npygame.display.flip()\nwhile True:\n    input(pygame.event.wait())", "original_code": "\nFile:Fractal-tree-python.png\nLibrary: pygame\nimport pygame, math\n\npygame.init()\nwindow = pygame.display.set_mode((600, 600))\npygame.display.set_caption(\"Fractal Tree\")\nscreen = pygame.display.get_surface()\n\ndef drawTree(x1, y1, angle, depth):\n    fork_angle = 20\n    base_len = 10.0\n    if depth > 0:\n        x2 = x1 + int(math.cos(math.radians(angle)) * depth * base_len)\n        y2 = y1 + int(math.sin(math.radians(angle)) * depth * base_len)\n        pygame.draw.line(screen, (255,255,255), (x1, y1), (x2, y2), 2)\n        drawTree(x2, y2, angle - fork_angle, depth - 1)\n        drawTree(x2, y2, angle + fork_angle, depth - 1)\n\ndef input(event):\n    if event.type == pygame.QUIT:\n        exit(0)\n\ndrawTree(300, 550, -90, 9)\npygame.display.flip()\nwhile True:\n    input(pygame.event.wait())\n\n", "perturbed_code": "\nFile: ((Fractal - tree) - python.png)\nimport pygame, math\npygame.init()\n\ndef drawTree(x1, y1, angle, depth):\n    base_len = 10.0\n    fork_angle = 20\n    if (depth > 0):\n        x2 = (x1 + int((base_len * (math.cos(math.radians(angle)) * depth))))\n        y2 = (y1 + int((base_len * (depth * math.sin(math.radians(angle))))))\n        pygame.draw.line(screen, (255, 255, 255), (x1, y1), (x2, y2), 2)\n        drawTree(x2, y2, (angle - fork_angle), (depth - 1))\n        drawTree(x2, y2, (angle + fork_angle), (depth - 1))\n\ndef input(event):\n    if (pygame.QUIT == event.type):\n        exit(0)\nLibrary: pygame\nwindow = pygame.display.set_mode((600, 600))\npygame.display.set_caption('Fractal Tree')\nscreen = pygame.display.get_surface()\npygame.display.flip()\nwhile True:\n    input(pygame.event.wait())\ndrawTree(300, 550, (- 90), 9)\n", "incomplete_perturbed_code": "File: Fractal - tree - python.png\nimport pygame, math\npygame.init()\n\ndef drawTree(x1, y1, angle, depth):\n    pass\n\ndef input(event):\n    pass\nLibrary: pygame\nwindow = pygame.display.set_mode((600, 600))\npygame.display.set_caption('Fractal Tree')\nscreen = pygame.display.get_surface()\npygame.display.flip()\nwhile True:\n    input(pygame.event.wait())\ndrawTree(300, 550, -90, 9)", "adversarial_score": 2, "original_score": 3, "search_time_seconds": 263.7749288082123, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 99, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 99, "successful_llm_evaluations": 99, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 1, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 99}, "adversarial_completion": "import pygame, math\npygame.init()\n\ndef drawTree(x1, y1, angle, depth):\n    if depth == 0:\n        return\n    angle_rad = math.radians(angle)\n    x2 = x1 + 20 * math.cos(angle_rad)\n    y2 = y1 - 20 * math.sin(angle_rad)\n    pygame.draw.line(screen, green, (x1, y1), (x2, y2), 2)\n    drawTree(x2, y2, angle - 20, depth - 1)\n    drawTree(x2, y2, angle + 20, depth - 1)\n\ndef input(event):\n    if event.type == pygame.QUIT:\n        pygame.quit()\n        quit()\n\nwindow = pygame.display.set_mode((600, 600))\npygame.display.set_caption('Fractal Tree')\nscreen = pygame.display.get_surface()\npygame.display.flip()\ngreen = (0, 255, 0)\nwhile True:\n    input(pygame.event.wait())\ndrawTree(300, 550, -90, 9)", "score_distribution_all_attempts": [3, 3, 3, 3, 3, 3, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 2, 2, 2, 3, 2, 3, 3, 2, 3, 3, 3, 2, 3, 3, 2, 3, 3, 3, 3, 3, 3, 2, 3, 3, 2, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 2, 3, 3, 3, 3, 2, 3, 3, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]}
{"lang_cluster": "Python", "source_code": "\ndef _pr(t, x, y, z):\n    txt = '\\n'.join(''.join(t[(n,m)] for n in range(3+x+z)).rstrip()\n                    for m in reversed(range(3+y+z)))\n    return txt\n\t\t\ndef cuboid(x,y,z):\n    t = {(n,m):' ' for n in range(3+x+z) for m in range(3+y+z)}\n    xrow = ['+'] + ['%i' % (i % 10) for i in range(x)] + ['+']\n    for i,ch in enumerate(xrow):\n        t[(i,0)] = t[(i,1+y)] = t[(1+z+i,2+y+z)] = ch\n    if _debug: print(_pr(t, x, y, z))\n    ycol = ['+'] + ['%i' % (j % 10) for j in range(y)] + ['+']\n    for j,ch in enumerate(ycol):\n        t[(0,j)] = t[(x+1,j)] = t[(2+x+z,1+z+j)] = ch\n    zdepth = ['+'] + ['%i' % (k % 10) for k in range(z)] + ['+']\n    if _debug: print(_pr(t, x, y, z))\n    for k,ch in enumerate(zdepth):\n        t[(k,1+y+k)] = t[(1+x+k,1+y+k)] = t[(1+x+k,k)] = ch\n\t\n    return _pr(t, x, y, z)\n\n\n_debug = False\nif __name__ == '__main__':\n    for dim in ((2,3,4), (3,4,2), (4,2,3)):\n        print(\"CUBOID%r\" % (dim,), cuboid(*dim), sep='\\n')\n\n\n", "human_summarization": "The following codes output a graphical or ASCII art representation of a cuboid with dimensions 2x3x4. The cuboid has three visible faces and can be displayed either statically or in rotational projection. Additional features include the ability to rotate the cuboid, change its background, color, transparency, and material, display information about the scene and object, and a self-running demo mode.", "id": "4710", "incomplete_code": "def _pr(t, x, y, z):\n    pass\n\ndef cuboid(x, y, z):\n    pass\n_debug = False\nif __name__ == '__main__':\n    for dim in ((2, 3, 4), (3, 4, 2), (4, 2, 3)):\n        print('CUBOID%r' % (dim,), cuboid(*dim), sep='\\n')", "original_code": "\ndef _pr(t, x, y, z):\n    txt = '\\n'.join(''.join(t[(n,m)] for n in range(3+x+z)).rstrip()\n                    for m in reversed(range(3+y+z)))\n    return txt\n\t\t\ndef cuboid(x,y,z):\n    t = {(n,m):' ' for n in range(3+x+z) for m in range(3+y+z)}\n    xrow = ['+'] + ['%i' % (i % 10) for i in range(x)] + ['+']\n    for i,ch in enumerate(xrow):\n        t[(i,0)] = t[(i,1+y)] = t[(1+z+i,2+y+z)] = ch\n    if _debug: print(_pr(t, x, y, z))\n    ycol = ['+'] + ['%i' % (j % 10) for j in range(y)] + ['+']\n    for j,ch in enumerate(ycol):\n        t[(0,j)] = t[(x+1,j)] = t[(2+x+z,1+z+j)] = ch\n    zdepth = ['+'] + ['%i' % (k % 10) for k in range(z)] + ['+']\n    if _debug: print(_pr(t, x, y, z))\n    for k,ch in enumerate(zdepth):\n        t[(k,1+y+k)] = t[(1+x+k,1+y+k)] = t[(1+x+k,k)] = ch\n\t\n    return _pr(t, x, y, z)\n\n\n_debug = False\nif __name__ == '__main__':\n    for dim in ((2,3,4), (3,4,2), (4,2,3)):\n        print(\"CUBOID%r\" % (dim,), cuboid(*dim), sep='\\n')\n\n\n", "perturbed_code": "\n\ndef _pr(t, x, y, z):\n    txt = '\\n'.join((''.join((t[(n, m)] for n in range(((x + 3) + z)))).rstrip() for m in reversed(range((z + (y + 3))))))\n    return txt\n\ndef cuboid(x, y, z):\n    for (k, ch) in enumerate(zdepth):\n        t[(k, (k + (y + 1)))] = t[(((x + 1) + k), (k + (1 + y)))] = t[(((x + 1) + k), k)] = ch\n    if _debug:\n        print(_pr(t, x, y, z))\n    for (j, ch) in enumerate(ycol):\n        t[(0, j)] = t[((x + 1), j)] = t[((z + (2 + x)), ((z + 1) + j))] = ch\n    if _debug:\n        print(_pr(t, x, y, z))\n    for (i, ch) in enumerate(xrow):\n        t[(i, 0)] = t[(i, (1 + y))] = t[(((1 + z) + i), (z + (y + 2)))] = ch\n    t = {(n, m): ' ' for n in range(((3 + x) + z)) for m in range((z + (3 + y)))}\n    xrow = (['+'] + ([('%i' % (i % 10)) for i in range(x)] + ['+']))\n    ycol = (['+'] + ([('%i' % (j % 10)) for j in range(y)] + ['+']))\n    zdepth = ((['+'] + [('%i' % (k % 10)) for k in range(z)]) + ['+'])\n    return _pr(t, x, y, z)\n_debug = False\nif (__name__ == '__main__'):\n    for dim in ((2, 3, 4), (3, 4, 2), (4, 2, 3)):\n        print(('CUBOID%r' % (dim,)), cuboid(*dim), sep='\\n')\n", "incomplete_perturbed_code": "def _pr(t, x, y, z):\n    pass\n\ndef cuboid(x, y, z):\n    pass\n_debug = False\nif __name__ == '__main__':\n    for dim in ((2, 3, 4), (3, 4, 2), (4, 2, 3)):\n        print('CUBOID%r' % (dim,), cuboid(*dim), sep='\\n')", "adversarial_score": 2, "original_score": 2, "search_time_seconds": 289.25174856185913, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 100, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 100, "successful_llm_evaluations": 100, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 0, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 100}, "adversarial_completion": "def _pr(t, x, y, z):\n    return t * x * y * z\n\ndef cuboid(x, y, z):\n    global _debug\n    if _debug:\n        print(\"cuboid called with x={}, y={}, z={}\".format(x, y, z))\n    s = \"\"\n    s += \" \" * (z - 1) + \"#####\\n\"\n    s += \" \" * (z - 1) + \"#   #\\n\"\n    s += \" \" * (z - 1) + \"#   #\\n\"\n    s += \" \" * (z - 1) + \"#####\\n\"\n    s += \"#   #\\n\"\n    s += \"#   #\\n\"\n    s += \"#####\\n\"\n    s += \"#   #\\n\"\n    s += \"#   #\\n\"\n    s += \"#####\\n\"\n    s += \" \" * (y - 1) + \"#####\\n\"\n    s += \" \" * (y - 1) + \"#   #\\n\"\n    s += \" \" * (y - 1) + \"#   #\\n\"\n    s += \" \" * (y - 1) + \"#####\\n\"\n    return s\n\n_debug = False\nif __name__ == '__main__':\n    for dim in ((2, 3, 4), (3, 4, 2), (4, 2, 3)):\n        print('CUBOID%r' % (dim,), cuboid(*dim), sep='\\n')", "score_distribution_all_attempts": [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]}
{"lang_cluster": "Python", "source_code": "\ndef bsd_rand(seed):\n   def rand():\n      rand.seed = (1103515245*rand.seed + 12345) & 0x7fffffff\n      return rand.seed\n   rand.seed = seed\n   return rand\n\ndef msvcrt_rand(seed):\n   def rand():\n      rand.seed = (214013*rand.seed + 2531011) & 0x7fffffff\n      return rand.seed >> 16\n   rand.seed = seed\n   return rand\n\n# Works with: Python version 3.x\ndef bsd_rand(seed):\n   def rand():\n      nonlocal seed\n      seed = (1103515245*seed + 12345) & 0x7fffffff\n      return seed\n   return rand\n\ndef msvcrt_rand(seed):\n   def rand():\n      nonlocal seed\n      seed = (214013*seed + 2531011) & 0x7fffffff\n      return seed >> 16\n   return rand\n\n", "human_summarization": "The code implements two historic random number generators: the rand() function from BSD libc and the rand() function from the Microsoft C Runtime (MSCVRT.DLL). These generators use the linear congruential generator formula with specific constants. The generators produce a sequence of integers, starting from a seed value, that is not cryptographically secure but can be used for simple tasks. The BSD generator outputs numbers in the range 0 to 2147483647, while the Microsoft generator outputs numbers in the range 0 to 32767.", "id": "4716", "incomplete_code": "def bsd_rand(seed):\n    pass\n\ndef msvcrt_rand(seed):\n    pass\n\ndef bsd_rand(seed):\n    pass\n\ndef msvcrt_rand(seed):\n    pass", "original_code": "\ndef bsd_rand(seed):\n   def rand():\n      rand.seed = (1103515245*rand.seed + 12345) & 0x7fffffff\n      return rand.seed\n   rand.seed = seed\n   return rand\n\ndef msvcrt_rand(seed):\n   def rand():\n      rand.seed = (214013*rand.seed + 2531011) & 0x7fffffff\n      return rand.seed >> 16\n   rand.seed = seed\n   return rand\n\n# Works with: Python version 3.x\ndef bsd_rand(seed):\n   def rand():\n      nonlocal seed\n      seed = (1103515245*seed + 12345) & 0x7fffffff\n      return seed\n   return rand\n\ndef msvcrt_rand(seed):\n   def rand():\n      nonlocal seed\n      seed = (214013*seed + 2531011) & 0x7fffffff\n      return seed >> 16\n   return rand\n\n", "perturbed_code": "\n\ndef msvcrt_rand(seed):\n\n    def rand():\n        rand.seed = (2147483647 & (2531011 + (rand.seed * 214013)))\n        return (rand.seed >> 16)\n    rand.seed = seed\n    return rand\n\ndef msvcrt_rand(seed):\n\n    def rand():\n        nonlocal seed\n        seed = (2147483647 & (2531011 + (214013 * seed)))\n        return (seed >> 16)\n    return rand\n\ndef bsd_rand(seed):\n\n    def rand():\n        rand.seed = (2147483647 & ((rand.seed * 1103515245) + 12345))\n        return rand.seed\n    rand.seed = seed\n    return rand\n\ndef bsd_rand(seed):\n\n    def rand():\n        seed = (2147483647 & (12345 + (seed * 1103515245)))\n        nonlocal seed\n        return seed\n    return rand\n", "incomplete_perturbed_code": "def msvcrt_rand(seed):\n    pass\n\ndef msvcrt_rand(seed):\n    pass\n\ndef bsd_rand(seed):\n    pass\n\ndef bsd_rand(seed):\n    pass", "adversarial_score": 2, "original_score": 2, "search_time_seconds": 90.08665871620178, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 100, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 100, "successful_llm_evaluations": 100, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 0, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 100}, "adversarial_completion": "def msvcrt_rand(seed):\n    seed = (seed * 0x27D44785 + 0x4E20719D) & 0xFFFF\n    return seed % 65536\n\ndef bsd_rand(seed):\n    seed = (seed * 1103515245 + 12345) & 0x7FFFFFFF\n    return seed", "score_distribution_all_attempts": [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]}
{"lang_cluster": "Python", "source_code": "\n\n'''\n The 24 Game Player\n \n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and / operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n \n An answer of \"q\"  will quit the game.\n An answer of \"!\"  will generate a new set of four digits.\n An answer of \"!!\" will ask you for a new set of four digits.\n An answer of \"?\"  will compute an expression for the current digits.\n \n Otherwise you are repeatedly asked for an expression until it evaluates to 24\n \n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n \n'''\n \nfrom   __future__ import division, print_function\nfrom   itertools  import permutations, combinations, product, \\\n                         chain\nfrom   pprint     import pprint as pp\nfrom   fractions  import Fraction as F\nimport random, ast, re\nimport sys\n \nif sys.version_info[0] < 3:\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n \n \ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n \ndef ask4():\n    'get four random digits >0 from the player'\n    digits = ''\n    while len(digits) != 4 or not all(d in '123456789' for d in digits):\n        digits = input('Enter the digits to solve for: ')\n        digits = ''.join(digits.strip().split())\n    return list(digits)\n \ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n \ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n \ndef solve(digits):\n    \"\"\"\\\n    >>> for digits in '3246 4788 1111 123456 1127 3838'.split():\n            solve(list(digits))\n \n \n    Solution found: 2 + 3 * 6 + 4\n    '2 + 3 * 6 + 4'\n    Solution found: ( 4 + 7 - 8 ) * 8\n    '( 4 + 7 - 8 ) * 8'\n    No solution found for: 1 1 1 1\n    '!'\n    Solution found: 1 + 2 + 3 * ( 4 + 5 ) - 6\n    '1 + 2 + 3 * ( 4 + 5 ) - 6'\n    Solution found: ( 1 + 2 ) * ( 1 + 7 )\n    '( 1 + 2 ) * ( 1 + 7 )'\n    Solution found: 8 / ( 3 - 8 / 3 )\n    '8 / ( 3 - 8 / 3 )'\n    >>> \"\"\"\n    digilen = len(digits)\n    # length of an exp without brackets \n    exprlen = 2 * digilen - 1\n    # permute all the digits\n    digiperm = sorted(set(permutations(digits)))\n    # All the possible operator combinations\n    opcomb   = list(product('+-*/', repeat=digilen-1))\n    # All the bracket insertion points:\n    brackets = ( [()] + [(x,y)\n                         for x in range(0, exprlen, 2)\n                         for y in range(x+4, exprlen+2, 2)\n                         if (x,y) != (0,exprlen+1)]\n                 + [(0, 3+1, 4+2, 7+3)] ) # double brackets case\n    for d in digiperm:\n        for ops in opcomb:\n            if '/' in ops:\n                d2 = [('F(%s)' % i) for i in d] # Use Fractions for accuracy\n            else:\n                d2 = d\n            ex = list(chain.from_iterable(zip_longest(d2, ops, fillvalue='')))\n            for b in brackets:\n                exp = ex[::]\n                for insertpoint, bracket in zip(b, '()'*(len(b)//2)):\n                    exp.insert(insertpoint, bracket)\n                txt = ''.join(exp)\n                try:\n                    num = eval(txt)\n                except ZeroDivisionError:\n                    continue\n                if num == 24:\n                    if '/' in ops:\n                        exp = [ (term if not term.startswith('F(') else term[2])\n                               for term in exp ]\n                    ans = ' '.join(exp).rstrip()\n                    print (\"Solution found:\",ans)\n                    return ans\n    print (\"No solution found for:\", ' '.join(digits))            \n    return '!'\n \ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer == '?':\n            solve(digits)\n            answer = '!'\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if answer == '!!':\n            digits = ask4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            if '/' in answer:\n                # Use Fractions for accuracy in divisions\n                answer = ''.join( (('F(%s)' % char) if char in '123456789' else char)\n                                  for char in answer )\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n \nmain()\n\n\n", "human_summarization": "The code takes four digits as input, either from the user or randomly generated, and calculates arithmetic expressions according to the rules of the 24 game. It includes a function called 'solve' that is integrated into the game player. The function switches to precise fractional arithmetic during division to accurately solve and recognize cases that do not equal 24 due to Python's double-precision floating point. The code can handle any number of digits by recursively merging two numbers using all available operands until only one value remains.", "id": "4719", "incomplete_code": "\"\"\"\n The 24 Game Player\n \n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and / operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n \n An answer of \"q\"  will quit the game.\n An answer of \"!\"  will generate a new set of four digits.\n An answer of \"!!\" will ask you for a new set of four digits.\n An answer of \"?\"  will compute an expression for the current digits.\n \n Otherwise you are repeatedly asked for an expression until it evaluates to 24\n \n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n \n\"\"\"\nfrom __future__ import division, print_function\nfrom itertools import permutations, combinations, product, chain\nfrom pprint import pprint as pp\nfrom fractions import Fraction as F\nimport random, ast, re\nimport sys\nif sys.version_info[0] < 3:\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n\ndef choose4():\n    \"\"\"four random digits >0 as characters\"\"\"\n    pass\n\ndef ask4():\n    \"\"\"get four random digits >0 from the player\"\"\"\n    pass\n\ndef welcome(digits):\n    pass\n\ndef check(answer, digits):\n    pass\n\ndef solve(digits):\n    \"\"\"    >>> for digits in '3246 4788 1111 123456 1127 3838'.split():\n            solve(list(digits))\n \n \n    Solution found: 2 + 3 * 6 + 4\n    '2 + 3 * 6 + 4'\n    Solution found: ( 4 + 7 - 8 ) * 8\n    '( 4 + 7 - 8 ) * 8'\n    No solution found for: 1 1 1 1\n    '!'\n    Solution found: 1 + 2 + 3 * ( 4 + 5 ) - 6\n    '1 + 2 + 3 * ( 4 + 5 ) - 6'\n    Solution found: ( 1 + 2 ) * ( 1 + 7 )\n    '( 1 + 2 ) * ( 1 + 7 )'\n    Solution found: 8 / ( 3 - 8 / 3 )\n    '8 / ( 3 - 8 / 3 )'\n    >>> \"\"\"\n    pass\n\ndef main():\n    pass\nmain()", "original_code": "\n\n'''\n The 24 Game Player\n \n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and / operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n \n An answer of \"q\"  will quit the game.\n An answer of \"!\"  will generate a new set of four digits.\n An answer of \"!!\" will ask you for a new set of four digits.\n An answer of \"?\"  will compute an expression for the current digits.\n \n Otherwise you are repeatedly asked for an expression until it evaluates to 24\n \n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n \n'''\n \nfrom   __future__ import division, print_function\nfrom   itertools  import permutations, combinations, product, \\\n                         chain\nfrom   pprint     import pprint as pp\nfrom   fractions  import Fraction as F\nimport random, ast, re\nimport sys\n \nif sys.version_info[0] < 3:\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n \n \ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n \ndef ask4():\n    'get four random digits >0 from the player'\n    digits = ''\n    while len(digits) != 4 or not all(d in '123456789' for d in digits):\n        digits = input('Enter the digits to solve for: ')\n        digits = ''.join(digits.strip().split())\n    return list(digits)\n \ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n \ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n \ndef solve(digits):\n    \"\"\"\\\n    >>> for digits in '3246 4788 1111 123456 1127 3838'.split():\n            solve(list(digits))\n \n \n    Solution found: 2 + 3 * 6 + 4\n    '2 + 3 * 6 + 4'\n    Solution found: ( 4 + 7 - 8 ) * 8\n    '( 4 + 7 - 8 ) * 8'\n    No solution found for: 1 1 1 1\n    '!'\n    Solution found: 1 + 2 + 3 * ( 4 + 5 ) - 6\n    '1 + 2 + 3 * ( 4 + 5 ) - 6'\n    Solution found: ( 1 + 2 ) * ( 1 + 7 )\n    '( 1 + 2 ) * ( 1 + 7 )'\n    Solution found: 8 / ( 3 - 8 / 3 )\n    '8 / ( 3 - 8 / 3 )'\n    >>> \"\"\"\n    digilen = len(digits)\n    # length of an exp without brackets \n    exprlen = 2 * digilen - 1\n    # permute all the digits\n    digiperm = sorted(set(permutations(digits)))\n    # All the possible operator combinations\n    opcomb   = list(product('+-*/', repeat=digilen-1))\n    # All the bracket insertion points:\n    brackets = ( [()] + [(x,y)\n                         for x in range(0, exprlen, 2)\n                         for y in range(x+4, exprlen+2, 2)\n                         if (x,y) != (0,exprlen+1)]\n                 + [(0, 3+1, 4+2, 7+3)] ) # double brackets case\n    for d in digiperm:\n        for ops in opcomb:\n            if '/' in ops:\n                d2 = [('F(%s)' % i) for i in d] # Use Fractions for accuracy\n            else:\n                d2 = d\n            ex = list(chain.from_iterable(zip_longest(d2, ops, fillvalue='')))\n            for b in brackets:\n                exp = ex[::]\n                for insertpoint, bracket in zip(b, '()'*(len(b)//2)):\n                    exp.insert(insertpoint, bracket)\n                txt = ''.join(exp)\n                try:\n                    num = eval(txt)\n                except ZeroDivisionError:\n                    continue\n                if num == 24:\n                    if '/' in ops:\n                        exp = [ (term if not term.startswith('F(') else term[2])\n                               for term in exp ]\n                    ans = ' '.join(exp).rstrip()\n                    print (\"Solution found:\",ans)\n                    return ans\n    print (\"No solution found for:\", ' '.join(digits))            \n    return '!'\n \ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer == '?':\n            solve(digits)\n            answer = '!'\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if answer == '!!':\n            digits = ask4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            if '/' in answer:\n                # Use Fractions for accuracy in divisions\n                answer = ''.join( (('F(%s)' % char) if char in '123456789' else char)\n                                  for char in answer )\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n \nmain()\n\n\n", "perturbed_code": "\n'\\n The 24 Game Player\\n \\n Given any four digits in the range 1 to 9, which may have repetitions,\\n Using just the +, -, *, and / operators; and the possible use of\\n brackets, (), show how to make an answer of 24.\\n \\n An answer of \"q\"  will quit the game.\\n An answer of \"!\"  will generate a new set of four digits.\\n An answer of \"!!\" will ask you for a new set of four digits.\\n An answer of \"?\"  will compute an expression for the current digits.\\n \\n Otherwise you are repeatedly asked for an expression until it evaluates to 24\\n \\n Note: you cannot form multiple digit numbers from the supplied digits,\\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\\n \\n'\nfrom fractions import Fraction as F\n\ndef ask4():\n    'get four random digits >0 from the player'\n    digits = ''\n    while ((4 != len(digits)) or (not all(((d in '123456789') for d in digits)))):\n        digits = input('Enter the digits to solve for: ')\n        digits = ''.join(digits.strip().split())\n    return list(digits)\nfrom itertools import permutations, combinations, product, chain\n\ndef welcome(digits):\n    print(__doc__)\n    print((' '.join(digits) + 'Your four digits: '))\nfrom pprint import pprint as pp\nimport random, ast, re\n\ndef check(answer, digits):\n    allowed = set(('() +-*/\\t' + ''.join(digits)))\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    ok = (all(((ch in allowed) for ch in answer)) and all(((digits.count(dig) == answer.count(dig)) for dig in set(digits))) and (not re.search('\\\\d\\\\d', answer)))\n    return ok\n\ndef main():\n    trial = 0\n    while (not (chk and (ans == 24))):\n        if (not chk):\n            print((\"The input '%s' was wonky!\" % answer))\n        else:\n            if (24 == ans):\n                print('Thats right!')\n            if ('/' in answer):\n                answer = ''.join(((('F(%s)' % char) if (char in '123456789') else char) for char in answer))\n            ans = eval(answer)\n            print(' = ', ans)\n        if (answer == '!!'):\n            continue\n            trial = 0\n            digits = ask4()\n            print('\\nNew digits:', ' '.join(digits))\n        if (answer == '!'):\n            continue\n            trial = 0\n            digits = choose4()\n            print('\\nNew digits:', ' '.join(digits))\n        if (answer.lower() == 'q'):\n            break\n        if (answer == '?'):\n            solve(digits)\n            answer = '!'\n        trial += 1\n        answer = input(('Expression %i: ' % trial))\n        chk = check(answer, digits)\n    chk = ans = False\n    digits = choose4()\n    welcome(digits)\n    answer = ''\n    print('Thank you and goodbye')\nfrom __future__ import division, print_function\nimport sys\nif (sys.version_info[0] < 3):\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n\ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1, 9)) for i in range(4)]\n\ndef solve(digits):\n    \"    >>> for digits in '3246 4788 1111 123456 1127 3838'.split():\\n            solve(list(digits))\\n \\n \\n    Solution found: 2 + 3 * 6 + 4\\n    '2 + 3 * 6 + 4'\\n    Solution found: ( 4 + 7 - 8 ) * 8\\n    '( 4 + 7 - 8 ) * 8'\\n    No solution found for: 1 1 1 1\\n    '!'\\n    Solution found: 1 + 2 + 3 * ( 4 + 5 ) - 6\\n    '1 + 2 + 3 * ( 4 + 5 ) - 6'\\n    Solution found: ( 1 + 2 ) * ( 1 + 7 )\\n    '( 1 + 2 ) * ( 1 + 7 )'\\n    Solution found: 8 / ( 3 - 8 / 3 )\\n    '8 / ( 3 - 8 / 3 )'\\n    >>> \"\n    for d in digiperm:\n        for ops in opcomb:\n            for b in brackets:\n                if (24 == num):\n                    if ('/' in ops):\n                        exp = [(term if (not term.startswith('F(')) else term[2]) for term in exp]\n                    ans = ' '.join(exp).rstrip()\n                    print('Solution found:', ans)\n                    return ans\n                try:\n                    num = eval(txt)\n                except ZeroDivisionError:\n                    continue\n                for (insertpoint, bracket) in zip(b, ('()' * (len(b) // 2))):\n                    exp.insert(insertpoint, bracket)\n                exp = ex[:]\n                txt = ''.join(exp)\n            if ('/' in ops):\n                d2 = [('F(%s)' % i) for i in d]\n            else:\n                d2 = d\n            ex = list(chain.from_iterable(zip_longest(d2, ops, fillvalue='')))\n    print('No solution found for:', ' '.join(digits))\n    return '!'\n    digilen = len(digits)\n    exprlen = ((2 * digilen) - 1)\n    brackets = (([()] + [(x, y) for x in range(0, exprlen, 2) for y in range((x + 4), (2 + exprlen), 2) if ((x, y) != (0, (exprlen + 1)))]) + [(0, (3 + 1), (4 + 2), (7 + 3))])\n    opcomb = list(product('+-*/', repeat=(digilen - 1)))\n    digiperm = sorted(set(permutations(digits)))\nmain()\n", "incomplete_perturbed_code": "\"\"\"\n The 24 Game Player\n \n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and / operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n \n An answer of \"q\"  will quit the game.\n An answer of \"!\"  will generate a new set of four digits.\n An answer of \"!!\" will ask you for a new set of four digits.\n An answer of \"?\"  will compute an expression for the current digits.\n \n Otherwise you are repeatedly asked for an expression until it evaluates to 24\n \n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n \n\"\"\"\nfrom fractions import Fraction as F\n\ndef ask4():\n    \"\"\"get four random digits >0 from the player\"\"\"\n    pass\nfrom itertools import permutations, combinations, product, chain\n\ndef welcome(digits):\n    pass\nfrom pprint import pprint as pp\nimport random, ast, re\n\ndef check(answer, digits):\n    pass\n\ndef main():\n    pass\nfrom __future__ import division, print_function\nimport sys\nif sys.version_info[0] < 3:\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n\ndef choose4():\n    \"\"\"four random digits >0 as characters\"\"\"\n    pass\n\ndef solve(digits):\n    \"\"\"    >>> for digits in '3246 4788 1111 123456 1127 3838'.split():\n            solve(list(digits))\n \n \n    Solution found: 2 + 3 * 6 + 4\n    '2 + 3 * 6 + 4'\n    Solution found: ( 4 + 7 - 8 ) * 8\n    '( 4 + 7 - 8 ) * 8'\n    No solution found for: 1 1 1 1\n    '!'\n    Solution found: 1 + 2 + 3 * ( 4 + 5 ) - 6\n    '1 + 2 + 3 * ( 4 + 5 ) - 6'\n    Solution found: ( 1 + 2 ) * ( 1 + 7 )\n    '( 1 + 2 ) * ( 1 + 7 )'\n    Solution found: 8 / ( 3 - 8 / 3 )\n    '8 / ( 3 - 8 / 3 )'\n    >>> \"\"\"\n    pass\nmain()", "adversarial_score": 3, "original_score": 3, "search_time_seconds": 4500.755784273148, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 100, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 100, "successful_llm_evaluations": 16, "failed_llm_evaluations": 84, "cache_hits_reordering_score": 0, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 100}, "adversarial_completion": "\"\"\"\n The 24 Game Player\n \n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and / operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n \n An answer of \"q\"  will quit the game.\n An answer of \"!\"  will generate a new set of four digits.\n An answer of \"!!\" will ask you for a new set of four digits.\n An answer of \"?\"  will compute an expression for the current digits.\n \n Otherwise you are repeatedly asked for an expression until it evaluates to 24\n \n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n \n\"\"\"\nfrom fractions import Fraction as F\n\ndef ask4():\n    \"\"\"get four random digits >0 from the player\"\"\"\n    return [str(random.randint(1, 9)) for _ in range(4)]\nfrom itertools import permutations, combinations, product, chain\n\ndef welcome(digits):\n    \"\"\"display the digits and ask for an expression\"\"\"\n    print(\"The digits are:\", digits)\n    print(\"Enter an expression, or 'q' to quit, '!' for new digits, '!!' for new digits from you, or '?' to compute an expression.\")\n\nfrom pprint import pprint as pp\nimport random, ast, re\n\ndef check(answer, digits):\n    \"\"\"check if the answer is 24\"\"\"\n    try:\n        if answer == 'q':\n            return False\n        if answer == '!':\n            return '!'\n        if answer == '!!':\n            return '!!'\n        if answer == '?':\n            return '?'\n        \n        expression = answer\n        \n        # Replace digits with their string representation\n        for i, digit in enumerate(digits):\n            expression = expression.replace(digit, f\"digits[{i}]\")\n        \n        # Evaluate the expression using fractions for accurate division\n        result = eval(expression)\n        \n        if isinstance(result, F):\n            return result == F(24)\n        else:\n            return result == 24\n    except (SyntaxError, NameError, TypeError, ZeroDivisionError):\n        print(\"Invalid expression.\")\n        return False\n\ndef main():\n    \"\"\"main game loop\"\"\"\n    digits = ask4()\n    welcome(digits)\n    while True:\n        answer = input(\"Enter your expression: \")\n        result = check(answer, digits)\n        if result == False:\n            continue\n        elif result == '!':\n            digits = ask4()\n            welcome(digits)\n        elif result == '!!':\n            try:\n                digits = [input(\"Enter digit 1: \"), input(\"Enter digit 2: \"), input(\"Enter digit 3: \"), input(\"Enter digit 4: \")]\n            except:\n                print(\"Invalid input. Generating new digits.\")\n                digits = ask4()\n                welcome(digits)\n            \n        elif result == '?':\n            solution = solve(digits)\n            if solution:\n                print(\"Solution found:\", solution)\n            else:\n                print(\"No solution found.\")\n        else:\n            print(\"Correct!\")\n            break\n\nfrom __future__ import division, print_function\nimport sys\nif sys.version_info[0] < 3:\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n\ndef choose4():\n    \"\"\"four random digits >0 as characters\"\"\"\n    return [str(random.randint(1, 9)) for _ in range(4)]\n\ndef solve(digits):\n    \"\"\"    >>> for digits in '3246 4788 1111 123456 1127 3838'.split():\n            solve(digits)\n \n \n    Solution found: 2 + 3 * 6 + 4\n    '2 + 3 * 6 + 4'\n    Solution found: ( 4 + 7 - 8 ) * 8\n    '( 4 + 7 - 8 ) * 8'\n    No solution found for: 1 1 1 1\n    '!'\n    Solution found: 1 + 2 + 3 * ( 4 + 5 ) - 6\n    '1 + 2 + 3 * ( 4 + 5 ) - 6'\n    Solution found: ( 1 + 2 ) * ( 1 + 7 )\n    '( 1 + 2 ) * ( 1 + 7 )'\n    Solution found: 8 / ( 3 - 8 / 3 )\n    '8 / ( 3 - 8 / 3 )'\n    >>> \"\"\"\n    ops = ['+', '-', '*', '/']\n    \n    def calculate(expr):\n        try:\n            return eval(expr)\n        except (ZeroDivisionError, TypeError):\n            return None\n    \n    for perm in permutations(digits):\n        for op1 in ops:\n            for op2 in ops:\n                # (a op1 b) op2 c\n                expr1 = f\"({perm[0]} {op1} {perm[1]}) {op2} {perm[2]}\"\n                result1 = calculate(expr1)\n                if isinstance(result1, float) and abs(result1 - 24) < 1e-6:\n                    return expr1\n                \n                # a op1 (b op2 c)\n                expr2 = f\"{perm[0]} {op1} ({perm[1]} {op2} {perm[2]})\"\n                result2 = calculate(expr2)\n                if isinstance(result2, float) and abs(result2 - 24) < 1e-6:\n                    return expr2\n                \n                # a op1 b op2 c\n                expr3 = f\"{perm[0]} {op1} {perm[1]} {op2} {perm[2]}\"\n                result3 = calculate(expr3)\n                if isinstance(result3, float) and abs(result3 - 24) < 1e-6:\n                    return expr3\n                \n                # a op1 b op2 c op3 d\n                if len(digits) == 4:\n                    expr4 = f\"{perm[0]} {op1} {perm[1]} {op2} {perm[2]} {op3} {perm[3]}\"\n                    result4 = calculate(expr4)\n                    if isinstance(result4, float) and abs(result4 - 24) < 1e-6:\n                        return expr4\n    \n    return None\n\nmain()", "score_distribution_all_attempts": [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]}
{"lang_cluster": "Python", "source_code": "\n# Works with: Python version 2.6+, 3.x\nimport math\nmath.factorial(n)\ndef factorial(n):\n    result = 1\n    for i in range(1, n+1):\n        result *= i\n    return result\nfrom operator import mul\nfrom functools import reduce\n\ndef factorial(n):\n    return reduce(mul, range(1,n+1), 1)\n\nfrom itertools import (accumulate, chain)\nfrom operator import mul\n\n# factorial\u00a0:: Integer\ndef factorial(n):\n    return list(\n        accumulate(chain([1], range(1, 1 + n)), mul)\n    )[-1]\n\nfrom itertools import (accumulate, chain)\nfrom operator import mul\n\n\n# factorials\u00a0:: [Integer]\ndef factorials(n):\n    return list(\n        accumulate(chain([1], range(1, 1 + n)), mul)\n    )\n\nprint(factorials(5))\n\n# -> [1, 1, 2, 6, 24, 120]\n\nfrom numpy import prod\n\ndef factorial(n):\n    return prod(range(1, n + 1), dtype=int)\ndef factorial(n):\n    z=1\n    if n>1:\n        z=n*factorial(n-1)\n    return z\n\n", "human_summarization": "implement a function that calculates the factorial of a given number. The function can be either iterative or recursive. It optionally includes error handling for negative input values. The factorial function is defined as the product of a sequence from the given positive integer down to 1. The code may also include a Lanczos approximation to approximate the gamma function, which extends the domain of the factorial function.", "id": "4720", "incomplete_code": "import math\nmath.factorial(n)\n\ndef factorial(n):\n    pass\nfrom operator import mul\nfrom functools import reduce\n\ndef factorial(n):\n    pass\nfrom itertools import accumulate, chain\nfrom operator import mul\n\ndef factorial(n):\n    pass\nfrom itertools import accumulate, chain\nfrom operator import mul\n\ndef factorials(n):\n    pass\nprint(factorials(5))\nfrom numpy import prod\n\ndef factorial(n):\n    pass\n\ndef factorial(n):\n    pass", "original_code": "\n# Works with: Python version 2.6+, 3.x\nimport math\nmath.factorial(n)\ndef factorial(n):\n    result = 1\n    for i in range(1, n+1):\n        result *= i\n    return result\nfrom operator import mul\nfrom functools import reduce\n\ndef factorial(n):\n    return reduce(mul, range(1,n+1), 1)\n\nfrom itertools import (accumulate, chain)\nfrom operator import mul\n\n# factorial\u00a0:: Integer\ndef factorial(n):\n    return list(\n        accumulate(chain([1], range(1, 1 + n)), mul)\n    )[-1]\n\nfrom itertools import (accumulate, chain)\nfrom operator import mul\n\n\n# factorials\u00a0:: [Integer]\ndef factorials(n):\n    return list(\n        accumulate(chain([1], range(1, 1 + n)), mul)\n    )\n\nprint(factorials(5))\n\n# -> [1, 1, 2, 6, 24, 120]\n\nfrom numpy import prod\n\ndef factorial(n):\n    return prod(range(1, n + 1), dtype=int)\ndef factorial(n):\n    z=1\n    if n>1:\n        z=n*factorial(n-1)\n    return z\n\n", "perturbed_code": "\nimport math\nmath.factorial(n)\n\ndef factorial(n):\n    for i in range(1, (1 + n)):\n        result *= i\n    result = 1\n    return result\nfrom functools import reduce\nfrom operator import mul\n\ndef factorial(n):\n    return reduce(mul, range(1, (n + 1)), 1)\nfrom itertools import accumulate, chain\nfrom operator import mul\n\ndef factorial(n):\n    return list(accumulate(chain([1], range(1, (n + 1))), mul))[(- 1)]\nfrom itertools import accumulate, chain\nfrom operator import mul\n\ndef factorials(n):\n    return list(accumulate(chain([1], range(1, (1 + n))), mul))\nprint(factorials(5))\nfrom numpy import prod\n\ndef factorial(n):\n    return prod(range(1, (n + 1)), dtype=int)\n\ndef factorial(n):\n    z = 1\n    if (n > 1):\n        z = (n * factorial((n - 1)))\n    return z\n", "incomplete_perturbed_code": "import math\nmath.factorial(n)\n\ndef factorial(n):\n    pass\nfrom functools import reduce\nfrom operator import mul\n\ndef factorial(n):\n    pass\nfrom itertools import accumulate, chain\nfrom operator import mul\n\ndef factorial(n):\n    pass\nfrom itertools import accumulate, chain\nfrom operator import mul\n\ndef factorials(n):\n    pass\nprint(factorials(5))\nfrom numpy import prod\n\ndef factorial(n):\n    pass\n\ndef factorial(n):\n    pass", "adversarial_score": 4, "original_score": 4, "search_time_seconds": 184.19611811637878, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 88, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 92, "successful_llm_evaluations": 92, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 8, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 88}, "adversarial_completion": "import math\nmath.factorial(n)\n\ndef factorial(n):\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    elif n == 0:\n        return 1\n    else:\n        result = 1\n        for i in range(1, n + 1):\n            result *= i\n        return result\nfrom functools import reduce\nfrom operator import mul\n\ndef factorial(n):\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    else:\n        return reduce(mul, range(1, n + 1), 1)\nfrom itertools import accumulate, chain\nfrom operator import mul\n\ndef factorial(n):\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    else:\n        return reduce(mul, range(1, n + 1), 1)\nfrom itertools import accumulate, chain\nfrom operator import mul\n\ndef factorials(n):\n    return list(accumulate(range(1, n + 1), lambda x, y: x * y))\nprint(factorials(5))\nfrom numpy import prod\n\ndef factorial(n):\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    else:\n        return int(prod(range(1, n + 1)))\n\ndef factorial(n):\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    else:\n        return math.factorial(n)", "score_distribution_all_attempts": [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]}
{"lang_cluster": "Python", "source_code": "\ndef dotp(a,b):\n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n\nif __name__ == '__main__':\n    a, b = [1, 3, -5], [4, -2, -1]\n    assert dotp(a,b) == 3\n\n\n# Works with: Python version 3.7\n'''Dot product'''\n\nfrom operator import (mul)\n\n\n# dotProduct\u00a0:: Num a => [a] -> [a] -> Either String a\ndef dotProduct(xs):\n    '''Either the dot product of xs and ys,\n       or a string reporting unmatched vector sizes.\n    '''\n    return lambda ys: Left('vector sizes differ') if (\n        len(xs) != len(ys)\n    ) else Right(sum(map(mul, xs, ys)))\n\n\n# TEST ----------------------------------------------------\n# main\u00a0:: IO ()\ndef main():\n    '''Dot product of other vectors with [1, 3, -5]'''\n\n    print(\n        fTable(main.__doc__ + ':\\n')(str)(str)(\n            compose(\n                either(append('Undefined\u00a0:: '))(str)\n            )(dotProduct([1, 3, -5]))\n        )([[4, -2, -1, 8], [4, -2], [4, 2, -1], [4, -2, -1]])\n    )\n\n\n# GENERIC -------------------------------------------------\n\n# Left\u00a0:: a -> Either a b\ndef Left(x):\n    '''Constructor for an empty Either (option type) value\n       with an associated string.\n    '''\n    return {'type': 'Either', 'Right': None, 'Left': x}\n\n\n# Right\u00a0:: b -> Either a b\ndef Right(x):\n    '''Constructor for a populated Either (option type) value'''\n    return {'type': 'Either', 'Left': None, 'Right': x}\n\n\n# append (++)\u00a0:: [a] -> [a] -> [a]\n# append (++)\u00a0:: String -> String -> String\ndef append(xs):\n    '''Two lists or strings combined into one.'''\n    return lambda ys: xs + ys\n\n\n# compose (<<<)\u00a0:: (b -> c) -> (a -> b) -> a -> c\ndef compose(g):\n    '''Right to left function composition.'''\n    return lambda f: lambda x: g(f(x))\n\n\n# either\u00a0:: (a -> c) -> (b -> c) -> Either a b -> c\ndef either(fl):\n    '''The application of fl to e if e is a Left value,\n       or the application of fr to e if e is a Right value.\n    '''\n    return lambda fr: lambda e: fl(e['Left']) if (\n        None is e['Right']\n    ) else fr(e['Right'])\n\n\n# FORMATTING ----------------------------------------------\n\n# fTable\u00a0:: String -> (a -> String) ->\n#                     (b -> String) -> (a -> b) -> [a] -> String\ndef fTable(s):\n    '''Heading -> x display function -> fx display function ->\n                     f -> xs -> tabular string.\n    '''\n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\n\n", "human_summarization": "The code implements a function to compute the dot product of two vectors of arbitrary length. It ensures that both vectors are of the same length, multiplies corresponding terms from each vector, and sums the products to produce the final result. It also includes an Either type for error handling, which returns either a computed value or an explanatory string.", "id": "4723", "incomplete_code": "def dotp(a, b):\n    pass\nif __name__ == '__main__':\n    a, b = ([1, 3, -5], [4, -2, -1])\n    assert dotp(a, b) == 3\n'Dot product'\nfrom operator import mul\n\ndef dotProduct(xs):\n    \"\"\"Either the dot product of xs and ys,\n       or a string reporting unmatched vector sizes.\n    \"\"\"\n    pass\n\ndef main():\n    \"\"\"Dot product of other vectors with [1, 3, -5]\"\"\"\n    pass\n\ndef Left(x):\n    \"\"\"Constructor for an empty Either (option type) value\n       with an associated string.\n    \"\"\"\n    pass\n\ndef Right(x):\n    \"\"\"Constructor for a populated Either (option type) value\"\"\"\n    pass\n\ndef append(xs):\n    \"\"\"Two lists or strings combined into one.\"\"\"\n    pass\n\ndef compose(g):\n    \"\"\"Right to left function composition.\"\"\"\n    pass\n\ndef either(fl):\n    \"\"\"The application of fl to e if e is a Left value,\n       or the application of fr to e if e is a Right value.\n    \"\"\"\n    pass\n\ndef fTable(s):\n    \"\"\"Heading -> x display function -> fx display function ->\n                     f -> xs -> tabular string.\n    \"\"\"\n    pass\nif __name__ == '__main__':\n    main()", "original_code": "\ndef dotp(a,b):\n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n\nif __name__ == '__main__':\n    a, b = [1, 3, -5], [4, -2, -1]\n    assert dotp(a,b) == 3\n\n\n# Works with: Python version 3.7\n'''Dot product'''\n\nfrom operator import (mul)\n\n\n# dotProduct\u00a0:: Num a => [a] -> [a] -> Either String a\ndef dotProduct(xs):\n    '''Either the dot product of xs and ys,\n       or a string reporting unmatched vector sizes.\n    '''\n    return lambda ys: Left('vector sizes differ') if (\n        len(xs) != len(ys)\n    ) else Right(sum(map(mul, xs, ys)))\n\n\n# TEST ----------------------------------------------------\n# main\u00a0:: IO ()\ndef main():\n    '''Dot product of other vectors with [1, 3, -5]'''\n\n    print(\n        fTable(main.__doc__ + ':\\n')(str)(str)(\n            compose(\n                either(append('Undefined\u00a0:: '))(str)\n            )(dotProduct([1, 3, -5]))\n        )([[4, -2, -1, 8], [4, -2], [4, 2, -1], [4, -2, -1]])\n    )\n\n\n# GENERIC -------------------------------------------------\n\n# Left\u00a0:: a -> Either a b\ndef Left(x):\n    '''Constructor for an empty Either (option type) value\n       with an associated string.\n    '''\n    return {'type': 'Either', 'Right': None, 'Left': x}\n\n\n# Right\u00a0:: b -> Either a b\ndef Right(x):\n    '''Constructor for a populated Either (option type) value'''\n    return {'type': 'Either', 'Left': None, 'Right': x}\n\n\n# append (++)\u00a0:: [a] -> [a] -> [a]\n# append (++)\u00a0:: String -> String -> String\ndef append(xs):\n    '''Two lists or strings combined into one.'''\n    return lambda ys: xs + ys\n\n\n# compose (<<<)\u00a0:: (b -> c) -> (a -> b) -> a -> c\ndef compose(g):\n    '''Right to left function composition.'''\n    return lambda f: lambda x: g(f(x))\n\n\n# either\u00a0:: (a -> c) -> (b -> c) -> Either a b -> c\ndef either(fl):\n    '''The application of fl to e if e is a Left value,\n       or the application of fr to e if e is a Right value.\n    '''\n    return lambda fr: lambda e: fl(e['Left']) if (\n        None is e['Right']\n    ) else fr(e['Right'])\n\n\n# FORMATTING ----------------------------------------------\n\n# fTable\u00a0:: String -> (a -> String) ->\n#                     (b -> String) -> (a -> b) -> [a] -> String\ndef fTable(s):\n    '''Heading -> x display function -> fx display function ->\n                     f -> xs -> tabular string.\n    '''\n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\n\n", "perturbed_code": "\n\ndef main():\n    print(fTable((':\\n' + main.__doc__))(str)(str)(compose(either(append('Undefined\\xa0:: '))(str))(dotProduct([1, 3, (- 5)])))([[4, (- 2), (- 1), 8], [4, (- 2)], [4, 2, (- 1)], [4, (- 2), (- 1)]]))\n    'Dot product of other vectors with [1, 3, -5]'\n\ndef dotp(a, b):\n    assert (len(b) == len(a)), 'Vector sizes must match'\n    return sum(((aterm * bterm) for (aterm, bterm) in zip(a, b)))\n\ndef fTable(s):\n    'Heading -> x display function -> fx display function ->\\n                     f -> xs -> tabular string.\\n    '\n\n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return ((s + '\\n') + '\\n'.join(map((lambda x, y: (fxShow(f(x)) + (' -> ' + y.rjust(w, ' ')))), xs, ys)))\n    return (lambda xShow: (lambda fxShow: (lambda f: (lambda xs: go(xShow, fxShow, f, xs)))))\n\ndef compose(g):\n    'Right to left function composition.'\n    return (lambda f: (lambda x: g(f(x))))\nif ('__main__' == __name__):\n    main()\n\ndef either(fl):\n    'The application of fl to e if e is a Left value,\\n       or the application of fr to e if e is a Right value.\\n    '\n    return (lambda fr: (lambda e: (fl(e['Left']) if (None is e['Right']) else fr(e['Right']))))\nif ('__main__' == __name__):\n    (a, b) = ([1, 3, (- 5)], [4, (- 2), (- 1)])\n    assert (3 == dotp(a, b))\n\ndef append(xs):\n    'Two lists or strings combined into one.'\n    return (lambda ys: (ys + xs))\nfrom operator import mul\n'Dot product'\n\ndef dotProduct(xs):\n    'Either the dot product of xs and ys,\\n       or a string reporting unmatched vector sizes.\\n    '\n    return (lambda ys: (Left('vector sizes differ') if (len(xs) != len(ys)) else Right(sum(map(mul, xs, ys)))))\n\ndef Left(x):\n    'Constructor for an empty Either (option type) value\\n       with an associated string.\\n    '\n    return {'type': 'Either', 'Right': None, 'Left': x}\n\ndef Right(x):\n    'Constructor for a populated Either (option type) value'\n    return {'type': 'Either', 'Left': None, 'Right': x}\n", "incomplete_perturbed_code": "def main():\n    pass\n\ndef dotp(a, b):\n    pass\n\ndef fTable(s):\n    \"\"\"Heading -> x display function -> fx display function ->\n                     f -> xs -> tabular string.\n    \"\"\"\n    pass\n\ndef compose(g):\n    \"\"\"Right to left function composition.\"\"\"\n    pass\nif '__main__' == __name__:\n    main()\n\ndef either(fl):\n    \"\"\"The application of fl to e if e is a Left value,\n       or the application of fr to e if e is a Right value.\n    \"\"\"\n    pass\nif '__main__' == __name__:\n    a, b = ([1, 3, -5], [4, -2, -1])\n    assert 3 == dotp(a, b)\n\ndef append(xs):\n    \"\"\"Two lists or strings combined into one.\"\"\"\n    pass\nfrom operator import mul\n'Dot product'\n\ndef dotProduct(xs):\n    \"\"\"Either the dot product of xs and ys,\n       or a string reporting unmatched vector sizes.\n    \"\"\"\n    pass\n\ndef Left(x):\n    \"\"\"Constructor for an empty Either (option type) value\n       with an associated string.\n    \"\"\"\n    pass\n\ndef Right(x):\n    \"\"\"Constructor for a populated Either (option type) value\"\"\"\n    pass", "adversarial_score": 2, "original_score": 3, "search_time_seconds": 1238.9027967453003, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 100, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 100, "successful_llm_evaluations": 100, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 0, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 100}, "adversarial_completion": "def main():\n    pass\n\ndef dotp(a, b):\n    if len(a) != len(b):\n        raise ValueError(\"Vectors must have the same length\")\n    return sum(x * y for x, y in zip(a, b))\n\ndef fTable(s):\n    \"\"\"Heading -> x display function -> fx display function ->\n                     f -> xs -> tabular string.\n    \"\"\"\n    pass\n\ndef compose(g):\n    \"\"\"Right to left function composition.\"\"\"\n    pass\nif '__main__' == __name__:\n    main()\n\ndef either(fl):\n    \"\"\"The application of fl to e if e is a Left value,\n       or the application of fr to e if e is a Right value.\n    \"\"\"\n    pass\nif '__main__' == __name__:\n    a, b = ([1, 3, -5], [4, -2, -1])\n    assert 3 == dotp(a, b)\n\ndef append(xs):\n    \"\"\"Two lists or strings combined into one.\"\"\"\n    pass\nfrom operator import mul\n'Dot product'\n\ndef dotProduct(xs, ys):\n    \"\"\"Either the dot product of xs and ys,\n       or a string reporting unmatched vector sizes.\n    \"\"\"\n    if len(xs) != len(ys):\n        return Left(\"Vectors must have the same length\")\n    else:\n        return Right(sum(mul(x, y) for x, y in zip(xs, ys)))\n\ndef Left(x):\n    \"\"\"Constructor for an empty Either (option type) value\n       with an associated string.\n    \"\"\"\n    pass\n\ndef Right(x):\n    \"\"\"Constructor for a populated Either (option type) value\"\"\"\n    pass", "score_distribution_all_attempts": [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]}
{"lang_cluster": "Python", "source_code": "\nimport math\n\nshades = ('.',':','!','*','o','e','&','#','%','@')\n\ndef normalize(v):\n\tlen = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)\n\treturn (v[0]/len, v[1]/len, v[2]/len)\n\ndef dot(x,y):\n\td = x[0]*y[0] + x[1]*y[1] + x[2]*y[2]\n\treturn -d if d < 0 else 0\n\ndef draw_sphere(r, k, ambient, light):\n\tfor i in range(int(math.floor(-r)),int(math.ceil(r)+1)):\n\t\tx = i + 0.5\n\t\tline = ''\n\n\t\tfor j in range(int(math.floor(-2*r)),int(math.ceil(2*r)+1)):\n\t\t\ty = j/2 + 0.5\n\t\t\tif x*x + y*y <= r*r:\n\t\t\t\tvec = normalize((x,y,math.sqrt(r*r - x*x - y*y)))\n\t\t\t\tb = dot(light,vec)**k + ambient\n\t\t\t\tintensity = int((1-b)*(len(shades)-1))\n\t\t\t\tline += shades[intensity] if 0 <= intensity < len(shades) else shades[0]\n\t\t\telse:\n\t\t\t\tline += ' '\n\n\t\tprint(line)\n\nlight = normalize((30,30,-50))\ndraw_sphere(20,4,0.1, light)\ndraw_sphere(10,2,0.4, light)\n\n\n", "human_summarization": "The code utilizes Pygame and Python 3.2.2 to graphically or ASCII art represent a sphere, which can be either static or rotational. It also incorporates random Perlin noise for rendering the sphere. Some unnecessary functions from a 3D graphics library are included in the code.", "id": "4728", "incomplete_code": "import math\nshades = ('.', ':', '!', '*', 'o', 'e', '&', '#', '%', '@')\n\ndef normalize(v):\n    pass\n\ndef dot(x, y):\n    pass\n\ndef draw_sphere(r, k, ambient, light):\n    pass\nlight = normalize((30, 30, -50))\ndraw_sphere(20, 4, 0.1, light)\ndraw_sphere(10, 2, 0.4, light)", "original_code": "\nimport math\n\nshades = ('.',':','!','*','o','e','&','#','%','@')\n\ndef normalize(v):\n\tlen = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)\n\treturn (v[0]/len, v[1]/len, v[2]/len)\n\ndef dot(x,y):\n\td = x[0]*y[0] + x[1]*y[1] + x[2]*y[2]\n\treturn -d if d < 0 else 0\n\ndef draw_sphere(r, k, ambient, light):\n\tfor i in range(int(math.floor(-r)),int(math.ceil(r)+1)):\n\t\tx = i + 0.5\n\t\tline = ''\n\n\t\tfor j in range(int(math.floor(-2*r)),int(math.ceil(2*r)+1)):\n\t\t\ty = j/2 + 0.5\n\t\t\tif x*x + y*y <= r*r:\n\t\t\t\tvec = normalize((x,y,math.sqrt(r*r - x*x - y*y)))\n\t\t\t\tb = dot(light,vec)**k + ambient\n\t\t\t\tintensity = int((1-b)*(len(shades)-1))\n\t\t\t\tline += shades[intensity] if 0 <= intensity < len(shades) else shades[0]\n\t\t\telse:\n\t\t\t\tline += ' '\n\n\t\tprint(line)\n\nlight = normalize((30,30,-50))\ndraw_sphere(20,4,0.1, light)\ndraw_sphere(10,2,0.4, light)\n\n\n", "perturbed_code": "\n\ndef dot(x, y):\n    d = ((x[2] * y[2]) + ((y[1] * x[1]) + (y[0] * x[0])))\n    return ((- d) if (d < 0) else 0)\nshades = ('.', ':', '!', '*', 'o', 'e', '&', '#', '%', '@')\nimport math\n\ndef draw_sphere(r, k, ambient, light):\n    for i in range(int(math.floor((- r))), int((math.ceil(r) + 1))):\n        for j in range(int(math.floor(((- 2) * r))), int((1 + math.ceil((r * 2))))):\n            if (((x * x) + (y * y)) <= (r * r)):\n                vec = normalize((x, y, math.sqrt((((r * r) - (x * x)) - (y * y)))))\n                b = (ambient + (dot(light, vec) ** k))\n                intensity = int(((1 - b) * (len(shades) - 1)))\n                line += (shades[intensity] if (0 <= intensity < len(shades)) else shades[0])\n            else:\n                line += ' '\n            y = ((j / 2) + 0.5)\n        line = ''\n        print(line)\n        x = (0.5 + i)\n\ndef normalize(v):\n    len = math.sqrt((((v[0] ** 2) + (v[1] ** 2)) + (v[2] ** 2)))\n    return ((v[0] / len), (v[1] / len), (v[2] / len))\nlight = normalize((30, 30, (- 50)))\ndraw_sphere(20, 4, 0.1, light)\ndraw_sphere(10, 2, 0.4, light)\n", "incomplete_perturbed_code": "def dot(x, y):\n    pass\nshades = ('.', ':', '!', '*', 'o', 'e', '&', '#', '%', '@')\nimport math\n\ndef draw_sphere(r, k, ambient, light):\n    pass\n\ndef normalize(v):\n    pass\nlight = normalize((30, 30, -50))\ndraw_sphere(20, 4, 0.1, light)\ndraw_sphere(10, 2, 0.4, light)", "adversarial_score": 2, "original_score": 3, "search_time_seconds": 305.989453792572, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 100, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 100, "successful_llm_evaluations": 100, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 0, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 100}, "adversarial_completion": "def dot(x, y):\n    return x[0] * y[0] + x[1] * y[1] + x[2] * y[2]\n\nshades = ('.', ':', '!', '*', 'o', 'e', '&', '#', '%', '@')\nimport math\n\ndef draw_sphere(r, k, ambient, light):\n    for j in range(-k, k + 1):\n        for i in range(-k, k + 1):\n            d = math.sqrt(i * i + j * j)\n            if d > k:\n                continue\n            z = math.sqrt(r * r - i * i - j * j)\n            shade = int(ambient + (1 - ambient) * (1 + math.cos(z) / 2) * (1 + math.cos(i / k) * light[0] + math.cos(j / k) * light[1]) / 3)\n            shade = max(0, min(10, shade))\n            print(shades[shade], end='')\n        print()\n\ndef normalize(v):\n    length = math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2])\n    if length == 0:\n        return (0, 0, 0)\n    return (v[0] / length, v[1] / length, v[2] / length)\n\nlight = normalize((30, 30, -50))\ndraw_sphere(20, 4, 0.1, light)\ndraw_sphere(10, 2, 0.4, light)", "score_distribution_all_attempts": [3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 2, 3, 3, 3, 2, 3, 3, 2, 3, 2, 3, 3, 3, 3, 3, 2, 3, 2, 3, 3, 3, 2, 2, 2, 3, 3, 3, 3, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 2, 2, 3, 3, 3, 3, 3, 2, 2, 2, 3, 3, 3, 3, 3, 3, 2, 3, 3, 2, 3, 3, 2, 2, 2, 2, 3, 3, 2, 3, 3, 3, 3, 2, 3, 2, 3, 3, 3, 3, 3, 2, 3, 2, 3, 2, 2, 3, 2]}
{"lang_cluster": "Python", "source_code": "\n_suffix = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th']\n\ndef nth(n):\n    return \"%i'%s\" % (n, _suffix[n%10] if n % 100 <= 10 or n % 100 > 20 else 'th')\n\nif __name__ == '__main__':\n    for j in range(0,1001, 250):\n        print(' '.join(nth(i) for i in list(range(j, j+25))))\n\n\n", "human_summarization": "The code generates ordinal suffixes for given integers, returning a string of the number followed by an apostrophe and the ordinal suffix. The function handles integer inputs within the ranges of 0 to 25, 250 to 265, and 1000 to 1025. Apostrophes in the output are optional.", "id": "4729", "incomplete_code": "_suffix = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th']\n\ndef nth(n):\n    pass\nif __name__ == '__main__':\n    for j in range(0, 1001, 250):\n        print(' '.join((nth(i) for i in list(range(j, j + 25)))))", "original_code": "\n_suffix = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th']\n\ndef nth(n):\n    return \"%i'%s\" % (n, _suffix[n%10] if n % 100 <= 10 or n % 100 > 20 else 'th')\n\nif __name__ == '__main__':\n    for j in range(0,1001, 250):\n        print(' '.join(nth(i) for i in list(range(j, j+25))))\n\n\n", "perturbed_code": "\n_suffix = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th']\n\ndef nth(n):\n    return (\"%i'%s\" % (n, (_suffix[(n % 10)] if (((n % 100) <= 10) or ((n % 100) > 20)) else 'th')))\nif (__name__ == '__main__'):\n    for j in range(0, 1001, 250):\n        print(' '.join((nth(i) for i in list(range(j, (25 + j))))))\n", "incomplete_perturbed_code": "_suffix = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th']\n\ndef nth(n):\n    pass\nif __name__ == '__main__':\n    for j in range(0, 1001, 250):\n        print(' '.join((nth(i) for i in list(range(j, 25 + j)))))", "adversarial_score": 2, "original_score": 2, "search_time_seconds": 104.17528343200684, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 4, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 20, "successful_llm_evaluations": 20, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 80, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 4}, "adversarial_completion": "_suffix = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th']\n\ndef nth(n):\n    if 0 <= n <= 9:\n        return str(n) + _suffix[n]\n    elif 10 <= n <= 20:\n        return str(n) + 'th'\n    elif 25 <= n <= 250:\n        return str(n) + 'th'\n    elif 250 <= n <= 265:\n        return str(n) + 'th'\n    elif 1000 <= n <= 1025:\n        return str(n) + 'th'\n    else:\n        return str(n) + 'th'\nif __name__ == '__main__':\n    for j in range(0, 1001, 250):\n        print(' '.join((nth(i) for i in list(range(j, 25 + j)))))", "score_distribution_all_attempts": [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]}
{"lang_cluster": "Python", "source_code": "Library: turtle\nfrom turtle import *\n\ndef dragon(step, length):\n    dcr(step, length)\n\ndef dcr(step, length):\n    step -= 1\n    length /= 1.41421\n    if step > 0:\n        right(45)\n        dcr(step, length)\n        left(90)\n        dcl(step, length)\n        right(45)\n    else:\n        right(45)\n        forward(length)\n        left(90)\n        forward(length)\n        right(45)\n\ndef dcl(step, length):\n    step -= 1\n    length /= 1.41421\n\n    if step > 0:\n        left(45)\n        dcr(step, length)\n        right(90)\n        dcl(step, length)\n        left(45)\n    else:\n        left(45)\n        forward(length)\n        right(90)\n        forward(length)\n        left(45)\n\n\nfrom turtle import right, left, forward, speed, exitonclick, hideturtle\n\ndef dragon(level=4, size=200, zig=right, zag=left):\n    if level <= 0:\n        forward(size)\n        return\n\n    size /= 1.41421\n    zig(45)\n    dragon(level-1, size, right, left)\n    zag(90)\n    dragon(level-1, size, left, right)\n    zig(45)\n\nspeed(0)\nhideturtle()\ndragon(6)\nexitonclick() # click to exit\n\n\nfrom turtle import right, left, forward, speed, exitonclick, hideturtle\n\ndef dragon(level=4, size=200, direction=45):\n    if level:\n        right(direction)\n        dragon(level-1, size/1.41421356237, 45)\n        left(direction * 2)\n        dragon(level-1, size/1.41421356237, -45)\n        right(direction)\n    else:\n        forward(size)\n\nspeed(0)\nhideturtle()\ndragon(6)\nexitonclick() # click to exit\n\n", "human_summarization": "The code generates a dragon curve fractal, either displaying it directly or writing it to an image file. It uses recursive, successive approximation, iterative, and Lindenmayer system methods to create the fractal. The code also includes functionality to calculate the absolute direction and X, Y coordinates of a point, and to test whether a given point or segment is on the curve. It can handle different curl directions and expansion levels, and can draw other curves defined by L-systems.", "id": "4733", "incomplete_code": "Library: turtle\nfrom turtle import *\n\ndef dragon(step, length):\n    pass\n\ndef dcr(step, length):\n    pass\n\ndef dcl(step, length):\n    pass\nfrom turtle import right, left, forward, speed, exitonclick, hideturtle\n\ndef dragon(level=4, size=200, zig=right, zag=left):\n    pass\nspeed(0)\nhideturtle()\ndragon(6)\nexitonclick()\nfrom turtle import right, left, forward, speed, exitonclick, hideturtle\n\ndef dragon(level=4, size=200, direction=45):\n    pass\nspeed(0)\nhideturtle()\ndragon(6)\nexitonclick()", "original_code": "Library: turtle\nfrom turtle import *\n\ndef dragon(step, length):\n    dcr(step, length)\n\ndef dcr(step, length):\n    step -= 1\n    length /= 1.41421\n    if step > 0:\n        right(45)\n        dcr(step, length)\n        left(90)\n        dcl(step, length)\n        right(45)\n    else:\n        right(45)\n        forward(length)\n        left(90)\n        forward(length)\n        right(45)\n\ndef dcl(step, length):\n    step -= 1\n    length /= 1.41421\n\n    if step > 0:\n        left(45)\n        dcr(step, length)\n        right(90)\n        dcl(step, length)\n        left(45)\n    else:\n        left(45)\n        forward(length)\n        right(90)\n        forward(length)\n        left(45)\n\n\nfrom turtle import right, left, forward, speed, exitonclick, hideturtle\n\ndef dragon(level=4, size=200, zig=right, zag=left):\n    if level <= 0:\n        forward(size)\n        return\n\n    size /= 1.41421\n    zig(45)\n    dragon(level-1, size, right, left)\n    zag(90)\n    dragon(level-1, size, left, right)\n    zig(45)\n\nspeed(0)\nhideturtle()\ndragon(6)\nexitonclick() # click to exit\n\n\nfrom turtle import right, left, forward, speed, exitonclick, hideturtle\n\ndef dragon(level=4, size=200, direction=45):\n    if level:\n        right(direction)\n        dragon(level-1, size/1.41421356237, 45)\n        left(direction * 2)\n        dragon(level-1, size/1.41421356237, -45)\n        right(direction)\n    else:\n        forward(size)\n\nspeed(0)\nhideturtle()\ndragon(6)\nexitonclick() # click to exit\n\n", "perturbed_code": "\n\ndef dragon(step, length):\n    dcr(step, length)\n\ndef dragon(level=4, size=200, zig=right, zag=left):\n    if (level <= 0):\n        forward(size)\n        return\n    zag(90)\n    zig(45)\n    zig(45)\n    size /= 1.41421\n    dragon((level - 1), size, right, left)\n    dragon((level - 1), size, left, right)\nspeed(0)\nfrom turtle import right, left, forward, speed, exitonclick, hideturtle\nLibrary: turtle\nhideturtle()\nfrom turtle import *\ndragon(6)\nexitonclick()\nfrom turtle import right, left, forward, speed, exitonclick, hideturtle\n\ndef dcr(step, length):\n    if (step > 0):\n        left(90)\n        dcr(step, length)\n        dcl(step, length)\n        right(45)\n        right(45)\n    else:\n        right(45)\n        left(90)\n        right(45)\n        forward(length)\n        forward(length)\n    step -= 1\n    length /= 1.41421\n\ndef dragon(level=4, size=200, direction=45):\n    if level:\n        right(direction)\n        dragon((level - 1), (size / 1.41421356237), 45)\n        left((direction * 2))\n        dragon((level - 1), (size / 1.41421356237), (- 45))\n        right(direction)\n    else:\n        forward(size)\nspeed(0)\nhideturtle()\ndragon(6)\nexitonclick()\n\ndef dcl(step, length):\n    length /= 1.41421\n    step -= 1\n    if (step > 0):\n        dcr(step, length)\n        left(45)\n        left(45)\n        right(90)\n        dcl(step, length)\n    else:\n        forward(length)\n        forward(length)\n        left(45)\n        right(90)\n        left(45)\n", "incomplete_perturbed_code": "def dragon(step, length):\n    pass\n\ndef dragon(level=4, size=200, zig=right, zag=left):\n    pass\nspeed(0)\nfrom turtle import right, left, forward, speed, exitonclick, hideturtle\nLibrary: turtle\nhideturtle()\nfrom turtle import *\ndragon(6)\nexitonclick()\nfrom turtle import right, left, forward, speed, exitonclick, hideturtle\n\ndef dcr(step, length):\n    pass\n\ndef dragon(level=4, size=200, direction=45):\n    pass\nspeed(0)\nhideturtle()\ndragon(6)\nexitonclick()\n\ndef dcl(step, length):\n    pass", "adversarial_score": 2, "original_score": 3, "search_time_seconds": 1460.275634765625, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 100, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 100, "successful_llm_evaluations": 100, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 0, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 100}, "adversarial_completion": "def dragon(step, length):\n    pass\n\ndef dragon(level=4, size=200, zig=right, zag=left):\n    speed(0)\n    from turtle import right, left, forward, speed, exitonclick, hideturtle\n    hideturtle()\n    from turtle import *\n    stack = []\n    x, y = 0, 0\n    angle = 0\n    forward(size / 2)\n    right(90)\n    for i in range(step):\n        save = (angle, x, y)\n        stack.append(save)\n        if i % 2 == 0:\n            forward(length)\n            right(90)\n            angle += 90\n        else:\n            forward(length)\n            left(90)\n            angle -= 90\n        x, y = pos()\n    while stack:\n        angle, x0, y0 = stack.pop()\n        forward(length)\n        if angle == 90:\n            left(90)\n        elif angle == -90:\n            right(90)\n        elif angle == 180:\n            backward(length)\n        elif angle == 0:\n            backward(length)\n        x, y = pos()\n    exitonclick()\n    from turtle import right, left, forward, speed, exitonclick, hideturtle\n\ndef dcr(step, length):\n    pass\n\ndef dragon(level=4, size=200, direction=45):\n    speed(0)\n    hideturtle()\n    from turtle import right, left, forward, speed, exitonclick, hideturtle\n    from turtle import *\n    axiom = \"F\"\n    rules = {\"F\": \"F+F-F-F+F\"}\n    \n    for _ in range(level):\n        axiom = \"\".join([rules.get(char, char) for char in axiom])\n    \n    x, y = 0, 0\n    angle = 0\n    \n    for move in axiom:\n        if move == \"F\":\n            forward(size / (2**level))\n            x, y = pos()\n        elif move == \"+\":\n            right(90)\n            angle += 90\n        elif move == \"-\":\n            left(90)\n            angle -= 90\n    \n    exitonclick()\n\ndef dcl(step, length):\n    pass", "score_distribution_all_attempts": [2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 2, 3, 2, 2, 2, 2, 3, 2, 2, 3, 2, 2, 2, 2, 2, 3, 2, 2, 2, 3, 2, 2, 3, 2, 3, 2, 2, 2]}
{"lang_cluster": "Python", "source_code": "\n\"ha\" * 5  # ==> \"hahahahaha\"\n\n5 * \"ha\"  # ==> \"hahahahaha\"\ndef repeat(s, times):\n    return s * times\n\nprint(repeat(\"ha\", 5))\n\n", "human_summarization": "The code takes a string or a character and repeats it a specified number of times. For instance, repeat(\"ha\", 5) will output \"hahahahaha\". Similarly, repeat-char(\"*\", 5) will output \"*****\". It treats characters as strings of length one.", "id": "4744", "incomplete_code": "'ha' * 5\n5 * 'ha'\n\ndef repeat(s, times):\n    pass\nprint(repeat('ha', 5))", "original_code": "\n\"ha\" * 5  # ==> \"hahahahaha\"\n\n5 * \"ha\"  # ==> \"hahahahaha\"\ndef repeat(s, times):\n    return s * times\n\nprint(repeat(\"ha\", 5))\n\n", "perturbed_code": "\n(5 * 'ha')\n(5 * 'ha')\n\ndef repeat(s, times):\n    return (s * times)\nprint(repeat('ha', 5))\n", "incomplete_perturbed_code": "5 * 'ha'\n5 * 'ha'\n\ndef repeat(s, times):\n    pass\nprint(repeat('ha', 5))", "adversarial_score": 3, "original_score": 5, "search_time_seconds": 28.014686584472656, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 8, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 24, "successful_llm_evaluations": 24, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 76, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 8}, "adversarial_completion": "5 * 'ha'\n5 * 'ha'\n\ndef repeat(s, times):\n    result = \"\"\n    for _ in range(times):\n        result += s\n    return result\nprint(repeat('ha', 5))", "score_distribution_all_attempts": [5, 3, 3, 5, 3, 3, 5, 5, 5, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 3, 3, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 3, 5, 5, 5, 3, 3, 5, 5, 5, 3, 5, 5, 3, 5, 5, 5, 5, 5, 5, 3, 5, 5, 5, 3, 3, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 5, 5, 5, 5, 5, 3, 3, 5, 3, 5, 5, 3, 5, 5, 5, 5, 5, 5, 5, 5, 3, 5, 3, 5]}
{"lang_cluster": "Python", "source_code": "\n# Works with: Python version 3.1\n\n# String masquerading as ppm file (version P3)\nimport io\nppmfileout = io.StringIO('')\n\ndef togreyscale(self):\n    for h in range(self.height):\n        for w in range(self.width):\n            r, g, b = self.get(w, h)\n            l = int(0.2126 * r + 0.7152 * g + 0.0722 * b)\n            self.set(w, h, Colour(l, l, l))\n\nBitmap.togreyscale = togreyscale    \n\n\n# Draw something simple\nbitmap = Bitmap(4, 4, white)\nbitmap.fillrect(1, 0, 1, 2, Colour(127, 0, 63))\nbitmap.set(3, 3, Colour(0, 127, 31))\nprint('Colour:')\n# Write to the open 'file' handle\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\nprint('Grey:')\nbitmap.togreyscale()\nppmfileout = io.StringIO('')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\n\n\n'''\nThe print statement above produces the following output\u00a0:\n\nColour:\nP3\n# generated from Bitmap.writeppmp3\n4 4\n255\n   255 255 255   255 255 255   255 255 255     0 127  31\n   255 255 255   255 255 255   255 255 255   255 255 255\n   255 255 255   127   0  63   255 255 255   255 255 255\n   255 255 255   127   0  63   255 255 255   255 255 255\n\nGrey:\nP3\n# generated from Bitmap.writeppmp3\n4 4\n254\n   254 254 254   254 254 254   254 254 254    93  93  93\n   254 254 254   254 254 254   254 254 254   254 254 254\n   254 254 254    31  31  31   254 254 254   254 254 254\n   254 254 254    31  31  31   254 254 254   254 254 254\n\n'''\n\n", "human_summarization": "extend the data storage type to support grayscale images, convert color images to grayscale and vice versa using the CIE recommended formula for luminance calculation. The code also ensures that rounding errors in floating-point arithmetic do not cause run-time issues or distorted results.", "id": "4751", "incomplete_code": "import io\nppmfileout = io.StringIO('')\n\ndef togreyscale(self):\n    pass\nBitmap.togreyscale = togreyscale\nbitmap = Bitmap(4, 4, white)\nbitmap.fillrect(1, 0, 1, 2, Colour(127, 0, 63))\nbitmap.set(3, 3, Colour(0, 127, 31))\nprint('Colour:')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\nprint('Grey:')\nbitmap.togreyscale()\nppmfileout = io.StringIO('')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\n'\\nThe print statement above produces the following output\\xa0:\\n\\nColour:\\nP3\\n# generated from Bitmap.writeppmp3\\n4 4\\n255\\n   255 255 255   255 255 255   255 255 255     0 127  31\\n   255 255 255   255 255 255   255 255 255   255 255 255\\n   255 255 255   127   0  63   255 255 255   255 255 255\\n   255 255 255   127   0  63   255 255 255   255 255 255\\n\\nGrey:\\nP3\\n# generated from Bitmap.writeppmp3\\n4 4\\n254\\n   254 254 254   254 254 254   254 254 254    93  93  93\\n   254 254 254   254 254 254   254 254 254   254 254 254\\n   254 254 254    31  31  31   254 254 254   254 254 254\\n   254 254 254    31  31  31   254 254 254   254 254 254\\n\\n'", "original_code": "\n# Works with: Python version 3.1\n\n# String masquerading as ppm file (version P3)\nimport io\nppmfileout = io.StringIO('')\n\ndef togreyscale(self):\n    for h in range(self.height):\n        for w in range(self.width):\n            r, g, b = self.get(w, h)\n            l = int(0.2126 * r + 0.7152 * g + 0.0722 * b)\n            self.set(w, h, Colour(l, l, l))\n\nBitmap.togreyscale = togreyscale    \n\n\n# Draw something simple\nbitmap = Bitmap(4, 4, white)\nbitmap.fillrect(1, 0, 1, 2, Colour(127, 0, 63))\nbitmap.set(3, 3, Colour(0, 127, 31))\nprint('Colour:')\n# Write to the open 'file' handle\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\nprint('Grey:')\nbitmap.togreyscale()\nppmfileout = io.StringIO('')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\n\n\n'''\nThe print statement above produces the following output\u00a0:\n\nColour:\nP3\n# generated from Bitmap.writeppmp3\n4 4\n255\n   255 255 255   255 255 255   255 255 255     0 127  31\n   255 255 255   255 255 255   255 255 255   255 255 255\n   255 255 255   127   0  63   255 255 255   255 255 255\n   255 255 255   127   0  63   255 255 255   255 255 255\n\nGrey:\nP3\n# generated from Bitmap.writeppmp3\n4 4\n254\n   254 254 254   254 254 254   254 254 254    93  93  93\n   254 254 254   254 254 254   254 254 254   254 254 254\n   254 254 254    31  31  31   254 254 254   254 254 254\n   254 254 254    31  31  31   254 254 254   254 254 254\n\n'''\n\n", "perturbed_code": "\n\ndef togreyscale(self):\n    for h in range(self.height):\n        for w in range(self.width):\n            (r, g, b) = self.get(w, h)\n            l = int(((0.0722 * b) + ((g * 0.7152) + (0.2126 * r))))\n            self.set(w, h, Colour(l, l, l))\nimport io\nBitmap.togreyscale = togreyscale\nppmfileout = io.StringIO('')\nbitmap = Bitmap(4, 4, white)\nbitmap.fillrect(1, 0, 1, 2, Colour(127, 0, 63))\nbitmap.set(3, 3, Colour(0, 127, 31))\nprint('Colour:')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\nprint('Grey:')\nbitmap.togreyscale()\nppmfileout = io.StringIO('')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\n'\\nThe print statement above produces the following output\\xa0:\\n\\nColour:\\nP3\\n# generated from Bitmap.writeppmp3\\n4 4\\n255\\n   255 255 255   255 255 255   255 255 255     0 127  31\\n   255 255 255   255 255 255   255 255 255   255 255 255\\n   255 255 255   127   0  63   255 255 255   255 255 255\\n   255 255 255   127   0  63   255 255 255   255 255 255\\n\\nGrey:\\nP3\\n# generated from Bitmap.writeppmp3\\n4 4\\n254\\n   254 254 254   254 254 254   254 254 254    93  93  93\\n   254 254 254   254 254 254   254 254 254   254 254 254\\n   254 254 254    31  31  31   254 254 254   254 254 254\\n   254 254 254    31  31  31   254 254 254   254 254 254\\n\\n'\n", "incomplete_perturbed_code": "def togreyscale(self):\n    pass\nimport io\nBitmap.togreyscale = togreyscale\nppmfileout = io.StringIO('')\nbitmap = Bitmap(4, 4, white)\nbitmap.fillrect(1, 0, 1, 2, Colour(127, 0, 63))\nbitmap.set(3, 3, Colour(0, 127, 31))\nprint('Colour:')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\nprint('Grey:')\nbitmap.togreyscale()\nppmfileout = io.StringIO('')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\n'\\nThe print statement above produces the following output\\xa0:\\n\\nColour:\\nP3\\n# generated from Bitmap.writeppmp3\\n4 4\\n255\\n   255 255 255   255 255 255   255 255 255     0 127  31\\n   255 255 255   255 255 255   255 255 255   255 255 255\\n   255 255 255   127   0  63   255 255 255   255 255 255\\n   255 255 255   127   0  63   255 255 255   255 255 255\\n\\nGrey:\\nP3\\n# generated from Bitmap.writeppmp3\\n4 4\\n254\\n   254 254 254   254 254 254   254 254 254    93  93  93\\n   254 254 254   254 254 254   254 254 254   254 254 254\\n   254 254 254    31  31  31   254 254 254   254 254 254\\n   254 254 254    31  31  31   254 254 254   254 254 254\\n\\n'", "adversarial_score": 3, "original_score": 5, "search_time_seconds": 333.50012493133545, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 79, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 81, "successful_llm_evaluations": 81, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 19, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 79}, "adversarial_completion": "def togreyscale(self):\n    new_bitmap = Bitmap(self.width, self.height, white)\n    for x in range(self.width):\n        for y in range(self.height):\n            colour = self.get(x, y)\n            luminance = int(0.299 * colour.r + 0.587 * colour.g + 0.114 * colour.b + 0.5)\n            new_bitmap.set(x, y, Colour(luminance, luminance, luminance))\n    self.data = new_bitmap.data\n    self.colour_depth = 254  # Grayscale has a single channel\nimport io\nclass Colour:\n    def __init__(self, r, g, b):\n        self.r = r\n        self.g = g\n        self.b = b\n\nclass Bitmap:\n    def __init__(self, width, height, colour):\n        self.width = width\n        self.height = height\n        self.data = [[colour for _ in range(width)] for _ in range(height)]\n        self.colour_depth = 255\n\n    def set(self, x, y, colour):\n        self.data[y][x] = colour\n\n    def get(self, x, y):\n        return self.data[y][x]\n\n    def fillrect(self, x, y, width, height, colour):\n        for i in range(y, y + height):\n            for j in range(x, x + width):\n                self.set(j, i, colour)\n\n    def writeppmp3(self, file):\n        file.write(\"P3\\n\")\n        file.write(\"# generated from Bitmap.writeppmp3\\n\")\n        file.write(str(self.width) + \" \" + str(self.height) + \"\\n\")\n        file.write(str(self.colour_depth) + \"\\n\")\n        for y in range(self.height):\n            for x in range(self.width):\n                colour = self.get(x, y)\n                file.write(str(colour.r) + \" \" + str(colour.g) + \" \" + str(colour.b) + \"  \")\n            file.write(\"\\n\")\n    \n    togreyscale = togreyscale\n\nwhite = Colour(255, 255, 255)\nppmfileout = io.StringIO('')\nbitmap = Bitmap(4, 4, white)\nbitmap.fillrect(1, 0, 1, 2, Colour(127, 0, 63))\nbitmap.set(3, 3, Colour(0, 127, 31))\nprint('Colour:')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\nprint('Grey:')\nbitmap.togreyscale()\nppmfileout = io.StringIO('')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())", "score_distribution_all_attempts": [3, 5, 5, 4, 4, 4, 3, 3, 5, 3, 5, 3, 4, 4, 5, 5, 5, 3, 5, 5, 3, 5, 3, 4, 3, 4, 4, 3, 3, 3, 4, 3, 3, 4, 4, 3, 3, 3, 3, 3, 4, 4, 5, 4, 3, 4, 3, 5, 3, 3, 4, 4, 4, 4, 4, 4, 3, 5, 4, 3, 3, 3, 4, 5, 3, 3, 4, 3, 3, 4, 4, 5, 4, 5, 5, 4, 3, 5, 5, 4, 5, 4, 3, 5, 3, 3, 5, 4, 4, 5, 3, 4, 4, 4, 5, 5, 3, 5, 5, 3]}
{"lang_cluster": "Python", "source_code": "\nLibrary: PyQt5\n#!/usr/bin/env python3\nimport sys\n\nfrom PyQt5.QtCore import QBasicTimer, Qt\nfrom PyQt5.QtGui import QFont\nfrom PyQt5.QtWidgets import QApplication, QLabel\n\n\nclass Marquee(QLabel):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.right_to_left_direction = True\n        self.initUI()\n        self.timer = QBasicTimer()\n        self.timer.start(80, self)\n\n    def initUI(self):\n        self.setWindowFlags(Qt.FramelessWindowHint)\n        self.setAttribute(Qt.WA_TranslucentBackground)\n        self.setText(\"Hello World! \")\n        self.setFont(QFont(None, 50, QFont.Bold))\n        # make more irritating for the authenticity with <marquee> element\n        self.setStyleSheet(\"QLabel {color: cyan; }\")\n\n    def timerEvent(self, event):\n        i = 1 if self.right_to_left_direction else -1\n        self.setText(self.text()[i:] + self.text()[:i])  # rotate\n\n    def mouseReleaseEvent(self, event):  # change direction on mouse release\n        self.right_to_left_direction = not self.right_to_left_direction\n\n    def keyPressEvent(self, event):  # exit on Esc\n        if event.key() == Qt.Key_Escape:\n            self.close()\n\n\napp = QApplication(sys.argv)\nw = Marquee()\n# center widget on the screen\nw.adjustSize()  # update w.rect() now\nw.move(QApplication.instance().desktop().screen().rect().center()\n       - w.rect().center())\nw.show()\nsys.exit(app.exec())\n\nLibrary: pygame\nimport pygame, sys\nfrom pygame.locals import *\npygame.init()\n\nYSIZE = 40\nXSIZE = 150\n\nTEXT = \"Hello World! \"\nFONTSIZE = 32\n\nLEFT = False\nRIGHT = True\n\nDIR = RIGHT\n\nTIMETICK = 180\nTICK = USEREVENT + 2\n\nTEXTBOX = pygame.Rect(10,10,XSIZE,YSIZE)\n\npygame.time.set_timer(TICK, TIMETICK)\n\nwindow = pygame.display.set_mode((XSIZE, YSIZE))\npygame.display.set_caption(\"Animation\")\n\nfont = pygame.font.SysFont(None, FONTSIZE)\nscreen = pygame.display.get_surface()\n\ndef rotate():\n    index = DIR and -1 or 1\n    global TEXT\n    TEXT = TEXT[index:]+TEXT[:index]\n\ndef click(position):\n    if TEXTBOX.collidepoint(position):\n        global DIR\n        DIR = not DIR\n\ndef draw():\n    surface = font.render(TEXT, True, (255,255,255), (0,0,0))\n    global TEXTBOX\n    TEXTBOX = screen.blit(surface, TEXTBOX)\n    \ndef input(event):\n    if event.type == QUIT:\n        sys.exit(0)\n    elif event.type == MOUSEBUTTONDOWN:\n        click(event.pos)\n    elif event.type == TICK:\n        draw()\n        rotate()\n\nwhile True:\n    input(pygame.event.wait())\n    pygame.display.flip()\n\nimport Tkinter as tki\n\ndef scroll_text(s, how_many):\n    return s[how_many:] + s[:how_many]\n\ndirection = 1\ntk = tki.Tk()\nvar = tki.Variable(tk)\n\ndef mouse_handler(point):\n    global direction\n    direction *= -1\n\ndef timer_handler():\n    var.set(scroll_text(var.get(),direction))\n    tk.after(125, timer_handler)\n\nvar.set('Hello, World! ')\ntki.Label(tk, textvariable=var).pack()\ntk.bind(\"<Button-1>\", mouse_handler)\ntk.after(125, timer_handler)\ntk.title('Python Animation')\ntki.mainloop()\n\n", "human_summarization": "Create a GUI animation where the string \"Hello World! \" appears to rotate right by periodically moving the last letter to the front. The direction of rotation reverses when the user clicks on the text.", "id": "4752", "incomplete_code": "Library: PyQt5\nimport sys\nfrom PyQt5.QtCore import QBasicTimer, Qt\nfrom PyQt5.QtGui import QFont\nfrom PyQt5.QtWidgets import QApplication, QLabel\n\nclass Marquee(QLabel):\n\n    def __init__(self, **kwargs):\n        pass\n\n    def initUI(self):\n        pass\n\n    def timerEvent(self, event):\n        pass\n\n    def mouseReleaseEvent(self, event):\n        pass\n\n    def keyPressEvent(self, event):\n        pass\napp = QApplication(sys.argv)\nw = Marquee()\nw.adjustSize()\nw.move(QApplication.instance().desktop().screen().rect().center() - w.rect().center())\nw.show()\nsys.exit(app.exec())\nLibrary: pygame\nimport pygame, sys\nfrom pygame.locals import *\npygame.init()\nYSIZE = 40\nXSIZE = 150\nTEXT = 'Hello World! '\nFONTSIZE = 32\nLEFT = False\nRIGHT = True\nDIR = RIGHT\nTIMETICK = 180\nTICK = USEREVENT + 2\nTEXTBOX = pygame.Rect(10, 10, XSIZE, YSIZE)\npygame.time.set_timer(TICK, TIMETICK)\nwindow = pygame.display.set_mode((XSIZE, YSIZE))\npygame.display.set_caption('Animation')\nfont = pygame.font.SysFont(None, FONTSIZE)\nscreen = pygame.display.get_surface()\n\ndef rotate():\n    pass\n\ndef click(position):\n    pass\n\ndef draw():\n    pass\n\ndef input(event):\n    pass\nwhile True:\n    input(pygame.event.wait())\n    pygame.display.flip()\nimport Tkinter as tki\n\ndef scroll_text(s, how_many):\n    pass\ndirection = 1\ntk = tki.Tk()\nvar = tki.Variable(tk)\n\ndef mouse_handler(point):\n    pass\n\ndef timer_handler():\n    pass\nvar.set('Hello, World! ')\ntki.Label(tk, textvariable=var).pack()\ntk.bind('<Button-1>', mouse_handler)\ntk.after(125, timer_handler)\ntk.title('Python Animation')\ntki.mainloop()", "original_code": "\nLibrary: PyQt5\n#!/usr/bin/env python3\nimport sys\n\nfrom PyQt5.QtCore import QBasicTimer, Qt\nfrom PyQt5.QtGui import QFont\nfrom PyQt5.QtWidgets import QApplication, QLabel\n\n\nclass Marquee(QLabel):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.right_to_left_direction = True\n        self.initUI()\n        self.timer = QBasicTimer()\n        self.timer.start(80, self)\n\n    def initUI(self):\n        self.setWindowFlags(Qt.FramelessWindowHint)\n        self.setAttribute(Qt.WA_TranslucentBackground)\n        self.setText(\"Hello World! \")\n        self.setFont(QFont(None, 50, QFont.Bold))\n        # make more irritating for the authenticity with <marquee> element\n        self.setStyleSheet(\"QLabel {color: cyan; }\")\n\n    def timerEvent(self, event):\n        i = 1 if self.right_to_left_direction else -1\n        self.setText(self.text()[i:] + self.text()[:i])  # rotate\n\n    def mouseReleaseEvent(self, event):  # change direction on mouse release\n        self.right_to_left_direction = not self.right_to_left_direction\n\n    def keyPressEvent(self, event):  # exit on Esc\n        if event.key() == Qt.Key_Escape:\n            self.close()\n\n\napp = QApplication(sys.argv)\nw = Marquee()\n# center widget on the screen\nw.adjustSize()  # update w.rect() now\nw.move(QApplication.instance().desktop().screen().rect().center()\n       - w.rect().center())\nw.show()\nsys.exit(app.exec())\n\nLibrary: pygame\nimport pygame, sys\nfrom pygame.locals import *\npygame.init()\n\nYSIZE = 40\nXSIZE = 150\n\nTEXT = \"Hello World! \"\nFONTSIZE = 32\n\nLEFT = False\nRIGHT = True\n\nDIR = RIGHT\n\nTIMETICK = 180\nTICK = USEREVENT + 2\n\nTEXTBOX = pygame.Rect(10,10,XSIZE,YSIZE)\n\npygame.time.set_timer(TICK, TIMETICK)\n\nwindow = pygame.display.set_mode((XSIZE, YSIZE))\npygame.display.set_caption(\"Animation\")\n\nfont = pygame.font.SysFont(None, FONTSIZE)\nscreen = pygame.display.get_surface()\n\ndef rotate():\n    index = DIR and -1 or 1\n    global TEXT\n    TEXT = TEXT[index:]+TEXT[:index]\n\ndef click(position):\n    if TEXTBOX.collidepoint(position):\n        global DIR\n        DIR = not DIR\n\ndef draw():\n    surface = font.render(TEXT, True, (255,255,255), (0,0,0))\n    global TEXTBOX\n    TEXTBOX = screen.blit(surface, TEXTBOX)\n    \ndef input(event):\n    if event.type == QUIT:\n        sys.exit(0)\n    elif event.type == MOUSEBUTTONDOWN:\n        click(event.pos)\n    elif event.type == TICK:\n        draw()\n        rotate()\n\nwhile True:\n    input(pygame.event.wait())\n    pygame.display.flip()\n\nimport Tkinter as tki\n\ndef scroll_text(s, how_many):\n    return s[how_many:] + s[:how_many]\n\ndirection = 1\ntk = tki.Tk()\nvar = tki.Variable(tk)\n\ndef mouse_handler(point):\n    global direction\n    direction *= -1\n\ndef timer_handler():\n    var.set(scroll_text(var.get(),direction))\n    tk.after(125, timer_handler)\n\nvar.set('Hello, World! ')\ntki.Label(tk, textvariable=var).pack()\ntk.bind(\"<Button-1>\", mouse_handler)\ntk.after(125, timer_handler)\ntk.title('Python Animation')\ntki.mainloop()\n\n", "perturbed_code": "\nfrom PyQt5.QtWidgets import QApplication, QLabel\nfrom PyQt5.QtCore import QBasicTimer, Qt\nLibrary: PyQt5\napp = QApplication(sys.argv)\nfrom PyQt5.QtGui import QFont\n\nclass Marquee(QLabel):\n\n    def __init__(self, **kwargs):\n        self.right_to_left_direction = True\n        self.initUI()\n        super().__init__(**kwargs)\n        self.timer = QBasicTimer()\n        self.timer.start(80, self)\n\n    def initUI(self):\n        self.setWindowFlags(Qt.FramelessWindowHint)\n        self.setAttribute(Qt.WA_TranslucentBackground)\n        self.setText('Hello World! ')\n        self.setFont(QFont(None, 50, QFont.Bold))\n        self.setStyleSheet('QLabel {color: cyan; }')\n\n    def timerEvent(self, event):\n        i = (1 if self.right_to_left_direction else (- 1))\n        self.setText((self.text()[:i] + self.text()[i:]))\n\n    def mouseReleaseEvent(self, event):\n        self.right_to_left_direction = (not self.right_to_left_direction)\n\n    def keyPressEvent(self, event):\n        if (event.key() == Qt.Key_Escape):\n            self.close()\nw = Marquee()\nw.adjustSize()\nimport sys\nw.move((QApplication.instance().desktop().screen().rect().center() - w.rect().center()))\nw.show()\nsys.exit(app.exec())\nimport pygame, sys\nLibrary: pygame\nfrom pygame.locals import *\npygame.init()\nYSIZE = 40\nXSIZE = 150\nTEXT = 'Hello World! '\nFONTSIZE = 32\nLEFT = False\nRIGHT = True\nDIR = RIGHT\nTIMETICK = 180\nTICK = (2 + USEREVENT)\nTEXTBOX = pygame.Rect(10, 10, XSIZE, YSIZE)\npygame.time.set_timer(TICK, TIMETICK)\nwindow = pygame.display.set_mode((XSIZE, YSIZE))\npygame.display.set_caption('Animation')\nfont = pygame.font.SysFont(None, FONTSIZE)\nscreen = pygame.display.get_surface()\n\ndef rotate():\n    index = ((DIR and (- 1)) or 1)\n    global TEXT\n    TEXT = (TEXT[index:] + TEXT[:index])\n\ndef click(position):\n    if TEXTBOX.collidepoint(position):\n        global DIR\n        DIR = (not DIR)\n\ndef draw():\n    surface = font.render(TEXT, True, (255, 255, 255), (0, 0, 0))\n    global TEXTBOX\n    TEXTBOX = screen.blit(surface, TEXTBOX)\n\ndef input(event):\n    if (event.type == QUIT):\n        sys.exit(0)\n    elif (event.type == MOUSEBUTTONDOWN):\n        click(event.pos)\n    elif (event.type == TICK):\n        draw()\n        rotate()\nwhile True:\n    input(pygame.event.wait())\n    pygame.display.flip()\nimport Tkinter as tki\n\ndef scroll_text(s, how_many):\n    return (s[how_many:] + s[:how_many])\ndirection = 1\ntk = tki.Tk()\nvar = tki.Variable(tk)\n\ndef mouse_handler(point):\n    global direction\n    direction *= (- 1)\n\ndef timer_handler():\n    var.set(scroll_text(var.get(), direction))\n    tk.after(125, timer_handler)\nvar.set('Hello, World! ')\ntki.Label(tk, textvariable=var).pack()\ntk.bind('<Button-1>', mouse_handler)\ntk.after(125, timer_handler)\ntk.title('Python Animation')\ntki.mainloop()\n", "incomplete_perturbed_code": "from PyQt5.QtWidgets import QApplication, QLabel\nfrom PyQt5.QtCore import QBasicTimer, Qt\nLibrary: PyQt5\napp = QApplication(sys.argv)\nfrom PyQt5.QtGui import QFont\n\nclass Marquee(QLabel):\n\n    def __init__(self, **kwargs):\n        pass\n\n    def initUI(self):\n        pass\n\n    def timerEvent(self, event):\n        pass\n\n    def mouseReleaseEvent(self, event):\n        pass\n\n    def keyPressEvent(self, event):\n        pass\nw = Marquee()\nw.adjustSize()\nimport sys\nw.move(QApplication.instance().desktop().screen().rect().center() - w.rect().center())\nw.show()\nsys.exit(app.exec())\nimport pygame, sys\nLibrary: pygame\nfrom pygame.locals import *\npygame.init()\nYSIZE = 40\nXSIZE = 150\nTEXT = 'Hello World! '\nFONTSIZE = 32\nLEFT = False\nRIGHT = True\nDIR = RIGHT\nTIMETICK = 180\nTICK = 2 + USEREVENT\nTEXTBOX = pygame.Rect(10, 10, XSIZE, YSIZE)\npygame.time.set_timer(TICK, TIMETICK)\nwindow = pygame.display.set_mode((XSIZE, YSIZE))\npygame.display.set_caption('Animation')\nfont = pygame.font.SysFont(None, FONTSIZE)\nscreen = pygame.display.get_surface()\n\ndef rotate():\n    pass\n\ndef click(position):\n    pass\n\ndef draw():\n    pass\n\ndef input(event):\n    pass\nwhile True:\n    input(pygame.event.wait())\n    pygame.display.flip()\nimport Tkinter as tki\n\ndef scroll_text(s, how_many):\n    pass\ndirection = 1\ntk = tki.Tk()\nvar = tki.Variable(tk)\n\ndef mouse_handler(point):\n    pass\n\ndef timer_handler():\n    pass\nvar.set('Hello, World! ')\ntki.Label(tk, textvariable=var).pack()\ntk.bind('<Button-1>', mouse_handler)\ntk.after(125, timer_handler)\ntk.title('Python Animation')\ntki.mainloop()", "adversarial_score": 3, "original_score": 4, "search_time_seconds": 2107.575166463852, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 100, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 100, "successful_llm_evaluations": 100, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 0, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 100}, "adversarial_completion": "from PyQt5.QtWidgets import QApplication, QLabel\nfrom PyQt5.QtCore import QBasicTimer, Qt\nfrom PyQt5.QtGui import QFont\nimport sys\n\nclass Marquee(QLabel):\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.rotating = True\n        self.timer = QBasicTimer(self)\n        self.timer.start(50, self)\n\n    def initUI(self):\n        self.setFont(QFont(\"Arial\", 20))\n        self.setAlignment(Qt.AlignCenter)\n\n    def timerEvent(self, event):\n        if event.timerId() == self.timer.timerId():\n            text = self.text()\n            new_text = text[-1] + text[:-1]\n            self.setText(new_text)\n\n    def mouseReleaseEvent(self, event):\n        self.rotating = not self.rotating\n        if not self.rotating:\n            self.timer.stop()\n        else:\n            self.timer.start(50, self)\n\n    def keyPressEvent(self, event):\n        pass\n\nw = Marquee()\nw.adjustSize()\nimport sys\napp = QApplication(sys.argv)\nw.move(QApplication.instance().desktop().screen().rect().center() - w.rect().center())\nw.show()\nsys.exit(app.exec())\nimport pygame, sys\nfrom pygame.locals import *\npygame.init()\nYSIZE = 40\nXSIZE = 150\nTEXT = 'Hello World! '\nFONTSIZE = 32\nLEFT = False\nRIGHT = True\nDIR = RIGHT\nTIMETICK = 180\nTICK = 2 + USEREVENT\nTEXTBOX = pygame.Rect(10, 10, XSIZE, YSIZE)\npygame.time.set_timer(TICK, TIMETICK)\nwindow = pygame.display.set_mode((XSIZE, YSIZE))\npygame.display.set_caption('Animation')\nfont = pygame.font.SysFont(None, FONTSIZE)\nscreen = pygame.display.get_surface()\n\ndef rotate():\n    global TEXT, DIR\n    if DIR == RIGHT:\n        TEXT = TEXT[1:] + TEXT[0]\n    else:\n        TEXT = TEXT[-1] + TEXT[:-1]\n\ndef click(position):\n    global DIR\n    if position[0] < XSIZE // 2:\n        DIR = LEFT\n    else:\n        DIR = RIGHT\n\ndef draw():\n    screen.fill((0, 0, 0))\n    text_surface = font.render(TEXT, True, (255, 255, 255))\n    screen.blit(text_surface, (10, 10))\n\ndef input(event):\n    if event.type == pygame.QUIT:\n        sys.exit()\n    if event.type == pygame.MOUSEBUTTONDOWN:\n        click(event.pos)\n    if event.type == pygame.USEREVENT and event.number == TICK:\n        rotate()\n\nwhile True:\n    for event in pygame.event.get():\n        input(event)\n    draw()\n    pygame.display.flip()\nimport Tkinter as tki\n\ndef scroll_text(s, how_many):\n    s.set(s.get()[-how_many:] + s.get()[:-how_many])\ndirection = 1\ntk = tki.Tk()\nvar = tki.Variable(tk)\n\ndef mouse_handler(point):\n    pass\n\ndef timer_handler():\n    global var\n    scroll_text(var, 1)\n    tk.after(125, timer_handler)\nvar.set('Hello, World! ')\ntki.Label(tk, textvariable=var).pack()\ntk.bind('<Button-1>', mouse_handler)\ntk.after(125, timer_handler)\ntk.title('Python Animation')\ntki.mainloop()", "score_distribution_all_attempts": [4, 3, 3, 3, 3, 3, 4, 3, 3, 4, 3, 4, 4, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 4, 3, 3, 3, 3, 4, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 4, 3, 3, 4, 4, 3, 4, 4, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 4, 4, 3, 3, 4, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]}
{"lang_cluster": "Python", "source_code": "\n\nfrom random import randrange\n\ndef knuth_shuffle(x):\n    for i in range(len(x)-1, 0, -1):\n        j = randrange(i + 1)\n        x[i], x[j] = x[j], x[i]\n\nx = list(range(10))\nknuth_shuffle(x)\nprint(\"shuffled:\", x)\n\n", "human_summarization": "implement the Knuth shuffle algorithm, also known as the Fisher-Yates shuffle, which randomly shuffles the elements of an array. The algorithm modifies the input array in-place, but can be adjusted to return a new shuffled array if necessary. It can also be amended to iterate from left to right for convenience. The Python standard library function random.shuffle uses this algorithm.", "id": "4760", "incomplete_code": "from random import randrange\n\ndef knuth_shuffle(x):\n    pass\nx = list(range(10))\nknuth_shuffle(x)\nprint('shuffled:', x)", "original_code": "\n\nfrom random import randrange\n\ndef knuth_shuffle(x):\n    for i in range(len(x)-1, 0, -1):\n        j = randrange(i + 1)\n        x[i], x[j] = x[j], x[i]\n\nx = list(range(10))\nknuth_shuffle(x)\nprint(\"shuffled:\", x)\n\n", "perturbed_code": "\nfrom random import randrange\n\ndef knuth_shuffle(x):\n    for i in range((len(x) - 1), 0, (- 1)):\n        j = randrange((i + 1))\n        (x[i], x[j]) = (x[j], x[i])\nx = list(range(10))\nknuth_shuffle(x)\nprint('shuffled:', x)\n", "incomplete_perturbed_code": "from random import randrange\n\ndef knuth_shuffle(x):\n    pass\nx = list(range(10))\nknuth_shuffle(x)\nprint('shuffled:', x)", "adversarial_score": 5, "original_score": 5, "search_time_seconds": 0.17101502418518066, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 2, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 20, "successful_llm_evaluations": 20, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 80, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 2}, "adversarial_completion": "from random import randrange\n\ndef knuth_shuffle(x):\n    n = len(x)\n    for i in range(n - 1, 0, -1):\n        j = randrange(0, i + 1)\n        x[i], x[j] = x[j], x[i]\nx = list(range(10))\nknuth_shuffle(x)\nprint('shuffled:', x)", "score_distribution_all_attempts": [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]}
{"lang_cluster": "Python", "source_code": "\ndef mc_rank(iterable, start=1):\n    \"\"\"Modified competition ranking\"\"\"\n    lastresult, fifo = None, []\n    for n, item in enumerate(iterable, start-1):\n        if item[0] == lastresult:\n            fifo += [item]\n        else:\n            while fifo:\n                yield n, fifo.pop(0)\n            lastresult, fifo = item[0], fifo + [item]\n    while fifo:\n        yield n+1, fifo.pop(0)\n\n\ndef sc_rank(iterable, start=1):\n    \"\"\"Standard competition ranking\"\"\"\n    lastresult, lastrank = None, None\n    for n, item in enumerate(iterable, start):\n        if item[0] == lastresult:\n            yield lastrank, item\n        else:\n            yield n, item\n            lastresult, lastrank = item[0], n\n\n\ndef d_rank(iterable, start=1):\n    \"\"\"Dense ranking\"\"\"\n    lastresult, lastrank = None, start - 1,\n    for item in iterable:\n        if item[0] == lastresult:\n            yield lastrank, item\n        else:\n            lastresult, lastrank = item[0], lastrank + 1\n            yield lastrank, item\n\n\ndef o_rank(iterable, start=1):\n    \"\"\"Ordinal  ranking\"\"\"\n    yield from enumerate(iterable, start)\n\n\ndef f_rank(iterable, start=1):\n    \"\"\"Fractional ranking\"\"\"\n    last, fifo = None, []\n    for n, item in enumerate(iterable, start):\n        if item[0] != last:\n            if fifo:\n                mean = sum(f[0] for f in fifo) / len(fifo)\n                while fifo:\n                    yield mean, fifo.pop(0)[1]\n        last = item[0]\n        fifo.append((n, item))\n    if fifo:\n        mean = sum(f[0] for f in fifo) / len(fifo)\n        while fifo:\n            yield mean, fifo.pop(0)[1]\n\n\nif __name__ == '__main__':\n    scores = [(44, 'Solomon'),\n              (42, 'Jason'),\n              (42, 'Errol'),\n              (41, 'Garry'),\n              (41, 'Bernard'),\n              (41, 'Barry'),\n              (39, 'Stephen')]\n\n    print('\\nScores to be ranked (best first):')\n    for s in scores:\n        print('        %2i %s' % (s ))\n    for ranker in [sc_rank, mc_rank, d_rank, o_rank, f_rank]:\n        print('\\n%s:' % ranker.__doc__)\n        for rank, score in ranker(scores):\n            print('  %3g, %r' % (rank, score))\n\n\n", "human_summarization": "\"Implement functions for five different ranking methods: Standard, Modified, Dense, Ordinal, and Fractional. Each function takes an ordered list of competition scores and applies the respective ranking method. The Standard method shares the first ordinal number for ties, the Modified method shares the last ordinal number for ties, the Dense method shares the next available integer for ties, the Ordinal method assigns the next available integer without special treatment for ties, and the Fractional method shares the mean of the ordinal numbers for ties.\"", "id": "4776", "incomplete_code": "def mc_rank(iterable, start=1):\n    \"\"\"Modified competition ranking\"\"\"\n    pass\n\ndef sc_rank(iterable, start=1):\n    \"\"\"Standard competition ranking\"\"\"\n    pass\n\ndef d_rank(iterable, start=1):\n    \"\"\"Dense ranking\"\"\"\n    pass\n\ndef o_rank(iterable, start=1):\n    \"\"\"Ordinal  ranking\"\"\"\n    pass\n\ndef f_rank(iterable, start=1):\n    \"\"\"Fractional ranking\"\"\"\n    pass\nif __name__ == '__main__':\n    scores = [(44, 'Solomon'), (42, 'Jason'), (42, 'Errol'), (41, 'Garry'), (41, 'Bernard'), (41, 'Barry'), (39, 'Stephen')]\n    print('\\nScores to be ranked (best first):')\n    for s in scores:\n        print('        %2i %s' % s)\n    for ranker in [sc_rank, mc_rank, d_rank, o_rank, f_rank]:\n        print('\\n%s:' % ranker.__doc__)\n        for rank, score in ranker(scores):\n            print('  %3g, %r' % (rank, score))", "original_code": "\ndef mc_rank(iterable, start=1):\n    \"\"\"Modified competition ranking\"\"\"\n    lastresult, fifo = None, []\n    for n, item in enumerate(iterable, start-1):\n        if item[0] == lastresult:\n            fifo += [item]\n        else:\n            while fifo:\n                yield n, fifo.pop(0)\n            lastresult, fifo = item[0], fifo + [item]\n    while fifo:\n        yield n+1, fifo.pop(0)\n\n\ndef sc_rank(iterable, start=1):\n    \"\"\"Standard competition ranking\"\"\"\n    lastresult, lastrank = None, None\n    for n, item in enumerate(iterable, start):\n        if item[0] == lastresult:\n            yield lastrank, item\n        else:\n            yield n, item\n            lastresult, lastrank = item[0], n\n\n\ndef d_rank(iterable, start=1):\n    \"\"\"Dense ranking\"\"\"\n    lastresult, lastrank = None, start - 1,\n    for item in iterable:\n        if item[0] == lastresult:\n            yield lastrank, item\n        else:\n            lastresult, lastrank = item[0], lastrank + 1\n            yield lastrank, item\n\n\ndef o_rank(iterable, start=1):\n    \"\"\"Ordinal  ranking\"\"\"\n    yield from enumerate(iterable, start)\n\n\ndef f_rank(iterable, start=1):\n    \"\"\"Fractional ranking\"\"\"\n    last, fifo = None, []\n    for n, item in enumerate(iterable, start):\n        if item[0] != last:\n            if fifo:\n                mean = sum(f[0] for f in fifo) / len(fifo)\n                while fifo:\n                    yield mean, fifo.pop(0)[1]\n        last = item[0]\n        fifo.append((n, item))\n    if fifo:\n        mean = sum(f[0] for f in fifo) / len(fifo)\n        while fifo:\n            yield mean, fifo.pop(0)[1]\n\n\nif __name__ == '__main__':\n    scores = [(44, 'Solomon'),\n              (42, 'Jason'),\n              (42, 'Errol'),\n              (41, 'Garry'),\n              (41, 'Bernard'),\n              (41, 'Barry'),\n              (39, 'Stephen')]\n\n    print('\\nScores to be ranked (best first):')\n    for s in scores:\n        print('        %2i %s' % (s ))\n    for ranker in [sc_rank, mc_rank, d_rank, o_rank, f_rank]:\n        print('\\n%s:' % ranker.__doc__)\n        for rank, score in ranker(scores):\n            print('  %3g, %r' % (rank, score))\n\n\n", "perturbed_code": "\n\ndef d_rank(iterable, start=1):\n    'Dense ranking'\n    (lastresult, lastrank) = (None, (start - 1))\n    for item in iterable:\n        if (item[0] == lastresult):\n            (yield (lastrank, item))\n        else:\n            (lastresult, lastrank) = (item[0], (1 + lastrank))\n            (yield (lastrank, item))\n\ndef f_rank(iterable, start=1):\n    'Fractional ranking'\n    if fifo:\n        while fifo:\n            (yield (mean, fifo.pop(0)[1]))\n        mean = (sum((f[0] for f in fifo)) / len(fifo))\n    for (n, item) in enumerate(iterable, start):\n        if (last != item[0]):\n            if fifo:\n                while fifo:\n                    (yield (mean, fifo.pop(0)[1]))\n                mean = (sum((f[0] for f in fifo)) / len(fifo))\n        last = item[0]\n        fifo.append((n, item))\n    (last, fifo) = (None, [])\n\ndef o_rank(iterable, start=1):\n    (yield from enumerate(iterable, start))\n    'Ordinal  ranking'\n\ndef mc_rank(iterable, start=1):\n    while fifo:\n        (yield ((1 + n), fifo.pop(0)))\n    'Modified competition ranking'\n    for (n, item) in enumerate(iterable, (start - 1)):\n        if (lastresult == item[0]):\n            fifo += [item]\n        else:\n            while fifo:\n                (yield (n, fifo.pop(0)))\n            (lastresult, fifo) = (item[0], ([item] + fifo))\n    (lastresult, fifo) = (None, [])\n\ndef sc_rank(iterable, start=1):\n    (lastresult, lastrank) = (None, None)\n    'Standard competition ranking'\n    for (n, item) in enumerate(iterable, start):\n        if (item[0] == lastresult):\n            (yield (lastrank, item))\n        else:\n            (yield (n, item))\n            (lastresult, lastrank) = (item[0], n)\nif ('__main__' == __name__):\n    print('\\nScores to be ranked (best first):')\n    for ranker in [sc_rank, mc_rank, d_rank, o_rank, f_rank]:\n        for (rank, score) in ranker(scores):\n            print(('  %3g, %r' % (rank, score)))\n        print(('\\n%s:' % ranker.__doc__))\n    for s in scores:\n        print(('        %2i %s' % s))\n    scores = [(44, 'Solomon'), (42, 'Jason'), (42, 'Errol'), (41, 'Garry'), (41, 'Bernard'), (41, 'Barry'), (39, 'Stephen')]\n", "incomplete_perturbed_code": "def d_rank(iterable, start=1):\n    \"\"\"Dense ranking\"\"\"\n    pass\n\ndef f_rank(iterable, start=1):\n    \"\"\"Fractional ranking\"\"\"\n    pass\n\ndef o_rank(iterable, start=1):\n    pass\n\ndef mc_rank(iterable, start=1):\n    pass\n\ndef sc_rank(iterable, start=1):\n    pass\nif '__main__' == __name__:\n    print('\\nScores to be ranked (best first):')\n    for ranker in [sc_rank, mc_rank, d_rank, o_rank, f_rank]:\n        for rank, score in ranker(scores):\n            print('  %3g, %r' % (rank, score))\n        print('\\n%s:' % ranker.__doc__)\n    for s in scores:\n        print('        %2i %s' % s)\n    scores = [(44, 'Solomon'), (42, 'Jason'), (42, 'Errol'), (41, 'Garry'), (41, 'Bernard'), (41, 'Barry'), (39, 'Stephen')]", "adversarial_score": 1, "original_score": 2, "search_time_seconds": 1961.3243865966797, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 100, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 100, "successful_llm_evaluations": 100, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 0, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 100}, "adversarial_completion": "```python\ndef d_rank(iterable, start=1):\n    \"\"\"Dense ranking\"\"\"\n    ranked = []\n    last_rank = start\n    for score in sorted(iterable, reverse=True):\n        ranked.append((last_rank, score))\n        last_rank += 1\n    return ranked\n\ndef f_rank(iterable, start=1):\n    \"\"\"Fractional ranking\"\"\"\n    ranked = []\n    ordinal = start\n    for i, score in enumerate(sorted(iterable, reverse=True)):\n        count = sum(1 for s in iterable if s == score)\n        rank_sum = ordinal + (count - 1) * 0.5\n        avg_rank = rank_sum / count\n        ranked.append((avg_rank, score))\n        ordinal += count\n    return ranked\n\ndef o_rank(iterable, start=1):\n    \"\"\"Ordinal ranking\"\"\"\n    ranked = []\n    ordinal = start\n    for score in sorted(iterable, reverse=True):\n        ranked.append((ordinal, score))\n        ordinal += 1\n    return ranked\n\ndef mc_rank(iterable, start=1):\n    \"\"\"Modified ranking\"\"\"\n    ranked = []\n    last_rank = start\n    for score in sorted(iterable, reverse=True):\n        ranked.append((last_rank, score))\n        if i < len(iterable) - 1:\n            if score == iterable[i+1]:\n                last_rank = last_rank\n            else:\n                last_rank += 1\n        else:\n            last_rank += 1\n        i += 1\n    \n    i = 0\n    last_rank = start\n    ranked = []\n    for score in sorted(iterable, reverse=True):\n        ranked.append((last_rank, score))\n        if i < len(iterable) - 1:\n            if score == iterable[i+1]:\n                pass\n            else:\n                last_rank += 1\n        else:\n            last_rank += 1\n        i += 1\n    \n    ranked = []\n    last_rank = start\n    for score in sorted(iterable, reverse=True):\n        ranked.append((last_rank, score))\n        if i < len(iterable) - 1:\n            if score == iterable[i+1]:\n                pass\n            else:\n                last_rank += 1\n        else:\n            last_rank += 1\n        i += 1\n    \n    ranked = []\n    last_rank = start\n    i = 0\n    for score in sorted(iterable, reverse=True):\n        ranked.append((last_rank, score))\n        if i < len(iterable) - 1:\n            if score == iterable[i+1]:\n                pass\n            else:\n                last_rank += 1\n        else:\n            last_rank += 1\n        i += 1\n    \n    ranked = []\n    last_rank = start\n    i = 0\n    for score in sorted(iterable, reverse=True):\n        ranked.append((last_rank, score))\n        if i < len(iterable) - 1:\n            if score == iterable[i+1]:\n                pass\n            else:\n                last_rank += 1\n        else:\n            last_rank += 1\n        i += 1\n    \n    ranked = []\n    last_rank = start\n    i = 0\n    for score in sorted(iterable, reverse=True):\n        ranked.append((last_rank, score))\n        if i < len(iterable) - 1:\n            if score == iterable[i+1]:\n                pass\n            else:\n                last_rank += 1\n        else:\n            last_rank += 1\n        i += 1\n    \n    ranked = []\n    last_rank = start\n    i = 0\n    for score in sorted(iterable, reverse=True):\n        ranked.append((last_rank, score))\n        if i < len(iterable) - 1:\n            if score == iterable[i+1]:\n                pass\n            else:\n                last_rank += 1\n        else:\n            last_rank += 1\n        i += 1\n    \n    ranked = []\n    last_rank = start\n    i = 0\n    for score in sorted(iterable, reverse=True):\n        ranked.append((last_rank, score))\n        if i < len(iterable) - 1:\n            if score == iterable[i+1]:\n                pass\n            else:\n                last_rank += 1\n        else:\n            last_rank += 1\n        i += 1\n    \n    ranked = []\n    last_rank = start\n    i = 0\n    for score in sorted(iterable, reverse=True):\n        ranked.append((last_rank, score))\n        if i < len(iterable) - 1:\n            if score == iterable[i+1]:\n                pass\n            else:\n                last_rank += 1\n        else:\n            last_rank += 1\n        i += 1\n    \n    ranked = []\n    last_rank = start\n    i = 0\n    for score in sorted(iterable, reverse=True):\n        ranked.append((last_rank, score))\n        if i < len(iterable) - 1:\n            if score == iterable[i+1]:\n                pass\n            else:\n                last_rank += 1\n        else:\n            last_rank += 1\n        i += 1\n    \n    ranked = []\n    last_rank = start\n    i = 0\n    for score in sorted(iterable, reverse=True):\n        ranked.append((last_rank, score))\n        if i < len(iterable) - 1:\n            if score == iterable[i+1]:\n                pass\n            else:\n                last_rank += 1\n        else:\n            last_rank += 1\n        i += 1\n    \n    ranked = []\n    last_rank = start\n    i = 0\n    for score in sorted(iterable, reverse=True):\n        ranked.append((last_rank, score))\n        if i < len(iterable) - 1:\n            if score == iterable[i+1]:\n                pass\n            else:\n                last_rank += 1\n        else:\n            last_rank += 1\n        i += 1\n    \n    ranked = []\n    last_rank = start\n    i = 0\n    for score in sorted(iterable, reverse=True):\n        ranked.append((last_rank, score))\n        if i < len(iterable) - 1:\n            if score == iterable[i+1]:\n                pass\n            else:\n                last_rank += 1\n        else:\n            last_rank += 1\n        i += 1\n    \n    ranked = []\n    last_rank = start\n    i = 0\n    for score in sorted(iterable, reverse=True):\n        ranked.append((last_rank, score))\n        if i < len(iterable) - 1:\n            if score == iterable[i+1]:\n                pass\n            else:\n                last_rank += 1\n        else:\n            last_rank += 1\n        i += 1\n    \n    ranked = []\n    last_rank = start\n    i = 0\n    for score in sorted(iterable, reverse=True):\n        ranked.append((last_rank, score))\n        if i < len(iterable) - 1:\n            if score == iterable[i+1]:\n                pass\n            else:\n                last_rank += 1\n        else:\n            last_rank += 1\n        i += 1\n    \n    ranked = []\n    last_rank = start\n    i = 0\n    for score in sorted(iterable, reverse=True):\n        ranked.append((last_rank, score))\n        if i < len(iterable) - 1:\n            if score == iterable[i+1]:\n                pass\n            else:\n                last_rank += 1\n        else:\n            last_rank += 1\n        i += 1\n    \n    ranked = []\n    last_rank = start\n    i = 0\n    for score in sorted(iterable, reverse=True):\n        ranked.append((last_rank, score))\n        if i < len(iterable) - 1:\n            if score == iterable[i+1]:\n                pass\n            else:\n                last_rank += 1\n        else:\n            last_rank += 1\n        i += 1\n    \n    ranked = []\n    last_rank = start\n    i = 0\n    for score in sorted(iterable, reverse=True):\n        ranked.append((last_rank, score))\n        if i < len(iterable) - 1:\n            if", "score_distribution_all_attempts": [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 1, 1, 1, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]}
{"lang_cluster": "Python", "source_code": "\n\nfrom itertools import groupby\nfrom collections import namedtuple\n\ndef anyvalidcomb(items, maxwt, val=0, wt=0):\n    ' All combinations below the maxwt '\n    if not items:\n        yield [], val, wt\n    else:\n        this, *items = items            # car, cdr\n        for n in range(this.number + 1):\n            w = wt  + n * this.weight\n            if w > maxwt:\n                break\n            v = val + n * this.value\n            this_comb = [this] * n\n            for comb, value, weight in anyvalidcomb(items, maxwt, v, w):\n                yield this_comb + comb, value, weight\n\nmaxwt = 400\nCOMB, VAL, WT = range(3)\nItem  = namedtuple('Items', 'name weight value number')\nitems = [ Item(*x) for x in\n          (\n            (\"map\", 9, 150, 1),\n            (\"compass\", 13, 35, 1),\n            (\"water\", 153, 200, 3),\n            (\"sandwich\", 50, 60, 2),\n            (\"glucose\", 15, 60, 2),\n            (\"tin\", 68, 45, 3),\n            (\"banana\", 27, 60, 3),\n            (\"apple\", 39, 40, 3),\n            (\"cheese\", 23, 30, 1),\n            (\"beer\", 52, 10, 3),\n            (\"suntan cream\", 11, 70, 1),\n            (\"camera\", 32, 30, 1),\n            (\"t-shirt\", 24, 15, 2),\n            (\"trousers\", 48, 10, 2),\n            (\"umbrella\", 73, 40, 1),\n            (\"waterproof trousers\", 42, 70, 1),\n            (\"waterproof overclothes\", 43, 75, 1),\n            (\"note-case\", 22, 80, 1),\n            (\"sunglasses\", 7, 20, 1),\n            (\"towel\", 18, 12, 2),\n            (\"socks\", 4, 50, 1),\n            (\"book\", 30, 10, 2),\n           ) ]  \n\nbagged = max( anyvalidcomb(items, maxwt), key=lambda c: (c[VAL], -c[WT])) # max val or min wt if values equal\nprint(\"Bagged the following %i items\" % len(bagged[COMB]))\nprint('\\n\\t'.join('%i off: %s' % (len(list(grp)), item.name) for item, grp in groupby(sorted(bagged[COMB]))))\nprint(\"for a total value of %i and a total weight of %i\" % bagged[1:])\n\n\n", "human_summarization": "The code determines the optimal combination of items that a tourist can carry in his knapsack, given a maximum weight limit of 4 kg. It takes into account the weight, value, and quantity of each item. The code uses a dynamic programming approach to solve the zero-one knapsack problem, ensuring the total weight does not exceed the limit and the total value is maximized.", "id": "4778", "incomplete_code": "from itertools import groupby\nfrom collections import namedtuple\n\ndef anyvalidcomb(items, maxwt, val=0, wt=0):\n    \"\"\" All combinations below the maxwt \"\"\"\n    pass\nmaxwt = 400\nCOMB, VAL, WT = range(3)\nItem = namedtuple('Items', 'name weight value number')\nitems = [Item(*x) for x in (('map', 9, 150, 1), ('compass', 13, 35, 1), ('water', 153, 200, 3), ('sandwich', 50, 60, 2), ('glucose', 15, 60, 2), ('tin', 68, 45, 3), ('banana', 27, 60, 3), ('apple', 39, 40, 3), ('cheese', 23, 30, 1), ('beer', 52, 10, 3), ('suntan cream', 11, 70, 1), ('camera', 32, 30, 1), ('t-shirt', 24, 15, 2), ('trousers', 48, 10, 2), ('umbrella', 73, 40, 1), ('waterproof trousers', 42, 70, 1), ('waterproof overclothes', 43, 75, 1), ('note-case', 22, 80, 1), ('sunglasses', 7, 20, 1), ('towel', 18, 12, 2), ('socks', 4, 50, 1), ('book', 30, 10, 2))]\nbagged = max(anyvalidcomb(items, maxwt), key=lambda c: (c[VAL], -c[WT]))\nprint('Bagged the following %i items' % len(bagged[COMB]))\nprint('\\n\\t'.join(('%i off: %s' % (len(list(grp)), item.name) for item, grp in groupby(sorted(bagged[COMB])))))\nprint('for a total value of %i and a total weight of %i' % bagged[1:])", "original_code": "\n\nfrom itertools import groupby\nfrom collections import namedtuple\n\ndef anyvalidcomb(items, maxwt, val=0, wt=0):\n    ' All combinations below the maxwt '\n    if not items:\n        yield [], val, wt\n    else:\n        this, *items = items            # car, cdr\n        for n in range(this.number + 1):\n            w = wt  + n * this.weight\n            if w > maxwt:\n                break\n            v = val + n * this.value\n            this_comb = [this] * n\n            for comb, value, weight in anyvalidcomb(items, maxwt, v, w):\n                yield this_comb + comb, value, weight\n\nmaxwt = 400\nCOMB, VAL, WT = range(3)\nItem  = namedtuple('Items', 'name weight value number')\nitems = [ Item(*x) for x in\n          (\n            (\"map\", 9, 150, 1),\n            (\"compass\", 13, 35, 1),\n            (\"water\", 153, 200, 3),\n            (\"sandwich\", 50, 60, 2),\n            (\"glucose\", 15, 60, 2),\n            (\"tin\", 68, 45, 3),\n            (\"banana\", 27, 60, 3),\n            (\"apple\", 39, 40, 3),\n            (\"cheese\", 23, 30, 1),\n            (\"beer\", 52, 10, 3),\n            (\"suntan cream\", 11, 70, 1),\n            (\"camera\", 32, 30, 1),\n            (\"t-shirt\", 24, 15, 2),\n            (\"trousers\", 48, 10, 2),\n            (\"umbrella\", 73, 40, 1),\n            (\"waterproof trousers\", 42, 70, 1),\n            (\"waterproof overclothes\", 43, 75, 1),\n            (\"note-case\", 22, 80, 1),\n            (\"sunglasses\", 7, 20, 1),\n            (\"towel\", 18, 12, 2),\n            (\"socks\", 4, 50, 1),\n            (\"book\", 30, 10, 2),\n           ) ]  \n\nbagged = max( anyvalidcomb(items, maxwt), key=lambda c: (c[VAL], -c[WT])) # max val or min wt if values equal\nprint(\"Bagged the following %i items\" % len(bagged[COMB]))\nprint('\\n\\t'.join('%i off: %s' % (len(list(grp)), item.name) for item, grp in groupby(sorted(bagged[COMB]))))\nprint(\"for a total value of %i and a total weight of %i\" % bagged[1:])\n\n\n", "perturbed_code": "\n\ndef anyvalidcomb(items, maxwt, val=0, wt=0):\n    ' All combinations below the maxwt '\n    if (not items):\n        (yield ([], val, wt))\n    else:\n        for n in range((1 + this.number)):\n            for (comb, value, weight) in anyvalidcomb(items, maxwt, v, w):\n                (yield ((this_comb + comb), value, weight))\n            if (w > maxwt):\n                break\n            w = (wt + (this.weight * n))\n            this_comb = (n * [this])\n            v = ((n * this.value) + val)\n        (this, *items) = items\nfrom itertools import groupby\n(COMB, VAL, WT) = range(3)\nfrom collections import namedtuple\nItem = namedtuple('Items', 'name weight value number')\nmaxwt = 400\nitems = [Item(*x) for x in (('map', 9, 150, 1), ('compass', 13, 35, 1), ('water', 153, 200, 3), ('sandwich', 50, 60, 2), ('glucose', 15, 60, 2), ('tin', 68, 45, 3), ('banana', 27, 60, 3), ('apple', 39, 40, 3), ('cheese', 23, 30, 1), ('beer', 52, 10, 3), ('suntan cream', 11, 70, 1), ('camera', 32, 30, 1), ('t-shirt', 24, 15, 2), ('trousers', 48, 10, 2), ('umbrella', 73, 40, 1), ('waterproof trousers', 42, 70, 1), ('waterproof overclothes', 43, 75, 1), ('note-case', 22, 80, 1), ('sunglasses', 7, 20, 1), ('towel', 18, 12, 2), ('socks', 4, 50, 1), ('book', 30, 10, 2))]\nbagged = max(anyvalidcomb(items, maxwt), key=(lambda c: (c[VAL], (- c[WT]))))\nprint(('Bagged the following %i items' % len(bagged[COMB])))\nprint('\\n\\t'.join((('%i off: %s' % (len(list(grp)), item.name)) for (item, grp) in groupby(sorted(bagged[COMB])))))\nprint(('for a total value of %i and a total weight of %i' % bagged[1:]))\n", "incomplete_perturbed_code": "def anyvalidcomb(items, maxwt, val=0, wt=0):\n    \"\"\" All combinations below the maxwt \"\"\"\n    pass\nfrom itertools import groupby\nCOMB, VAL, WT = range(3)\nfrom collections import namedtuple\nItem = namedtuple('Items', 'name weight value number')\nmaxwt = 400\nitems = [Item(*x) for x in (('map', 9, 150, 1), ('compass', 13, 35, 1), ('water', 153, 200, 3), ('sandwich', 50, 60, 2), ('glucose', 15, 60, 2), ('tin', 68, 45, 3), ('banana', 27, 60, 3), ('apple', 39, 40, 3), ('cheese', 23, 30, 1), ('beer', 52, 10, 3), ('suntan cream', 11, 70, 1), ('camera', 32, 30, 1), ('t-shirt', 24, 15, 2), ('trousers', 48, 10, 2), ('umbrella', 73, 40, 1), ('waterproof trousers', 42, 70, 1), ('waterproof overclothes', 43, 75, 1), ('note-case', 22, 80, 1), ('sunglasses', 7, 20, 1), ('towel', 18, 12, 2), ('socks', 4, 50, 1), ('book', 30, 10, 2))]\nbagged = max(anyvalidcomb(items, maxwt), key=lambda c: (c[VAL], -c[WT]))\nprint('Bagged the following %i items' % len(bagged[COMB]))\nprint('\\n\\t'.join(('%i off: %s' % (len(list(grp)), item.name) for item, grp in groupby(sorted(bagged[COMB])))))\nprint('for a total value of %i and a total weight of %i' % bagged[1:])", "adversarial_score": 2, "original_score": 3, "search_time_seconds": 928.7607743740082, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 96, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 97, "successful_llm_evaluations": 97, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 3, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 96}, "adversarial_completion": "def anyvalidcomb(items, maxwt, val=0, wt=0):\n    \"\"\" All combinations below the maxwt \"\"\"\n    if wt == maxwt:\n        return ([], val, wt)\n    if not items:\n        return ([], val, wt)\n\n    item = items[0]\n    remaining_items = items[1:]\n\n    # Option 1: Don't include the current item\n    not_included = anyvalidcomb(remaining_items, maxwt, val, wt)\n    not_included_comb = not_included[0]\n\n    # Option 2: Include the current item if possible\n    included = ([], 0, 0)\n    if wt + item.weight <= maxwt:\n        included = anyvalidcomb(remaining_items, maxwt, val + item.value, wt + item.weight)\n        included_comb = included[0]\n\n    # Choose the option with the higher value\n    if included[1] > not_included[1]:\n        return ([item] + included_comb, included[1], included[2])\n    else:\n        return (not_included_comb, not_included[1], not_included[2])\nfrom itertools import groupby\nCOMB, VAL, WT = range(3)\nfrom collections import namedtuple\nItem = namedtuple('Items', 'name weight value number')\nmaxwt = 400\nitems = [Item(*x) for x in (('map', 9, 150, 1), ('compass', 13, 35, 1), ('water', 153, 200, 3), ('sandwich', 50, 60, 2), ('glucose', 15, 60, 2), ('tin', 68, 45, 3), ('banana', 27, 60, 3), ('apple', 39, 40, 3), ('cheese', 23, 30, 1), ('beer', 52, 10, 3), ('suntan cream', 11, 70, 1), ('camera', 32, 30, 1), ('t-shirt', 24, 15, 2), ('trousers', 48, 10, 2), ('umbrella', 73, 40, 1), ('waterproof trousers', 42, 70, 1), ('waterproof overclothes', 43, 75, 1), ('note-case', 22, 80, 1), ('sunglasses', 7, 20, 1), ('towel', 18, 12, 2), ('socks', 4, 50, 1), ('book', 30, 10, 2))]\nbagged = max(anyvalidcomb(items, maxwt), key=lambda c: (c[VAL], -c[WT]))\nprint('Bagged the following %i items' % len(bagged[0]))\nprint('\\n\\t'.join(('%i off: %s' % (len(list(grp)), item.name) for item, grp in groupby(sorted(bagged[0])))))\nprint('for a total value of %i and a total weight of %i' % (bagged[1], bagged[2]))", "score_distribution_all_attempts": [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]}
{"lang_cluster": "Python", "source_code": "\n# Works with: Python version 2.3 through 3.4\nnext = str(int('123') + 1)\n\n# Dropping or keeping any non-numerics in the string\n\n\n# succString\u00a0:: Bool -> String -> String\ndef succString(blnPruned):\n    def go(x):\n        try:\n            return [str(1 + (float(x) if '.' in x else int(x)))]\n        except ValueError:\n            return [] if blnPruned else [x]\n    return lambda s: ' '.join(concatMap(go)(s.split()))\n\n\n# TEST ----------------------------------------------------\ndef main():\n    print(\n        '\\n'.join(\n            [succString(bln)(\n                '41.0 pine martens in 1491 -1.5 mushrooms \u2260 136'\n            ) for bln in [False, True]]\n        )\n    )\n\n\n# GENERIC ---------------------------------------------------\n\n# concatMap\u00a0:: (a -> [b]) -> [a] -> [b]\ndef concatMap(f):\n    return lambda xs: (\n        [ys[0] for ys in [f(x) for x in xs] if ys]\n    )\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\n", "human_summarization": "\"Increment a numerical string, with options to handle both integer and floating point values, manage noisy or multi-number strings, and retain or remove non-numeric parts.\"", "id": "4780", "incomplete_code": "next = str(int('123') + 1)\n\ndef succString(blnPruned):\n    pass\n\ndef main():\n    pass\n\ndef concatMap(f):\n    pass\nif __name__ == '__main__':\n    main()", "original_code": "\n# Works with: Python version 2.3 through 3.4\nnext = str(int('123') + 1)\n\n# Dropping or keeping any non-numerics in the string\n\n\n# succString\u00a0:: Bool -> String -> String\ndef succString(blnPruned):\n    def go(x):\n        try:\n            return [str(1 + (float(x) if '.' in x else int(x)))]\n        except ValueError:\n            return [] if blnPruned else [x]\n    return lambda s: ' '.join(concatMap(go)(s.split()))\n\n\n# TEST ----------------------------------------------------\ndef main():\n    print(\n        '\\n'.join(\n            [succString(bln)(\n                '41.0 pine martens in 1491 -1.5 mushrooms \u2260 136'\n            ) for bln in [False, True]]\n        )\n    )\n\n\n# GENERIC ---------------------------------------------------\n\n# concatMap\u00a0:: (a -> [b]) -> [a] -> [b]\ndef concatMap(f):\n    return lambda xs: (\n        [ys[0] for ys in [f(x) for x in xs] if ys]\n    )\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\n", "perturbed_code": "\nnext = str((int('123') + 1))\n\ndef succString(blnPruned):\n\n    def go(x):\n        try:\n            return [str((1 + (float(x) if ('.' in x) else int(x))))]\n        except ValueError:\n            return ([] if blnPruned else [x])\n    return (lambda s: ' '.join(concatMap(go)(s.split())))\n\ndef main():\n    print('\\n'.join([succString(bln)('41.0 pine martens in 1491 -1.5 mushrooms \u2260 136') for bln in [False, True]]))\n\ndef concatMap(f):\n    return (lambda xs: [ys[0] for ys in [f(x) for x in xs] if ys])\nif (__name__ == '__main__'):\n    main()\n", "incomplete_perturbed_code": "next = str(int('123') + 1)\n\ndef succString(blnPruned):\n    pass\n\ndef main():\n    pass\n\ndef concatMap(f):\n    pass\nif __name__ == '__main__':\n    main()", "adversarial_score": 2, "original_score": 2, "search_time_seconds": 68.99530124664307, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 8, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 20, "successful_llm_evaluations": 11, "failed_llm_evaluations": 9, "cache_hits_reordering_score": 37, "cache_hits_reordering_failed_eval": 43, "total_topo_sorts_generated": 100, "unique_perturbations": 8}, "adversarial_completion": "next = str(int('123') + 1)\n\ndef succString(blnPruned):\n    \"\"\"\n    Increment a numerical string, with options to handle both integer and floating point values,\n    manage noisy or multi-number strings, and retain or remove non-numeric parts.\n    \"\"\"\n    try:\n        if blnPruned:\n            num_str = ''.join(filter(str.isdigit, next))\n            if not num_str:\n                return next\n            num = int(num_str)\n            return str(num + 1)\n        else:\n            num = float(next)\n            return str(num + 1)\n    except ValueError:\n        return next\n\ndef main():\n    \"\"\"\n    Main function to demonstrate the succString function.\n    \"\"\"\n    test_strings = [\"123\", \"123.45\", \"abc123def\", \"123abc\", \"abc\", \"\"]\n    for s in test_strings:\n        print(f\"Original: {s}, Pruned: {succString(True)}, Not Pruned: {succString(False)}\")\n\ndef concatMap(f):\n    \"\"\"\n    Applies a function to each element of a list and concatenates the results.\n    \"\"\"\n    result = \"\"\n    for item in [1, 2, 3, 4, 5]:\n        result += str(f(item))\n    return result\nif __name__ == '__main__':\n    main()", "score_distribution_all_attempts": [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]}
{"lang_cluster": "Python", "source_code": "\n\"\"\"One-time pad using an XOR cipher. Requires Python >=3.6.\"\"\"\n\nimport argparse\nimport itertools\nimport pathlib\nimport re\nimport secrets\nimport sys\n\n\n# One-time pad file signature.\nMAGIC = \"#one-time pad\"\n\n\ndef make_keys(n, size):\n    \"\"\"Generate ``n`` secure, random keys of ``size`` bytes.\"\"\"\n    # We're generating and storing keys in their hexadecimal form to make\n    # one-time pad files a little more human readable and to ensure a key\n    # can not start with a hyphen.\n    return (secrets.token_hex(size) for _ in range(n))\n\n\ndef make_pad(name, pad_size, key_size):\n    \"\"\"Create a new one-time pad identified by the given name.\n\n    Args:\n        name (str): Unique one-time pad identifier.\n        pad_size (int): The number of keys (or pages) in the pad.\n        key_size (int): The number of bytes per key.\n    Returns:\n        The new one-time pad as a string.\n    \"\"\"\n    pad = [\n        MAGIC,\n        f\"#name={name}\",\n        f\"#size={pad_size}\",\n        *make_keys(pad_size, key_size),\n    ]\n\n    return \"\\n\".join(pad)\n\n\ndef xor(message, key):\n    \"\"\"Return ``message`` XOR-ed with ``key``.\n\n    Args:\n        message (bytes): Plaintext or cyphertext to be encrypted or decrypted.\n        key (bytes): Encryption and decryption key.\n    Returns:\n        Plaintext or cyphertext as a byte string.\n    \"\"\"\n    return bytes(mc ^ kc for mc, kc in zip(message, itertools.cycle(key)))\n\n\ndef use_key(pad):\n    \"\"\"Use the next available key from the given one-time pad.\n\n    Args:\n        pad (str): A one-time pad.\n    Returns:\n        (str, str) A two-tuple of updated pad and key.\n    \"\"\"\n    match = re.search(r\"^[a-f0-9]+$\", pad, re.MULTILINE)\n    if not match:\n        error(\"pad is all used up\")\n\n    key = match.group()\n    pos = match.start()\n\n    return (f\"{pad[:pos]}-{pad[pos:]}\", key)\n\n\ndef log(msg):\n    \"\"\"Log a message.\"\"\"\n    sys.stderr.write(msg)\n    sys.stderr.write(\"\\n\")\n\n\ndef error(msg):\n    \"\"\"Exit with an error message.\"\"\"\n    sys.stderr.write(msg)\n    sys.stderr.write(\"\\n\")\n    sys.exit(1)\n\n\ndef write_pad(path, pad_size, key_size):\n    \"\"\"Write a new one-time pad to the given path.\n\n    Args:\n        path (pathlib.Path): Path to write one-time pad to.\n        length (int): Number of keys in the pad.\n    \"\"\"\n    if path.exists():\n        error(f\"pad '{path}' already exists\")\n\n    with path.open(\"w\") as fd:\n        fd.write(make_pad(path.name, pad_size, key_size))\n\n    log(f\"New one-time pad written to {path}\")\n\n\ndef main(pad, message, outfile):\n    \"\"\"Encrypt or decrypt ``message`` using the given pad.\n\n    Args:\n        pad (pathlib.Path): Path to one-time pad.\n        message (bytes): Plaintext or ciphertext message to encrypt or decrypt.\n        outfile: File-like object to write to.\n    \"\"\"\n    if not pad.exists():\n        error(f\"no such pad '{pad}'\")\n\n    with pad.open(\"r\") as fd:\n        if fd.readline().strip() != MAGIC:\n            error(f\"file '{pad}' does not look like a one-time pad\")\n\n    # Rewrites the entire one-time pad every time\n    with pad.open(\"r+\") as fd:\n        updated, key = use_key(fd.read())\n\n        fd.seek(0)\n        fd.write(updated)\n\n    outfile.write(xor(message, bytes.fromhex(key)))\n\n\nif __name__ == \"__main__\":\n    # Command line interface\n    parser = argparse.ArgumentParser(description=\"One-time pad.\")\n\n    parser.add_argument(\n        \"pad\",\n        help=(\n            \"Path to one-time pad. If neither --encrypt or --decrypt \"\n            \"are given, will create a new pad.\"\n        ),\n    )\n\n    parser.add_argument(\n        \"--length\",\n        type=int,\n        default=10,\n        help=\"Pad size. Ignored if --encrypt or --decrypt are given. Defaults to 10.\",\n    )\n\n    parser.add_argument(\n        \"--key-size\",\n        type=int,\n        default=64,\n        help=\"Key size in bytes. Ignored if --encrypt or --decrypt are given. Defaults to 64.\",\n    )\n\n    parser.add_argument(\n        \"-o\",\n        \"--outfile\",\n        type=argparse.FileType(\"wb\"),\n        default=sys.stdout.buffer,\n        help=(\n            \"Write encoded/decoded message to a file. Ignored if --encrypt or \"\n            \"--decrypt is not given. Defaults to stdout.\"\n        ),\n    )\n\n    group = parser.add_mutually_exclusive_group()\n\n    group.add_argument(\n        \"--encrypt\",\n        metavar=\"FILE\",\n        type=argparse.FileType(\"rb\"),\n        help=\"Encrypt FILE using the next available key from pad.\",\n    )\n    group.add_argument(\n        \"--decrypt\",\n        metavar=\"FILE\",\n        type=argparse.FileType(\"rb\"),\n        help=\"Decrypt FILE using the next available key from pad.\",\n    )\n\n    args = parser.parse_args()\n\n    if args.encrypt:\n        message = args.encrypt.read()\n    elif args.decrypt:\n        message = args.decrypt.read()\n    else:\n        message = None\n\n    # Sometimes necessary if message came from stdin\n    if isinstance(message, str):\n        message = message.encode()\n\n    pad = pathlib.Path(args.pad).with_suffix(\".1tp\")\n\n    if message:\n        main(pad, message, args.outfile)\n    else:\n        write_pad(pad, args.length, args.key_size)\n\n\n", "human_summarization": "The code implements a One-time pad for encrypting and decrypting messages using only letters. It generates a One-time pad data based on user-specified filename and length, using true random numbers. The encryption/decryption operation is similar to Rot-13 and reuses much of the Vigen\u00e8re cipher. The code also optionally manages One-time pads, including listing, marking as used, and deleting. It supports the management of pad-files with a \".1tp\" extension, and handles metadata and used status. The code also provides a command-line interface for creating a new one-time pad, distributing it, encrypting a message, and decrypting a message using the shared one-time pad.", "id": 4789, "incomplete_code": "\"\"\"One-time pad using an XOR cipher. Requires Python >=3.6.\"\"\"\nimport argparse\nimport itertools\nimport pathlib\nimport re\nimport secrets\nimport sys\nMAGIC = '#one-time pad'\n\ndef make_keys(n, size):\n    \"\"\"Generate ``n`` secure, random keys of ``size`` bytes.\"\"\"\n    pass\n\ndef make_pad(name, pad_size, key_size):\n    \"\"\"Create a new one-time pad identified by the given name.\n\n    Args:\n        name (str): Unique one-time pad identifier.\n        pad_size (int): The number of keys (or pages) in the pad.\n        key_size (int): The number of bytes per key.\n    Returns:\n        The new one-time pad as a string.\n    \"\"\"\n    pass\n\ndef xor(message, key):\n    \"\"\"Return ``message`` XOR-ed with ``key``.\n\n    Args:\n        message (bytes): Plaintext or cyphertext to be encrypted or decrypted.\n        key (bytes): Encryption and decryption key.\n    Returns:\n        Plaintext or cyphertext as a byte string.\n    \"\"\"\n    pass\n\ndef use_key(pad):\n    \"\"\"Use the next available key from the given one-time pad.\n\n    Args:\n        pad (str): A one-time pad.\n    Returns:\n        (str, str) A two-tuple of updated pad and key.\n    \"\"\"\n    pass\n\ndef log(msg):\n    \"\"\"Log a message.\"\"\"\n    pass\n\ndef error(msg):\n    \"\"\"Exit with an error message.\"\"\"\n    pass\n\ndef write_pad(path, pad_size, key_size):\n    \"\"\"Write a new one-time pad to the given path.\n\n    Args:\n        path (pathlib.Path): Path to write one-time pad to.\n        length (int): Number of keys in the pad.\n    \"\"\"\n    pass\n\ndef main(pad, message, outfile):\n    \"\"\"Encrypt or decrypt ``message`` using the given pad.\n\n    Args:\n        pad (pathlib.Path): Path to one-time pad.\n        message (bytes): Plaintext or ciphertext message to encrypt or decrypt.\n        outfile: File-like object to write to.\n    \"\"\"\n    pass\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='One-time pad.')\n    parser.add_argument('pad', help='Path to one-time pad. If neither --encrypt or --decrypt are given, will create a new pad.')\n    parser.add_argument('--length', type=int, default=10, help='Pad size. Ignored if --encrypt or --decrypt are given. Defaults to 10.')\n    parser.add_argument('--key-size', type=int, default=64, help='Key size in bytes. Ignored if --encrypt or --decrypt are given. Defaults to 64.')\n    parser.add_argument('-o', '--outfile', type=argparse.FileType('wb'), default=sys.stdout.buffer, help='Write encoded/decoded message to a file. Ignored if --encrypt or --decrypt is not given. Defaults to stdout.')\n    group = parser.add_mutually_exclusive_group()\n    group.add_argument('--encrypt', metavar='FILE', type=argparse.FileType('rb'), help='Encrypt FILE using the next available key from pad.')\n    group.add_argument('--decrypt', metavar='FILE', type=argparse.FileType('rb'), help='Decrypt FILE using the next available key from pad.')\n    args = parser.parse_args()\n    if args.encrypt:\n        message = args.encrypt.read()\n    elif args.decrypt:\n        message = args.decrypt.read()\n    else:\n        message = None\n    if isinstance(message, str):\n        message = message.encode()\n    pad = pathlib.Path(args.pad).with_suffix('.1tp')\n    if message:\n        main(pad, message, args.outfile)\n    else:\n        write_pad(pad, args.length, args.key_size)", "original_code": "\n\"\"\"One-time pad using an XOR cipher. Requires Python >=3.6.\"\"\"\n\nimport argparse\nimport itertools\nimport pathlib\nimport re\nimport secrets\nimport sys\n\n\n# One-time pad file signature.\nMAGIC = \"#one-time pad\"\n\n\ndef make_keys(n, size):\n    \"\"\"Generate ``n`` secure, random keys of ``size`` bytes.\"\"\"\n    # We're generating and storing keys in their hexadecimal form to make\n    # one-time pad files a little more human readable and to ensure a key\n    # can not start with a hyphen.\n    return (secrets.token_hex(size) for _ in range(n))\n\n\ndef make_pad(name, pad_size, key_size):\n    \"\"\"Create a new one-time pad identified by the given name.\n\n    Args:\n        name (str): Unique one-time pad identifier.\n        pad_size (int): The number of keys (or pages) in the pad.\n        key_size (int): The number of bytes per key.\n    Returns:\n        The new one-time pad as a string.\n    \"\"\"\n    pad = [\n        MAGIC,\n        f\"#name={name}\",\n        f\"#size={pad_size}\",\n        *make_keys(pad_size, key_size),\n    ]\n\n    return \"\\n\".join(pad)\n\n\ndef xor(message, key):\n    \"\"\"Return ``message`` XOR-ed with ``key``.\n\n    Args:\n        message (bytes): Plaintext or cyphertext to be encrypted or decrypted.\n        key (bytes): Encryption and decryption key.\n    Returns:\n        Plaintext or cyphertext as a byte string.\n    \"\"\"\n    return bytes(mc ^ kc for mc, kc in zip(message, itertools.cycle(key)))\n\n\ndef use_key(pad):\n    \"\"\"Use the next available key from the given one-time pad.\n\n    Args:\n        pad (str): A one-time pad.\n    Returns:\n        (str, str) A two-tuple of updated pad and key.\n    \"\"\"\n    match = re.search(r\"^[a-f0-9]+$\", pad, re.MULTILINE)\n    if not match:\n        error(\"pad is all used up\")\n\n    key = match.group()\n    pos = match.start()\n\n    return (f\"{pad[:pos]}-{pad[pos:]}\", key)\n\n\ndef log(msg):\n    \"\"\"Log a message.\"\"\"\n    sys.stderr.write(msg)\n    sys.stderr.write(\"\\n\")\n\n\ndef error(msg):\n    \"\"\"Exit with an error message.\"\"\"\n    sys.stderr.write(msg)\n    sys.stderr.write(\"\\n\")\n    sys.exit(1)\n\n\ndef write_pad(path, pad_size, key_size):\n    \"\"\"Write a new one-time pad to the given path.\n\n    Args:\n        path (pathlib.Path): Path to write one-time pad to.\n        length (int): Number of keys in the pad.\n    \"\"\"\n    if path.exists():\n        error(f\"pad '{path}' already exists\")\n\n    with path.open(\"w\") as fd:\n        fd.write(make_pad(path.name, pad_size, key_size))\n\n    log(f\"New one-time pad written to {path}\")\n\n\ndef main(pad, message, outfile):\n    \"\"\"Encrypt or decrypt ``message`` using the given pad.\n\n    Args:\n        pad (pathlib.Path): Path to one-time pad.\n        message (bytes): Plaintext or ciphertext message to encrypt or decrypt.\n        outfile: File-like object to write to.\n    \"\"\"\n    if not pad.exists():\n        error(f\"no such pad '{pad}'\")\n\n    with pad.open(\"r\") as fd:\n        if fd.readline().strip() != MAGIC:\n            error(f\"file '{pad}' does not look like a one-time pad\")\n\n    # Rewrites the entire one-time pad every time\n    with pad.open(\"r+\") as fd:\n        updated, key = use_key(fd.read())\n\n        fd.seek(0)\n        fd.write(updated)\n\n    outfile.write(xor(message, bytes.fromhex(key)))\n\n\nif __name__ == \"__main__\":\n    # Command line interface\n    parser = argparse.ArgumentParser(description=\"One-time pad.\")\n\n    parser.add_argument(\n        \"pad\",\n        help=(\n            \"Path to one-time pad. If neither --encrypt or --decrypt \"\n            \"are given, will create a new pad.\"\n        ),\n    )\n\n    parser.add_argument(\n        \"--length\",\n        type=int,\n        default=10,\n        help=\"Pad size. Ignored if --encrypt or --decrypt are given. Defaults to 10.\",\n    )\n\n    parser.add_argument(\n        \"--key-size\",\n        type=int,\n        default=64,\n        help=\"Key size in bytes. Ignored if --encrypt or --decrypt are given. Defaults to 64.\",\n    )\n\n    parser.add_argument(\n        \"-o\",\n        \"--outfile\",\n        type=argparse.FileType(\"wb\"),\n        default=sys.stdout.buffer,\n        help=(\n            \"Write encoded/decoded message to a file. Ignored if --encrypt or \"\n            \"--decrypt is not given. Defaults to stdout.\"\n        ),\n    )\n\n    group = parser.add_mutually_exclusive_group()\n\n    group.add_argument(\n        \"--encrypt\",\n        metavar=\"FILE\",\n        type=argparse.FileType(\"rb\"),\n        help=\"Encrypt FILE using the next available key from pad.\",\n    )\n    group.add_argument(\n        \"--decrypt\",\n        metavar=\"FILE\",\n        type=argparse.FileType(\"rb\"),\n        help=\"Decrypt FILE using the next available key from pad.\",\n    )\n\n    args = parser.parse_args()\n\n    if args.encrypt:\n        message = args.encrypt.read()\n    elif args.decrypt:\n        message = args.decrypt.read()\n    else:\n        message = None\n\n    # Sometimes necessary if message came from stdin\n    if isinstance(message, str):\n        message = message.encode()\n\n    pad = pathlib.Path(args.pad).with_suffix(\".1tp\")\n\n    if message:\n        main(pad, message, args.outfile)\n    else:\n        write_pad(pad, args.length, args.key_size)\n\n\n", "perturbed_code": "\n\"\"\"One-time pad using an XOR cipher. Requires Python >=3.6.\"\"\"\n\nimport argparse\nimport itertools\nimport pathlib\nimport re\nimport secrets\nimport sys\n\n\n# One-time pad file signature.\nMAGIC = \"#one-time pad\"\n\n\ndef make_keys(n, size):\n    \"\"\"Generate ``n`` secure, random keys of ``size`` bytes.\"\"\"\n    # We're generating and storing keys in their hexadecimal form to make\n    # one-time pad files a little more human readable and to ensure a key\n    # can not start with a hyphen.\n    return (secrets.token_hex(size) for _ in range(n))\n\n\ndef make_pad(name, pad_size, key_size):\n    \"\"\"Create a new one-time pad identified by the given name.\n\n    Args:\n        name (str): Unique one-time pad identifier.\n        pad_size (int): The number of keys (or pages) in the pad.\n        key_size (int): The number of bytes per key.\n    Returns:\n        The new one-time pad as a string.\n    \"\"\"\n    pad = [\n        MAGIC,\n        f\"#name={name}\",\n        f\"#size={pad_size}\",\n        *make_keys(pad_size, key_size),\n    ]\n\n    return \"\\n\".join(pad)\n\n\ndef xor(message, key):\n    \"\"\"Return ``message`` XOR-ed with ``key``.\n\n    Args:\n        message (bytes): Plaintext or cyphertext to be encrypted or decrypted.\n        key (bytes): Encryption and decryption key.\n    Returns:\n        Plaintext or cyphertext as a byte string.\n    \"\"\"\n    return bytes(mc ^ kc for mc, kc in zip(message, itertools.cycle(key)))\n\n\ndef use_key(pad):\n    \"\"\"Use the next available key from the given one-time pad.\n\n    Args:\n        pad (str): A one-time pad.\n    Returns:\n        (str, str) A two-tuple of updated pad and key.\n    \"\"\"\n    match = re.search(r\"^[a-f0-9]+$\", pad, re.MULTILINE)\n    if not match:\n        error(\"pad is all used up\")\n\n    key = match.group()\n    pos = match.start()\n\n    return (f\"{pad[:pos]}-{pad[pos:]}\", key)\n\n\ndef log(msg):\n    \"\"\"Log a message.\"\"\"\n    sys.stderr.write(msg)\n    sys.stderr.write(\"\\n\")\n\n\ndef error(msg):\n    \"\"\"Exit with an error message.\"\"\"\n    sys.stderr.write(msg)\n    sys.stderr.write(\"\\n\")\n    sys.exit(1)\n\n\ndef write_pad(path, pad_size, key_size):\n    \"\"\"Write a new one-time pad to the given path.\n\n    Args:\n        path (pathlib.Path): Path to write one-time pad to.\n        length (int): Number of keys in the pad.\n    \"\"\"\n    if path.exists():\n        error(f\"pad '{path}' already exists\")\n\n    with path.open(\"w\") as fd:\n        fd.write(make_pad(path.name, pad_size, key_size))\n\n    log(f\"New one-time pad written to {path}\")\n\n\ndef main(pad, message, outfile):\n    \"\"\"Encrypt or decrypt ``message`` using the given pad.\n\n    Args:\n        pad (pathlib.Path): Path to one-time pad.\n        message (bytes): Plaintext or ciphertext message to encrypt or decrypt.\n        outfile: File-like object to write to.\n    \"\"\"\n    if not pad.exists():\n        error(f\"no such pad '{pad}'\")\n\n    with pad.open(\"r\") as fd:\n        if fd.readline().strip() != MAGIC:\n            error(f\"file '{pad}' does not look like a one-time pad\")\n\n    # Rewrites the entire one-time pad every time\n    with pad.open(\"r+\") as fd:\n        updated, key = use_key(fd.read())\n\n        fd.seek(0)\n        fd.write(updated)\n\n    outfile.write(xor(message, bytes.fromhex(key)))\n\n\nif __name__ == \"__main__\":\n    # Command line interface\n    parser = argparse.ArgumentParser(description=\"One-time pad.\")\n\n    parser.add_argument(\n        \"pad\",\n        help=(\n            \"Path to one-time pad. If neither --encrypt or --decrypt \"\n            \"are given, will create a new pad.\"\n        ),\n    )\n\n    parser.add_argument(\n        \"--length\",\n        type=int,\n        default=10,\n        help=\"Pad size. Ignored if --encrypt or --decrypt are given. Defaults to 10.\",\n    )\n\n    parser.add_argument(\n        \"--key-size\",\n        type=int,\n        default=64,\n        help=\"Key size in bytes. Ignored if --encrypt or --decrypt are given. Defaults to 64.\",\n    )\n\n    parser.add_argument(\n        \"-o\",\n        \"--outfile\",\n        type=argparse.FileType(\"wb\"),\n        default=sys.stdout.buffer,\n        help=(\n            \"Write encoded/decoded message to a file. Ignored if --encrypt or \"\n            \"--decrypt is not given. Defaults to stdout.\"\n        ),\n    )\n\n    group = parser.add_mutually_exclusive_group()\n\n    group.add_argument(\n        \"--encrypt\",\n        metavar=\"FILE\",\n        type=argparse.FileType(\"rb\"),\n        help=\"Encrypt FILE using the next available key from pad.\",\n    )\n    group.add_argument(\n        \"--decrypt\",\n        metavar=\"FILE\",\n        type=argparse.FileType(\"rb\"),\n        help=\"Decrypt FILE using the next available key from pad.\",\n    )\n\n    args = parser.parse_args()\n\n    if args.encrypt:\n        message = args.encrypt.read()\n    elif args.decrypt:\n        message = args.decrypt.read()\n    else:\n        message = None\n\n    # Sometimes necessary if message came from stdin\n    if isinstance(message, str):\n        message = message.encode()\n\n    pad = pathlib.Path(args.pad).with_suffix(\".1tp\")\n\n    if message:\n        main(pad, message, args.outfile)\n    else:\n        write_pad(pad, args.length, args.key_size)\n\n\n", "adversarial_score": Infinity, "original_score": 3, "notes": "No valid adversarial evaluations"}
{"lang_cluster": "Python", "source_code": "\nfrom itertools import permutations\n \ndef solve():\n    c, p, f, s = \"\\\\,Police,Fire,Sanitation\".split(',')\n    print(f\"{c:>3}  {p:^6} {f:^4} {s:^10}\")\n    c = 1\n    for p, f, s in permutations(range(1, 8), r=3):\n        if p + s + f == 12 and p % 2 == 0:\n            print(f\"{c:>3}: {p:^6} {f:^4} {s:^10}\")\n            c += 1\n \nif __name__ == '__main__':\n    solve()\n\n\n", "human_summarization": "all possible combinations of department numbers for the police, sanitation, and fire departments where each department has a unique number between 1 and 7, the total sum of the numbers is 12, and the police department's number is even. The combinations are generated using a constraint solver.", "id": "4791", "incomplete_code": "from itertools import permutations\n\ndef solve():\n    pass\nif __name__ == '__main__':\n    solve()", "original_code": "\nfrom itertools import permutations\n \ndef solve():\n    c, p, f, s = \"\\\\,Police,Fire,Sanitation\".split(',')\n    print(f\"{c:>3}  {p:^6} {f:^4} {s:^10}\")\n    c = 1\n    for p, f, s in permutations(range(1, 8), r=3):\n        if p + s + f == 12 and p % 2 == 0:\n            print(f\"{c:>3}: {p:^6} {f:^4} {s:^10}\")\n            c += 1\n \nif __name__ == '__main__':\n    solve()\n\n\n", "perturbed_code": "\nfrom itertools import permutations\n\ndef solve():\n    (c, p, f, s) = '\\\\,Police,Fire,Sanitation'.split(',')\n    print(f'{c:>3}  {p:^6} {f:^4} {s:^10}')\n    c = 1\n    for (p, f, s) in permutations(range(1, 8), r=3):\n        if ((12 == (f + (p + s))) and ((p % 2) == 0)):\n            print(f'{c:>3}: {p:^6} {f:^4} {s:^10}')\n            c += 1\nif ('__main__' == __name__):\n    solve()\n", "incomplete_perturbed_code": "from itertools import permutations\n\ndef solve():\n    pass\nif '__main__' == __name__:\n    solve()", "adversarial_score": 3, "original_score": 3, "search_time_seconds": 38.75139355659485, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 32, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 37, "successful_llm_evaluations": 37, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 63, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 32}, "adversarial_completion": "from itertools import permutations\n\ndef solve():\n    departments = [1, 2, 3, 4, 5, 6, 7]\n    results = []\n    for perm in permutations(departments, 3):\n        police, sanitation, fire = perm\n        if police % 2 == 0 and police + sanitation + fire == 12:\n            results.append((police, sanitation, fire))\n    \n    for result in results:\n        print(f\"Police: {result[0]}, Sanitation: {result[1]}, Fire: {result[2]}\")\n\nif '__main__' == __name__:\n    solve()", "score_distribution_all_attempts": [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]}
{"lang_cluster": "Python", "source_code": "\n# Works with: Python version 3.0.# Works with: Python version 2.6\ndef F(n): return 1 if n == 0 else n - M(F(n-1))\ndef M(n): return 0 if n == 0 else n - F(M(n-1))\n\nprint ([ F(n) for n in range(20) ])\nprint ([ M(n) for n in range(20) ])\n\n\n", "human_summarization": "implement two mutually recursive functions to compute the Hofstadter Female and Male sequences. The functions use each other in their definitions and computations. The Female sequence starts with 1 and the Male sequence starts with 0. For any number n greater than 0, the Female sequence is computed as n minus the Male sequence at the index of the previous Female sequence, and the Male sequence is computed as n minus the Female sequence at the index of the previous Male sequence. The functions are defined in such a way that they can be used in languages that do not require pre-declaration of functions.", "id": "4793", "incomplete_code": "def F(n):\n    pass\n\ndef M(n):\n    pass\nprint([F(n) for n in range(20)])\nprint([M(n) for n in range(20)])", "original_code": "\n# Works with: Python version 3.0.# Works with: Python version 2.6\ndef F(n): return 1 if n == 0 else n - M(F(n-1))\ndef M(n): return 0 if n == 0 else n - F(M(n-1))\n\nprint ([ F(n) for n in range(20) ])\nprint ([ M(n) for n in range(20) ])\n\n\n", "perturbed_code": "\n\ndef F(n):\n    return (1 if (0 == n) else (n - M(F((n - 1)))))\n\ndef M(n):\n    return (0 if (n == 0) else (n - F(M((n - 1)))))\nprint([F(n) for n in range(20)])\nprint([M(n) for n in range(20)])\n", "incomplete_perturbed_code": "def F(n):\n    pass\n\ndef M(n):\n    pass\nprint([F(n) for n in range(20)])\nprint([M(n) for n in range(20)])", "adversarial_score": 5, "original_score": 5, "search_time_seconds": 0.1549220085144043, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 4, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 20, "successful_llm_evaluations": 20, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 80, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 4}, "adversarial_completion": "def F(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return n - M(F(n - 1))\n\ndef M(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    else:\n        return n - F(M(n - 1))\nprint([F(n) for n in range(20)])\nprint([M(n) for n in range(20)])", "score_distribution_all_attempts": [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]}
{"lang_cluster": "Python", "source_code": "import pygame, sys\nfrom pygame.locals import *\nfrom math import sin, cos, radians\n\npygame.init()\n\nWINDOWSIZE = 250\nTIMETICK = 100\nBOBSIZE = 15\n\nwindow = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))\npygame.display.set_caption(\"Pendulum\")\n\nscreen = pygame.display.get_surface()\nscreen.fill((255,255,255))\n\nPIVOT = (WINDOWSIZE/2, WINDOWSIZE/10)\nSWINGLENGTH = PIVOT[1]*4\n\nclass BobMass(pygame.sprite.Sprite):\n    def __init__(self):\n        pygame.sprite.Sprite.__init__(self)\n        self.theta = 45\n        self.dtheta = 0\n        self.rect = pygame.Rect(PIVOT[0]-SWINGLENGTH*cos(radians(self.theta)),\n                                PIVOT[1]+SWINGLENGTH*sin(radians(self.theta)),\n                                1,1)\n        self.draw()\n\n    def recomputeAngle(self):\n        scaling = 3000.0/(SWINGLENGTH**2)\n\n        firstDDtheta = -sin(radians(self.theta))*scaling\n        midDtheta = self.dtheta + firstDDtheta\n        midtheta = self.theta + (self.dtheta + midDtheta)/2.0\n\n        midDDtheta = -sin(radians(midtheta))*scaling\n        midDtheta = self.dtheta + (firstDDtheta + midDDtheta)/2\n        midtheta = self.theta + (self.dtheta + midDtheta)/2\n\n        midDDtheta = -sin(radians(midtheta)) * scaling\n        lastDtheta = midDtheta + midDDtheta\n        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0\n        \n        lastDDtheta = -sin(radians(lasttheta)) * scaling\n        lastDtheta = midDtheta + (midDDtheta + lastDDtheta)/2.0\n        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0\n\n        self.dtheta = lastDtheta\n        self.theta = lasttheta\n        self.rect = pygame.Rect(PIVOT[0]-\n                                SWINGLENGTH*sin(radians(self.theta)), \n                                PIVOT[1]+\n                                SWINGLENGTH*cos(radians(self.theta)),1,1)\n\n\n    def draw(self):\n        pygame.draw.circle(screen, (0,0,0), PIVOT, 5, 0)\n        pygame.draw.circle(screen, (0,0,0), self.rect.center, BOBSIZE, 0)\n        pygame.draw.aaline(screen, (0,0,0), PIVOT, self.rect.center)\n        pygame.draw.line(screen, (0,0,0), (0, PIVOT[1]), (WINDOWSIZE, PIVOT[1]))\n\n    def update(self):\n        self.recomputeAngle()\n        screen.fill((255,255,255))\n        self.draw()\n\nbob = BobMass()\n\nTICK = USEREVENT + 2\npygame.time.set_timer(TICK, TIMETICK)\n\ndef input(events):\n    for event in events:\n        if event.type == QUIT:\n            sys.exit(0)\n        elif event.type == TICK:\n            bob.update()\n\nwhile True:\n    input(pygame.event.get())\n    pygame.display.flip()\n\n''' Python 3.6.5 code using Tkinter graphical user interface.''' \n\nfrom tkinter import *\nimport math\n\nclass Animation:\n    def __init__(self, gw):\n        self.window = gw\n        self.xoff, self.yoff = 300, 100\n        self.angle = 0\n        self.sina = math.sin(self.angle)\n        self.cosa = math.cos(self.angle)\n        self.rodhyp = 170\n        self.bobr = 30\n        self.bobhyp = self.rodhyp + self.bobr\n        self.rodx0, self.rody0 = self.xoff, self.yoff\n        self.ra = self.rodx0\n        self.rb = self.rody0\n        self.rc = self.xoff + self.rodhyp*self.sina\n        self.rd = self.yoff + self.rodhyp*self.cosa\n        self.ba = self.xoff - self.bobr + self.bobhyp*self.sina\n        self.bb = self.yoff - self.bobr + self.bobhyp*self.cosa\n        self.bc = self.xoff + self.bobr + self.bobhyp*self.sina\n        self.bd = self.yoff + self.bobr + self.bobhyp*self.cosa\n        self.da = math.pi / 360\n\n        # create / fill canvas:\n        self.cnv = Canvas(gw, bg='lemon chiffon')\n        self.cnv.pack(fill=BOTH, expand=True)\n\n        self.cnv.create_line(0, 100, 600, 100,\n                             fill='dodger blue',\n                             width=3)\n        radius = 8\n        self.cnv.create_oval(300-radius, 100-radius,\n                             300+radius, 100+radius,\n                             fill='navy')    \n\n        self.bob = self.cnv.create_oval(self.ba,\n                                        self.bb,\n                                        self.bc,\n                                        self.bd,\n                                        fill='red',\n                                        width=2)\n\n        self.rod = self.cnv.create_line(self.ra,\n                                        self.rb,\n                                        self.rc,\n                                        self.rd,\n                                        fill='dodger blue',\n                                        width=6)\n\n        self.animate()\n\n    def animate(self):\n        if abs(self.angle) > math.pi / 2:\n            self.da = - self.da\n        self.angle += self.da\n        self.sina = math.sin(self.angle)\n        self.cosa = math.cos(self.angle)\n        self.ra = self.rodx0\n        self.rb = self.rody0\n        self.rc = self.xoff + self.rodhyp*self.sina\n        self.rd = self.yoff + self.rodhyp*self.cosa\n        self.ba = self.xoff - self.bobr + self.bobhyp*self.sina\n        self.bb = self.yoff - self.bobr + self.bobhyp*self.cosa\n        self.bc = self.xoff + self.bobr + self.bobhyp*self.sina\n        self.bd = self.yoff + self.bobr + self.bobhyp*self.cosa\n        \n        self.cnv.coords(self.rod,\n                        self.ra,\n                        self.rb,\n                        self.rc,\n                        self.rd)\n        self.cnv.coords(self.bob,\n                        self.ba,\n                        self.bb,\n                        self.bc,\n                        self.bd)\n        self.window.update()\n        self.cnv.after(5, self.animate)\n         \nroot = Tk()\nroot.title('Pendulum')\nroot.geometry('600x400+100+50')\nroot.resizable(False, False)\na = Animation(root)\nroot.mainloop()\n\n", "human_summarization": "create and animate a simple physical model of a gravity pendulum.", "id": "4798", "incomplete_code": "import pygame, sys\nfrom pygame.locals import *\nfrom math import sin, cos, radians\npygame.init()\nWINDOWSIZE = 250\nTIMETICK = 100\nBOBSIZE = 15\nwindow = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))\npygame.display.set_caption('Pendulum')\nscreen = pygame.display.get_surface()\nscreen.fill((255, 255, 255))\nPIVOT = (WINDOWSIZE / 2, WINDOWSIZE / 10)\nSWINGLENGTH = PIVOT[1] * 4\n\nclass BobMass(pygame.sprite.Sprite):\n\n    def __init__(self):\n        pass\n\n    def recomputeAngle(self):\n        pass\n\n    def draw(self):\n        pass\n\n    def update(self):\n        pass\nbob = BobMass()\nTICK = USEREVENT + 2\npygame.time.set_timer(TICK, TIMETICK)\n\ndef input(events):\n    pass\nwhile True:\n    input(pygame.event.get())\n    pygame.display.flip()\n' Python 3.6.5 code using Tkinter graphical user interface.'\nfrom tkinter import *\nimport math\n\nclass Animation:\n\n    def __init__(self, gw):\n        pass\n\n    def animate(self):\n        pass\nroot = Tk()\nroot.title('Pendulum')\nroot.geometry('600x400+100+50')\nroot.resizable(False, False)\na = Animation(root)\nroot.mainloop()", "original_code": "import pygame, sys\nfrom pygame.locals import *\nfrom math import sin, cos, radians\n\npygame.init()\n\nWINDOWSIZE = 250\nTIMETICK = 100\nBOBSIZE = 15\n\nwindow = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))\npygame.display.set_caption(\"Pendulum\")\n\nscreen = pygame.display.get_surface()\nscreen.fill((255,255,255))\n\nPIVOT = (WINDOWSIZE/2, WINDOWSIZE/10)\nSWINGLENGTH = PIVOT[1]*4\n\nclass BobMass(pygame.sprite.Sprite):\n    def __init__(self):\n        pygame.sprite.Sprite.__init__(self)\n        self.theta = 45\n        self.dtheta = 0\n        self.rect = pygame.Rect(PIVOT[0]-SWINGLENGTH*cos(radians(self.theta)),\n                                PIVOT[1]+SWINGLENGTH*sin(radians(self.theta)),\n                                1,1)\n        self.draw()\n\n    def recomputeAngle(self):\n        scaling = 3000.0/(SWINGLENGTH**2)\n\n        firstDDtheta = -sin(radians(self.theta))*scaling\n        midDtheta = self.dtheta + firstDDtheta\n        midtheta = self.theta + (self.dtheta + midDtheta)/2.0\n\n        midDDtheta = -sin(radians(midtheta))*scaling\n        midDtheta = self.dtheta + (firstDDtheta + midDDtheta)/2\n        midtheta = self.theta + (self.dtheta + midDtheta)/2\n\n        midDDtheta = -sin(radians(midtheta)) * scaling\n        lastDtheta = midDtheta + midDDtheta\n        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0\n        \n        lastDDtheta = -sin(radians(lasttheta)) * scaling\n        lastDtheta = midDtheta + (midDDtheta + lastDDtheta)/2.0\n        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0\n\n        self.dtheta = lastDtheta\n        self.theta = lasttheta\n        self.rect = pygame.Rect(PIVOT[0]-\n                                SWINGLENGTH*sin(radians(self.theta)), \n                                PIVOT[1]+\n                                SWINGLENGTH*cos(radians(self.theta)),1,1)\n\n\n    def draw(self):\n        pygame.draw.circle(screen, (0,0,0), PIVOT, 5, 0)\n        pygame.draw.circle(screen, (0,0,0), self.rect.center, BOBSIZE, 0)\n        pygame.draw.aaline(screen, (0,0,0), PIVOT, self.rect.center)\n        pygame.draw.line(screen, (0,0,0), (0, PIVOT[1]), (WINDOWSIZE, PIVOT[1]))\n\n    def update(self):\n        self.recomputeAngle()\n        screen.fill((255,255,255))\n        self.draw()\n\nbob = BobMass()\n\nTICK = USEREVENT + 2\npygame.time.set_timer(TICK, TIMETICK)\n\ndef input(events):\n    for event in events:\n        if event.type == QUIT:\n            sys.exit(0)\n        elif event.type == TICK:\n            bob.update()\n\nwhile True:\n    input(pygame.event.get())\n    pygame.display.flip()\n\n''' Python 3.6.5 code using Tkinter graphical user interface.''' \n\nfrom tkinter import *\nimport math\n\nclass Animation:\n    def __init__(self, gw):\n        self.window = gw\n        self.xoff, self.yoff = 300, 100\n        self.angle = 0\n        self.sina = math.sin(self.angle)\n        self.cosa = math.cos(self.angle)\n        self.rodhyp = 170\n        self.bobr = 30\n        self.bobhyp = self.rodhyp + self.bobr\n        self.rodx0, self.rody0 = self.xoff, self.yoff\n        self.ra = self.rodx0\n        self.rb = self.rody0\n        self.rc = self.xoff + self.rodhyp*self.sina\n        self.rd = self.yoff + self.rodhyp*self.cosa\n        self.ba = self.xoff - self.bobr + self.bobhyp*self.sina\n        self.bb = self.yoff - self.bobr + self.bobhyp*self.cosa\n        self.bc = self.xoff + self.bobr + self.bobhyp*self.sina\n        self.bd = self.yoff + self.bobr + self.bobhyp*self.cosa\n        self.da = math.pi / 360\n\n        # create / fill canvas:\n        self.cnv = Canvas(gw, bg='lemon chiffon')\n        self.cnv.pack(fill=BOTH, expand=True)\n\n        self.cnv.create_line(0, 100, 600, 100,\n                             fill='dodger blue',\n                             width=3)\n        radius = 8\n        self.cnv.create_oval(300-radius, 100-radius,\n                             300+radius, 100+radius,\n                             fill='navy')    \n\n        self.bob = self.cnv.create_oval(self.ba,\n                                        self.bb,\n                                        self.bc,\n                                        self.bd,\n                                        fill='red',\n                                        width=2)\n\n        self.rod = self.cnv.create_line(self.ra,\n                                        self.rb,\n                                        self.rc,\n                                        self.rd,\n                                        fill='dodger blue',\n                                        width=6)\n\n        self.animate()\n\n    def animate(self):\n        if abs(self.angle) > math.pi / 2:\n            self.da = - self.da\n        self.angle += self.da\n        self.sina = math.sin(self.angle)\n        self.cosa = math.cos(self.angle)\n        self.ra = self.rodx0\n        self.rb = self.rody0\n        self.rc = self.xoff + self.rodhyp*self.sina\n        self.rd = self.yoff + self.rodhyp*self.cosa\n        self.ba = self.xoff - self.bobr + self.bobhyp*self.sina\n        self.bb = self.yoff - self.bobr + self.bobhyp*self.cosa\n        self.bc = self.xoff + self.bobr + self.bobhyp*self.sina\n        self.bd = self.yoff + self.bobr + self.bobhyp*self.cosa\n        \n        self.cnv.coords(self.rod,\n                        self.ra,\n                        self.rb,\n                        self.rc,\n                        self.rd)\n        self.cnv.coords(self.bob,\n                        self.ba,\n                        self.bb,\n                        self.bc,\n                        self.bd)\n        self.window.update()\n        self.cnv.after(5, self.animate)\n         \nroot = Tk()\nroot.title('Pendulum')\nroot.geometry('600x400+100+50')\nroot.resizable(False, False)\na = Animation(root)\nroot.mainloop()\n\n", "perturbed_code": "\nWINDOWSIZE = 250\nTIMETICK = 100\nfrom pygame.locals import *\nfrom math import sin, cos, radians\nimport pygame, sys\npygame.init()\nBOBSIZE = 15\n\nclass BobMass(pygame.sprite.Sprite):\n\n    def __init__(self):\n        pygame.sprite.Sprite.__init__(self)\n        self.dtheta = 0\n        self.theta = 45\n        self.rect = pygame.Rect((PIVOT[0] - (cos(radians(self.theta)) * SWINGLENGTH)), (PIVOT[1] + (sin(radians(self.theta)) * SWINGLENGTH)), 1, 1)\n        self.draw()\n\n    def recomputeAngle(self):\n        scaling = (3000.0 / (SWINGLENGTH ** 2))\n        firstDDtheta = ((- sin(radians(self.theta))) * scaling)\n        midDtheta = (firstDDtheta + self.dtheta)\n        midtheta = (self.theta + ((midDtheta + self.dtheta) / 2.0))\n        midDDtheta = (scaling * (- sin(radians(midtheta))))\n        midDtheta = (((midDDtheta + firstDDtheta) / 2) + self.dtheta)\n        midtheta = (((self.dtheta + midDtheta) / 2) + self.theta)\n        midDDtheta = ((- sin(radians(midtheta))) * scaling)\n        lastDtheta = (midDDtheta + midDtheta)\n        lasttheta = (midtheta + ((midDtheta + lastDtheta) / 2.0))\n        lastDDtheta = ((- sin(radians(lasttheta))) * scaling)\n        lastDtheta = (midDtheta + ((lastDDtheta + midDDtheta) / 2.0))\n        self.dtheta = lastDtheta\n        lasttheta = (((lastDtheta + midDtheta) / 2.0) + midtheta)\n        self.theta = lasttheta\n        self.rect = pygame.Rect((PIVOT[0] - (SWINGLENGTH * sin(radians(self.theta)))), (PIVOT[1] + (SWINGLENGTH * cos(radians(self.theta)))), 1, 1)\n\n    def draw(self):\n        pygame.draw.circle(screen, (0, 0, 0), PIVOT, 5, 0)\n        pygame.draw.circle(screen, (0, 0, 0), self.rect.center, BOBSIZE, 0)\n        pygame.draw.aaline(screen, (0, 0, 0), PIVOT, self.rect.center)\n        pygame.draw.line(screen, (0, 0, 0), (0, PIVOT[1]), (WINDOWSIZE, PIVOT[1]))\n\n    def update(self):\n        screen.fill((255, 255, 255))\n        self.recomputeAngle()\n        self.draw()\nbob = BobMass()\nTICK = (2 + USEREVENT)\nwindow = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))\npygame.display.set_caption('Pendulum')\nscreen = pygame.display.get_surface()\nscreen.fill((255, 255, 255))\npygame.time.set_timer(TICK, TIMETICK)\nPIVOT = ((WINDOWSIZE / 2), (WINDOWSIZE / 10))\n\ndef input(events):\n    for event in events:\n        if (QUIT == event.type):\n            sys.exit(0)\n        elif (event.type == TICK):\n            bob.update()\nSWINGLENGTH = (4 * PIVOT[1])\nwhile True:\n    input(pygame.event.get())\n    pygame.display.flip()\n' Python 3.6.5 code using Tkinter graphical user interface.'\nfrom tkinter import *\nimport math\n\nclass Animation():\n\n    def __init__(self, gw):\n        self.window = gw\n        (self.xoff, self.yoff) = (300, 100)\n        self.angle = 0\n        self.sina = math.sin(self.angle)\n        self.cosa = math.cos(self.angle)\n        self.rodhyp = 170\n        self.bobr = 30\n        self.bobhyp = (self.rodhyp + self.bobr)\n        (self.rodx0, self.rody0) = (self.xoff, self.yoff)\n        self.ra = self.rodx0\n        self.rb = self.rody0\n        self.rc = ((self.sina * self.rodhyp) + self.xoff)\n        self.rd = (self.yoff + (self.cosa * self.rodhyp))\n        self.ba = ((self.xoff - self.bobr) + (self.bobhyp * self.sina))\n        self.bb = ((self.cosa * self.bobhyp) + (self.yoff - self.bobr))\n        self.bc = ((self.bobr + self.xoff) + (self.bobhyp * self.sina))\n        self.bd = ((self.yoff + self.bobr) + (self.cosa * self.bobhyp))\n        self.da = (math.pi / 360)\n        self.cnv = Canvas(gw, bg='lemon chiffon')\n        self.cnv.pack(fill=BOTH, expand=True)\n        self.cnv.create_line(0, 100, 600, 100, fill='dodger blue', width=3)\n        radius = 8\n        self.cnv.create_oval((300 - radius), (100 - radius), (300 + radius), (radius + 100), fill='navy')\n        self.bob = self.cnv.create_oval(self.ba, self.bb, self.bc, self.bd, fill='red', width=2)\n        self.rod = self.cnv.create_line(self.ra, self.rb, self.rc, self.rd, fill='dodger blue', width=6)\n        self.animate()\n\n    def animate(self):\n        if (abs(self.angle) > (math.pi / 2)):\n            self.da = (- self.da)\n        self.angle += self.da\n        self.sina = math.sin(self.angle)\n        self.cosa = math.cos(self.angle)\n        self.ra = self.rodx0\n        self.rb = self.rody0\n        self.rc = ((self.sina * self.rodhyp) + self.xoff)\n        self.rd = ((self.rodhyp * self.cosa) + self.yoff)\n        self.ba = ((self.sina * self.bobhyp) + (self.xoff - self.bobr))\n        self.bb = ((self.yoff - self.bobr) + (self.bobhyp * self.cosa))\n        self.bc = ((self.xoff + self.bobr) + (self.sina * self.bobhyp))\n        self.bd = ((self.cosa * self.bobhyp) + (self.yoff + self.bobr))\n        self.cnv.coords(self.rod, self.ra, self.rb, self.rc, self.rd)\n        self.cnv.coords(self.bob, self.ba, self.bb, self.bc, self.bd)\n        self.window.update()\n        self.cnv.after(5, self.animate)\nroot = Tk()\nroot.title('Pendulum')\nroot.geometry('600x400+100+50')\nroot.resizable(False, False)\na = Animation(root)\nroot.mainloop()\n", "incomplete_perturbed_code": "WINDOWSIZE = 250\nTIMETICK = 100\nfrom pygame.locals import *\nfrom math import sin, cos, radians\nimport pygame, sys\npygame.init()\nBOBSIZE = 15\n\nclass BobMass(pygame.sprite.Sprite):\n\n    def __init__(self):\n        pass\n\n    def recomputeAngle(self):\n        pass\n\n    def draw(self):\n        pass\n\n    def update(self):\n        pass\nbob = BobMass()\nTICK = 2 + USEREVENT\nwindow = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))\npygame.display.set_caption('Pendulum')\nscreen = pygame.display.get_surface()\nscreen.fill((255, 255, 255))\npygame.time.set_timer(TICK, TIMETICK)\nPIVOT = (WINDOWSIZE / 2, WINDOWSIZE / 10)\n\ndef input(events):\n    pass\nSWINGLENGTH = 4 * PIVOT[1]\nwhile True:\n    input(pygame.event.get())\n    pygame.display.flip()\n' Python 3.6.5 code using Tkinter graphical user interface.'\nfrom tkinter import *\nimport math\n\nclass Animation:\n\n    def __init__(self, gw):\n        pass\n\n    def animate(self):\n        pass\nroot = Tk()\nroot.title('Pendulum')\nroot.geometry('600x400+100+50')\nroot.resizable(False, False)\na = Animation(root)\nroot.mainloop()", "adversarial_score": 2, "original_score": 3, "search_time_seconds": 2472.2825458049774, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 100, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 100, "successful_llm_evaluations": 88, "failed_llm_evaluations": 12, "cache_hits_reordering_score": 0, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 100}, "adversarial_completion": "WINDOWSIZE = 250\nTIMETICK = 100\nfrom pygame.locals import *\nfrom math import sin, cos, radians\nimport pygame, sys\npygame.init()\nBOBSIZE = 15\n\nclass BobMass(pygame.sprite.Sprite):\n\n    def __init__(self):\n        pygame.sprite.Sprite.__init__(self)\n        self.x = WINDOWSIZE / 2\n        self.y = WINDOWSIZE / 10\n        self.angle = radians(45)\n        self.image = pygame.Surface((BOBSIZE, BOBSIZE))\n        self.image.fill((0, 0, 255))\n        self.rect = self.image.get_rect()\n        self.rect.center = (self.x, self.y)\n        self.length = 4 * (WINDOWSIZE / 10)\n        self.velocity = 0\n        self.gravity = 0.5\n\n    def recomputeAngle(self):\n        self.velocity += self.gravity * sin(self.angle)\n        self.angle += self.velocity\n        self.x = PIVOT[0] + self.length * cos(self.angle)\n        self.y = PIVOT[1] + self.length * sin(self.angle)\n        self.rect.center = (int(self.x), int(self.y))\n\n    def draw(self):\n        pygame.draw.line(screen, (0, 0, 0), PIVOT, self.rect.center, 2)\n\n    def update(self):\n        self.recomputeAngle()\n        self.draw()\n\nbob = BobMass()\nTICK = 2 + USEREVENT\nwindow = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))\npygame.display.set_caption('Pendulum')\nscreen = pygame.display.get_surface()\nscreen.fill((255, 255, 255))\npygame.time.set_timer(TICK, TIMETICK)\nPIVOT = (WINDOWSIZE / 2, WINDOWSIZE / 10)\n\ndef input(events):\n    for event in events:\n        if event.type == QUIT:\n            sys.exit()\n        if event.type == TICK:\n            bob.update()\n\nSWINGLENGTH = 4 * PIVOT[1]\nwhile True:\n    input(pygame.event.get())\n    pygame.display.flip()\n' Python 3.6.5 code using Tkinter graphical user interface.'\nfrom tkinter import *\nimport math\n\nclass Animation:\n\n    def __init__(self, gw):\n        self.gw = gw\n\n    def animate(self):\n        canvas = Canvas(self.gw, width=600, height=400, bg=\"white\")\n        canvas.pack()\n        pivot_x = 300\n        pivot_y = 50\n        length = 200\n        bob_x = pivot_x + length * math.cos(math.radians(45))\n        bob_y = pivot_y + length * math.sin(math.radians(45))\n        canvas.create_line(pivot_x, pivot_y, bob_x, bob_y, width=2)\n        canvas.create_oval(bob_x - 10, bob_y - 10, bob_x + 10, bob_y + 10, fill=\"blue\")\n        \n        angle = 45\n        for i in range(360):\n            angle += 1\n            bob_x = pivot_x + length * math.cos(math.radians(angle))\n            bob_y = pivot_y + length * math.sin(math.radians(angle))\n            canvas.create_line(pivot_x, pivot_y, bob_x, bob_y, width=2)\n            canvas.create_oval(bob_x - 10, bob_y - 10, bob_x + 10, bob_y + 10, fill=\"blue\")\n            self.gw.update()\n\nroot = Tk()\nroot.title('Pendulum')\nroot.geometry('600x400+100+50')\nroot.resizable(False, False)\na = Animation(root)\n#a.animate()\nroot.mainloop()", "score_distribution_all_attempts": [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2]}
{"lang_cluster": "Python", "source_code": "\n\n'''\n The 24 Game\n\n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and / operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n\n An answer of \"q\" will quit the game.\n An answer of \"!\" will generate a new set of four digits.\n Otherwise you are repeatedly asked for an expression until it evaluates to 24\n\n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n\n'''\n\nfrom __future__ import division, print_function\nimport random, ast, re\nimport sys\n\nif sys.version_info[0] < 3: input = raw_input\n\ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n\ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n\ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n\ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            print (\"New digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n\nif __name__ == '__main__': main()\n\n\n", "human_summarization": "generate and display four random digits from 1 to 9, prompt the player to form an arithmetic expression using these digits exactly once, and check if the expression evaluates to 24. The allowed operations are addition, subtraction, multiplication, and division with floating point or rational arithmetic. The program does not generate or test the validity of the expression.", "id": "4803", "incomplete_code": "\"\"\"\n The 24 Game\n\n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and / operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n\n An answer of \"q\" will quit the game.\n An answer of \"!\" will generate a new set of four digits.\n Otherwise you are repeatedly asked for an expression until it evaluates to 24\n\n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n\n\"\"\"\nfrom __future__ import division, print_function\nimport random, ast, re\nimport sys\nif sys.version_info[0] < 3:\n    input = raw_input\n\ndef choose4():\n    \"\"\"four random digits >0 as characters\"\"\"\n    pass\n\ndef welcome(digits):\n    pass\n\ndef check(answer, digits):\n    pass\n\ndef main():\n    pass\nif __name__ == '__main__':\n    main()", "original_code": "\n\n'''\n The 24 Game\n\n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and / operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n\n An answer of \"q\" will quit the game.\n An answer of \"!\" will generate a new set of four digits.\n Otherwise you are repeatedly asked for an expression until it evaluates to 24\n\n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n\n'''\n\nfrom __future__ import division, print_function\nimport random, ast, re\nimport sys\n\nif sys.version_info[0] < 3: input = raw_input\n\ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n\ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n\ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n\ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            print (\"New digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n\nif __name__ == '__main__': main()\n\n\n", "perturbed_code": "\n\ndef main():\n    trial = 0\n    while (not (chk and (ans == 24))):\n        if (not chk):\n            print((\"The input '%s' was wonky!\" % answer))\n        else:\n            if (24 == ans):\n                print('Thats right!')\n            ans = eval(answer)\n            print(' = ', ans)\n        if (answer == '!'):\n            continue\n            digits = choose4()\n            print('New digits:', ' '.join(digits))\n        if (answer.lower() == 'q'):\n            break\n        trial += 1\n        answer = input(('Expression %i: ' % trial))\n        chk = check(answer, digits)\n    chk = ans = False\n    digits = choose4()\n    welcome(digits)\n    answer = ''\n    print('Thank you and goodbye')\n\ndef welcome(digits):\n    print(__doc__)\n    print(('Your four digits: ' + ' '.join(digits)))\n'\\n The 24 Game\\n\\n Given any four digits in the range 1 to 9, which may have repetitions,\\n Using just the +, -, *, and / operators; and the possible use of\\n brackets, (), show how to make an answer of 24.\\n\\n An answer of \"q\" will quit the game.\\n An answer of \"!\" will generate a new set of four digits.\\n Otherwise you are repeatedly asked for an expression until it evaluates to 24\\n\\n Note: you cannot form multiple digit numbers from the supplied digits,\\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\\n\\n'\nimport random, ast, re\n\ndef check(answer, digits):\n    allowed = set((''.join(digits) + '() +-*/\\t'))\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    ok = (all(((ch in allowed) for ch in answer)) and all(((answer.count(dig) == digits.count(dig)) for dig in set(digits))) and (not re.search('\\\\d\\\\d', answer)))\n    return ok\nfrom __future__ import division, print_function\nimport sys\nif (sys.version_info[0] < 3):\n    input = raw_input\n\ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1, 9)) for i in range(4)]\nif (__name__ == '__main__'):\n    main()\n", "incomplete_perturbed_code": "def main():\n    pass\n\ndef welcome(digits):\n    pass\n'\\n The 24 Game\\n\\n Given any four digits in the range 1 to 9, which may have repetitions,\\n Using just the +, -, *, and / operators; and the possible use of\\n brackets, (), show how to make an answer of 24.\\n\\n An answer of \"q\" will quit the game.\\n An answer of \"!\" will generate a new set of four digits.\\n Otherwise you are repeatedly asked for an expression until it evaluates to 24\\n\\n Note: you cannot form multiple digit numbers from the supplied digits,\\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\\n\\n'\nimport random, ast, re\n\ndef check(answer, digits):\n    pass\nfrom __future__ import division, print_function\nimport sys\nif sys.version_info[0] < 3:\n    input = raw_input\n\ndef choose4():\n    \"\"\"four random digits >0 as characters\"\"\"\n    pass\nif __name__ == '__main__':\n    main()", "adversarial_score": 2, "original_score": 2, "search_time_seconds": 1292.9793107509613, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 100, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 100, "successful_llm_evaluations": 100, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 0, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 100}, "adversarial_completion": "def main():\n    while True:\n        digits = choose4()\n        welcome(digits)\n        while True:\n            answer = input(\"Enter an expression using the digits {}: \".format(digits))\n            if answer.lower() == 'q':\n                print(\"Quitting the game.\")\n                return\n            elif answer.lower() == '!':\n                break\n            else:\n                try:\n                    result = check(answer, digits)\n                    if result == 24:\n                        print(\"Congratulations! You made 24.\")\n                        break\n                    else:\n                        print(\"Incorrect. Try again.\")\n                except (SyntaxError, NameError, TypeError, ZeroDivisionError):\n                    print(\"Invalid expression. Try again.\")\n\ndef welcome(digits):\n    print('\\n The 24 Game\\n\\n Given any four digits in the range 1 to 9, which may have repetitions,\\n Using just the +, -, *, and / operators; and the possible use of\\n brackets, (), show how to make an answer of 24.\\n\\n An answer of \"q\" will quit the game.\\n An answer of \"!\" will generate a new set of four digits.\\n Otherwise you are repeatedly asked for an expression until it evaluates to 24\\n\\n Note: you cannot form multiple digit numbers from the supplied digits,\\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\\n\\n')\n    print(\"Digits: {}\".format(digits))\n\ndef check(answer, digits):\n    try:\n        expression = answer\n        for digit in digits:\n            expression = expression.replace(digit, digit)\n        \n        result = eval(expression)\n        return result\n    except (SyntaxError, NameError, TypeError, ZeroDivisionError):\n        raise\nfrom __future__ import division, print_function\nimport sys\nif sys.version_info[0] < 3:\n    input = raw_input\n\ndef choose4():\n    \"\"\"four random digits >0 as characters\"\"\"\n    digits = []\n    for _ in range(4):\n        digits.append(str(random.randint(1, 9)))\n    return digits\n\nif __name__ == '__main__':\n    main()", "score_distribution_all_attempts": [2, 3, 3, 3, 3, 3, 2, 3, 3, 3, 2, 3, 3, 3, 3, 2, 2, 3, 2, 3, 2, 2, 3, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 3, 3, 2, 2, 2, 3, 2, 2, 3, 2, 2, 3, 3, 2, 2, 2, 3, 3, 2, 2, 3, 2, 2, 2, 2, 2, 3, 2, 2, 3, 2, 3, 2, 2, 3, 2, 3, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 3, 2, 2, 2, 2, 3, 3, 3, 2, 2, 3, 3, 2, 3]}
{"lang_cluster": "Python", "source_code": "\ndef encode(input_string):\n    count = 1\n    prev = None\n    lst = []\n    for character in input_string:\n        if character != prev:\n            if prev:\n                entry = (prev, count)\n                lst.append(entry)\n            count = 1\n            prev = character\n        else:\n            count += 1\n    else:\n        try:\n            entry = (character, count)\n            lst.append(entry)\n            return (lst, 0)\n        except Exception as e:\n            print(\"Exception encountered {e}\".format(e=e)) \n            return (e, 1)\n \ndef decode(lst):\n    q = []\n    for character, count in lst:\n        q.append(character * count)\n    return ''.join(q)\n \n#Method call\nvalue = encode(\"aaaaahhhhhhmmmmmmmuiiiiiiiaaaaaa\")\nif value[1] == 0:\n    print(\"Encoded value is {}\".format(value[0]))\n    decode(value[0])\n\n\n# Works with: Python version 2.4\nfrom itertools import groupby\ndef encode(input_string):\n    return [(len(list(g)), k) for k,g in groupby(input_string)]\n\ndef decode(lst):\n    return ''.join(c * n for n,c in lst)\n\nencode(\"aaaaahhhhhhmmmmmmmuiiiiiiiaaaaaa\")\ndecode([(5, 'a'), (6, 'h'), (7, 'm'), (1, 'u'), (7, 'i'), (6, 'a')])\n\n\nfrom re import sub\n\ndef encode(text):\n    '''\n    Doctest:\n        >>> encode('WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW')\n        '12W1B12W3B24W1B14W'    \n    '''\n    return sub(r'(.)\\1*', lambda m: str(len(m.group(0))) + m.group(1),\n               text)\n\ndef decode(text):\n    '''\n    Doctest:\n        >>> decode('12W1B12W3B24W1B14W')\n        'WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW'\n    '''\n    return sub(r'(\\d+)(\\D)', lambda m: m.group(2) * int(m.group(1)),\n               text)\n\ntextin = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\nassert decode(encode(textin)) == textin\n\n", "human_summarization": "The code compresses a string of uppercase characters by encoding repeated sequences of the same character with the length of the sequence followed by the character. It also provides a function to reverse this compression. For example, the string \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\" is compressed to \"12W1B12W3B24W1B14W\". The code uses regular expressions for both encoding and decoding processes.", "id": "4804", "incomplete_code": "def encode(input_string):\n    pass\n\ndef decode(lst):\n    pass\nvalue = encode('aaaaahhhhhhmmmmmmmuiiiiiiiaaaaaa')\nif value[1] == 0:\n    print('Encoded value is {}'.format(value[0]))\n    decode(value[0])\nfrom itertools import groupby\n\ndef encode(input_string):\n    pass\n\ndef decode(lst):\n    pass\nencode('aaaaahhhhhhmmmmmmmuiiiiiiiaaaaaa')\ndecode([(5, 'a'), (6, 'h'), (7, 'm'), (1, 'u'), (7, 'i'), (6, 'a')])\nfrom re import sub\n\ndef encode(text):\n    \"\"\"\n    Doctest:\n        >>> encode('WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW')\n        '12W1B12W3B24W1B14W'    \n    \"\"\"\n    pass\n\ndef decode(text):\n    \"\"\"\n    Doctest:\n        >>> decode('12W1B12W3B24W1B14W')\n        'WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW'\n    \"\"\"\n    pass\ntextin = 'WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW'\nassert decode(encode(textin)) == textin", "original_code": "\ndef encode(input_string):\n    count = 1\n    prev = None\n    lst = []\n    for character in input_string:\n        if character != prev:\n            if prev:\n                entry = (prev, count)\n                lst.append(entry)\n            count = 1\n            prev = character\n        else:\n            count += 1\n    else:\n        try:\n            entry = (character, count)\n            lst.append(entry)\n            return (lst, 0)\n        except Exception as e:\n            print(\"Exception encountered {e}\".format(e=e)) \n            return (e, 1)\n \ndef decode(lst):\n    q = []\n    for character, count in lst:\n        q.append(character * count)\n    return ''.join(q)\n \n#Method call\nvalue = encode(\"aaaaahhhhhhmmmmmmmuiiiiiiiaaaaaa\")\nif value[1] == 0:\n    print(\"Encoded value is {}\".format(value[0]))\n    decode(value[0])\n\n\n# Works with: Python version 2.4\nfrom itertools import groupby\ndef encode(input_string):\n    return [(len(list(g)), k) for k,g in groupby(input_string)]\n\ndef decode(lst):\n    return ''.join(c * n for n,c in lst)\n\nencode(\"aaaaahhhhhhmmmmmmmuiiiiiiiaaaaaa\")\ndecode([(5, 'a'), (6, 'h'), (7, 'm'), (1, 'u'), (7, 'i'), (6, 'a')])\n\n\nfrom re import sub\n\ndef encode(text):\n    '''\n    Doctest:\n        >>> encode('WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW')\n        '12W1B12W3B24W1B14W'    \n    '''\n    return sub(r'(.)\\1*', lambda m: str(len(m.group(0))) + m.group(1),\n               text)\n\ndef decode(text):\n    '''\n    Doctest:\n        >>> decode('12W1B12W3B24W1B14W')\n        'WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW'\n    '''\n    return sub(r'(\\d+)(\\D)', lambda m: m.group(2) * int(m.group(1)),\n               text)\n\ntextin = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\nassert decode(encode(textin)) == textin\n\n", "perturbed_code": "\n\ndef encode(input_string):\n    for character in input_string:\n        if (character != prev):\n            if prev:\n                entry = (prev, count)\n                lst.append(entry)\n            count = 1\n            prev = character\n        else:\n            count += 1\n    else:\n        try:\n            entry = (character, count)\n            lst.append(entry)\n            return (lst, 0)\n        except Exception as e:\n            print('Exception encountered {e}'.format(e=e))\n            return (e, 1)\n    lst = []\n    prev = None\n    count = 1\n\ndef decode(lst):\n    for (character, count) in lst:\n        q.append((count * character))\n    q = []\n    return ''.join(q)\nvalue = encode('aaaaahhhhhhmmmmmmmuiiiiiiiaaaaaa')\nfrom itertools import groupby\n\ndef encode(input_string):\n    return [(len(list(g)), k) for (k, g) in groupby(input_string)]\n\ndef decode(lst):\n    return ''.join(((n * c) for (n, c) in lst))\nencode('aaaaahhhhhhmmmmmmmuiiiiiiiaaaaaa')\ndecode([(5, 'a'), (6, 'h'), (7, 'm'), (1, 'u'), (7, 'i'), (6, 'a')])\nfrom re import sub\n\ndef encode(text):\n    \"\\n    Doctest:\\n        >>> encode('WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW')\\n        '12W1B12W3B24W1B14W'    \\n    \"\n    return sub('(.)\\\\1*', (lambda m: (str(len(m.group(0))) + m.group(1))), text)\n\ndef decode(text):\n    \"\\n    Doctest:\\n        >>> decode('12W1B12W3B24W1B14W')\\n        'WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW'\\n    \"\n    return sub('(\\\\d+)(\\\\D)', (lambda m: (int(m.group(1)) * m.group(2))), text)\ntextin = 'WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW'\nif (0 == value[1]):\n    print('Encoded value is {}'.format(value[0]))\n    decode(value[0])\nassert (decode(encode(textin)) == textin)\n", "incomplete_perturbed_code": "def encode(input_string):\n    pass\n\ndef decode(lst):\n    pass\nvalue = encode('aaaaahhhhhhmmmmmmmuiiiiiiiaaaaaa')\nfrom itertools import groupby\n\ndef encode(input_string):\n    pass\n\ndef decode(lst):\n    pass\nencode('aaaaahhhhhhmmmmmmmuiiiiiiiaaaaaa')\ndecode([(5, 'a'), (6, 'h'), (7, 'm'), (1, 'u'), (7, 'i'), (6, 'a')])\nfrom re import sub\n\ndef encode(text):\n    \"\"\"\n    Doctest:\n        >>> encode('WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW')\n        '12W1B12W3B24W1B14W'    \n    \"\"\"\n    pass\n\ndef decode(text):\n    \"\"\"\n    Doctest:\n        >>> decode('12W1B12W3B24W1B14W')\n        'WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW'\n    \"\"\"\n    pass\ntextin = 'WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW'\nif 0 == value[1]:\n    print('Encoded value is {}'.format(value[0]))\n    decode(value[0])\nassert decode(encode(textin)) == textin", "adversarial_score": 3, "original_score": 2, "search_time_seconds": 344.42985105514526, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 84, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 86, "successful_llm_evaluations": 86, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 14, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 84}, "adversarial_completion": "from re import sub\nfrom itertools import groupby\n\ndef encode(text):\n    \"\"\"\n    Doctest:\n        >>> encode('WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW')\n        '12W1B12W3B24W1B14W'    \n    \"\"\"\n    return sub(r'(\\d+)(\\w)', r'\\1\\2', ''.join(str(len(list(group)))+k for k, group in groupby(text)))\n\ndef decode(lst):\n    \"\"\"\n    Doctest:\n        >>> decode('12W1B12W3B24W1B14W')\n        'WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW'\n    \"\"\"\n    result = ''\n    for num, char in lst:\n        result += char * num\n    return result\nvalue = encode('aaaaahhhhhhmmmmmmmuiiiiiiiaaaaaa')\nfrom itertools import groupby\n\ndef encode(input_string):\n    return sub(r'(\\d+)(\\w)', r'\\1\\2', ''.join(str(len(list(group)))+k for k, group in groupby(input_string)))\n\ndef decode(lst):\n    result = ''\n    for num, char in lst:\n        result += char * num\n    return result\nencode('aaaaahhhhhhmmmmmmmuiiiiiiiaaaaaa')\ndecode([(5, 'a'), (6, 'h'), (7, 'm'), (1, 'u'), (7, 'i'), (6, 'a')])\nfrom re import sub\n\ndef encode(text):\n    \"\"\"\n    Doctest:\n        >>> encode('WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW')\n        '12W1B12W3B24W1B14W'    \n    \"\"\"\n    return sub(r'(\\d+)(\\w)', r'\\1\\2', ''.join(str(len(list(group)))+k for k, group in groupby(text)))\n\ndef decode(text):\n    \"\"\"\n    Doctest:\n        >>> decode('12W1B12W3B24W1B14W')\n        'WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW'\n    \"\"\"\n    result = ''\n    for num, char in re.findall(r'(\\d+)(\\w)', text):\n        result += char * int(num)\n    return result\ntextin = 'WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW'\nif 0 == value[1]:\n    print('Encoded value is {}'.format(value[0]))\n    decode(value[0])\nassert decode(encode(textin)) == textin\nimport re", "score_distribution_all_attempts": [3, 4, 4, 3, 4, 3, 3, 4, 3, 3, 4, 3, 3, 4, 3, 4, 4, 3, 4, 4, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 4, 4, 3, 3, 3, 4, 3, 4, 3, 3, 3, 3, 3, 4, 4, 4, 3, 4, 4, 4, 3, 4, 3, 4, 3, 4, 3, 4, 4, 3, 4]}
{"lang_cluster": "Python", "source_code": "\n'''Common sorted list'''\n\nfrom itertools import chain\n\n\n# ------------------------- TEST -------------------------\n# main\u00a0:: IO ()\ndef main():\n    '''Sorted union of lists'''\n\n    print(\n        sorted(nub(concat([\n            [5, 1, 3, 8, 9, 4, 8, 7],\n            [3, 5, 9, 8, 4],\n            [1, 3, 7, 9]\n        ])))\n    )\n\n\n# ----------------------- GENERIC ------------------------\n\n# concat\u00a0:: [[a]] -> [a]\n# concat\u00a0:: [String] -> String\ndef concat(xs):\n    '''The concatenation of all the elements in a list.\n    '''\n    return list(chain(*xs))\n\n\n# nub\u00a0:: [a] -> [a]\ndef nub(xs):\n    '''A list containing the same elements as xs,\n       without duplicates, in the order of their\n       first occurrence.\n    '''\n    return list(dict.fromkeys(xs))\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\n\n", "human_summarization": "generates a common sorted list with unique elements from multiple integer arrays.", "id": "4807", "incomplete_code": "\"\"\"Common sorted list\"\"\"\nfrom itertools import chain\n\ndef main():\n    \"\"\"Sorted union of lists\"\"\"\n    pass\n\ndef concat(xs):\n    \"\"\"The concatenation of all the elements in a list.\n    \"\"\"\n    pass\n\ndef nub(xs):\n    \"\"\"A list containing the same elements as xs,\n       without duplicates, in the order of their\n       first occurrence.\n    \"\"\"\n    pass\nif __name__ == '__main__':\n    main()", "original_code": "\n'''Common sorted list'''\n\nfrom itertools import chain\n\n\n# ------------------------- TEST -------------------------\n# main\u00a0:: IO ()\ndef main():\n    '''Sorted union of lists'''\n\n    print(\n        sorted(nub(concat([\n            [5, 1, 3, 8, 9, 4, 8, 7],\n            [3, 5, 9, 8, 4],\n            [1, 3, 7, 9]\n        ])))\n    )\n\n\n# ----------------------- GENERIC ------------------------\n\n# concat\u00a0:: [[a]] -> [a]\n# concat\u00a0:: [String] -> String\ndef concat(xs):\n    '''The concatenation of all the elements in a list.\n    '''\n    return list(chain(*xs))\n\n\n# nub\u00a0:: [a] -> [a]\ndef nub(xs):\n    '''A list containing the same elements as xs,\n       without duplicates, in the order of their\n       first occurrence.\n    '''\n    return list(dict.fromkeys(xs))\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\n\n", "perturbed_code": "\nfrom itertools import chain\n\ndef main():\n    'Sorted union of lists'\n    print(sorted(nub(concat([[5, 1, 3, 8, 9, 4, 8, 7], [3, 5, 9, 8, 4], [1, 3, 7, 9]]))))\n'Common sorted list'\n\ndef nub(xs):\n    'A list containing the same elements as xs,\\n       without duplicates, in the order of their\\n       first occurrence.\\n    '\n    return list(dict.fromkeys(xs))\nif (__name__ == '__main__'):\n    main()\n\ndef concat(xs):\n    'The concatenation of all the elements in a list.\\n    '\n    return list(chain(*xs))\n", "incomplete_perturbed_code": "from itertools import chain\n\ndef main():\n    \"\"\"Sorted union of lists\"\"\"\n    pass\n'Common sorted list'\n\ndef nub(xs):\n    \"\"\"A list containing the same elements as xs,\n       without duplicates, in the order of their\n       first occurrence.\n    \"\"\"\n    pass\nif __name__ == '__main__':\n    main()\n\ndef concat(xs):\n    \"\"\"The concatenation of all the elements in a list.\n    \"\"\"\n    pass", "adversarial_score": 3, "original_score": 3, "search_time_seconds": 223.70672273635864, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 37, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 47, "successful_llm_evaluations": 47, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 53, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 37}, "adversarial_completion": "from itertools import chain\n\ndef main():\n    \"\"\"Sorted union of lists\"\"\"\n    arrays = [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\n    result = sorted(list(set(chain(*arrays))))\n    print(result)\n'Common sorted list'\n\ndef nub(xs):\n    \"\"\"A list containing the same elements as xs,\n       without duplicates, in the order of their\n       first occurrence.\n    \"\"\"\n    seen = set()\n    result = []\n    for x in xs:\n        if x not in seen:\n            seen.add(x)\n            result.append(x)\n    return result\nif __name__ == '__main__':\n    main()\n\ndef concat(xs):\n    \"\"\"The concatenation of all the elements in a list.\n    \"\"\"\n    result = []\n    for sublist in xs:\n        result.extend(sublist)\n    return result", "score_distribution_all_attempts": [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 4, 3, 4, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]}
{"lang_cluster": "Python", "source_code": "\n# Works with: Python version 3.7\nfrom functools import partial\nimport tkinter as tk\n\ndef on_click(label: tk.Label,\n             counter: tk.IntVar) -> None:\n    counter.set(counter.get() + 1)\n    label[\"text\"] = f\"Number of clicks: {counter.get()}\"\n\ndef main():\n    window = tk.Tk()\n    window.geometry(\"200x50+100+100\")\n    label = tk.Label(master=window,\n                     text=\"There have been no clicks yet\")\n    label.pack()\n    counter = tk.IntVar()\n    update_counter = partial(on_click,\n                             label=label,\n                             counter=counter)\n    button = tk.Button(master=window,\n                       text=\"click me\",\n                       command=update_counter)\n    button.pack()\n    window.mainloop()\n\nif __name__ == '__main__':\n    main()\n\n\nimport tkinter as tk\n\nclass ClickCounter(tk.Frame):\n    def __init__(self, master=None):\n        super().__init__(master)\n        tk.Pack.config(self)\n        self.label = tk.Label(self, text='There have been no clicks yet')\n        self.label.pack()\n        self.button = tk.Button(self,\n                                text='click me',\n                                command=self.click)\n        self.button.pack()\n        self.count = 0\n\n    def click(self):\n        self.count += 1\n        self.label['text'] = f'Number of clicks: {self.count}'\n\n\nif __name__ == \"__main__\":\n    ClickCounter().mainloop()\n\nfrom functools import partial\nfrom itertools import count\n\nfrom PyQt5.QtWidgets import (QApplication,\n                             QLabel,\n                             QPushButton,\n                             QWidget)\nfrom PyQt5.QtCore import QRect\n\nLABEL_GEOMETRY = QRect(0, 15, 200, 25)\nBUTTON_GEOMETRY = QRect(50, 50, 100, 25)\n\n\ndef on_click(_, label, counter=count(1)):\n    label.setText(f\"Number of clicks: {next(counter)}\")\n\n\ndef main():\n    application = QApplication([])\n    window = QWidget()\n    label = QLabel(text=\"There have been no clicks yet\",\n                   parent=window)\n    label.setGeometry(LABEL_GEOMETRY)\n    button = QPushButton(text=\"click me\",\n                         parent=window)\n    button.setGeometry(BUTTON_GEOMETRY)\n    update_counter = partial(on_click,\n                             label=label)\n    button.clicked.connect(update_counter)\n    window.show()\n    application.lastWindowClosed.connect(window.close)\n    application.exec_()\n\n\nif __name__ == '__main__':\n    main()\n\nimport wx\n\n\nclass ClickCounter(wx.Frame):\n    def __init__(self):\n        super().__init__(parent=None)\n        self.count = 0\n        self.button = wx.Button(parent=self,\n                                label=\"Click me!\")\n        self.label = wx.StaticText(parent=self,\n                                   label=\"There have been no clicks yet\")\n        self.Bind(event=wx.EVT_BUTTON,\n                  handler=self.click,\n                  source=self.button)\n\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(window=self.button,\n                       proportion=1,\n                       flag=wx.EXPAND)\n        self.sizer.Add(window=self.label,\n                       proportion=1,\n                       flag=wx.EXPAND)\n        self.SetSizer(self.sizer)\n        self.sizer.Fit(self)\n\n    def click(self, _):\n        self.count += 1\n        self.label.SetLabel(f\"Count: {self.count}\")\n\n\nif __name__ == '__main__':\n    app = wx.App()\n    frame = ClickCounter()\n    frame.Show()\n    app.MainLoop()\n\n", "human_summarization": "implement a windowed application with a label and a button. The label initially displays \"There have been no clicks yet\". When the button labeled \"click me\" is clicked, the label updates to show the number of times the button has been clicked.", "id": "4812", "incomplete_code": "from functools import partial\nimport tkinter as tk\n\ndef on_click(label: tk.Label, counter: tk.IntVar) -> None:\n    pass\n\ndef main():\n    pass\nif __name__ == '__main__':\n    main()\nimport tkinter as tk\n\nclass ClickCounter(tk.Frame):\n\n    def __init__(self, master=None):\n        pass\n\n    def click(self):\n        pass\nif __name__ == '__main__':\n    ClickCounter().mainloop()\nfrom functools import partial\nfrom itertools import count\nfrom PyQt5.QtWidgets import QApplication, QLabel, QPushButton, QWidget\nfrom PyQt5.QtCore import QRect\nLABEL_GEOMETRY = QRect(0, 15, 200, 25)\nBUTTON_GEOMETRY = QRect(50, 50, 100, 25)\n\ndef on_click(_, label, counter=count(1)):\n    pass\n\ndef main():\n    pass\nif __name__ == '__main__':\n    main()\nimport wx\n\nclass ClickCounter(wx.Frame):\n\n    def __init__(self):\n        pass\n\n    def click(self, _):\n        pass\nif __name__ == '__main__':\n    app = wx.App()\n    frame = ClickCounter()\n    frame.Show()\n    app.MainLoop()", "original_code": "\n# Works with: Python version 3.7\nfrom functools import partial\nimport tkinter as tk\n\ndef on_click(label: tk.Label,\n             counter: tk.IntVar) -> None:\n    counter.set(counter.get() + 1)\n    label[\"text\"] = f\"Number of clicks: {counter.get()}\"\n\ndef main():\n    window = tk.Tk()\n    window.geometry(\"200x50+100+100\")\n    label = tk.Label(master=window,\n                     text=\"There have been no clicks yet\")\n    label.pack()\n    counter = tk.IntVar()\n    update_counter = partial(on_click,\n                             label=label,\n                             counter=counter)\n    button = tk.Button(master=window,\n                       text=\"click me\",\n                       command=update_counter)\n    button.pack()\n    window.mainloop()\n\nif __name__ == '__main__':\n    main()\n\n\nimport tkinter as tk\n\nclass ClickCounter(tk.Frame):\n    def __init__(self, master=None):\n        super().__init__(master)\n        tk.Pack.config(self)\n        self.label = tk.Label(self, text='There have been no clicks yet')\n        self.label.pack()\n        self.button = tk.Button(self,\n                                text='click me',\n                                command=self.click)\n        self.button.pack()\n        self.count = 0\n\n    def click(self):\n        self.count += 1\n        self.label['text'] = f'Number of clicks: {self.count}'\n\n\nif __name__ == \"__main__\":\n    ClickCounter().mainloop()\n\nfrom functools import partial\nfrom itertools import count\n\nfrom PyQt5.QtWidgets import (QApplication,\n                             QLabel,\n                             QPushButton,\n                             QWidget)\nfrom PyQt5.QtCore import QRect\n\nLABEL_GEOMETRY = QRect(0, 15, 200, 25)\nBUTTON_GEOMETRY = QRect(50, 50, 100, 25)\n\n\ndef on_click(_, label, counter=count(1)):\n    label.setText(f\"Number of clicks: {next(counter)}\")\n\n\ndef main():\n    application = QApplication([])\n    window = QWidget()\n    label = QLabel(text=\"There have been no clicks yet\",\n                   parent=window)\n    label.setGeometry(LABEL_GEOMETRY)\n    button = QPushButton(text=\"click me\",\n                         parent=window)\n    button.setGeometry(BUTTON_GEOMETRY)\n    update_counter = partial(on_click,\n                             label=label)\n    button.clicked.connect(update_counter)\n    window.show()\n    application.lastWindowClosed.connect(window.close)\n    application.exec_()\n\n\nif __name__ == '__main__':\n    main()\n\nimport wx\n\n\nclass ClickCounter(wx.Frame):\n    def __init__(self):\n        super().__init__(parent=None)\n        self.count = 0\n        self.button = wx.Button(parent=self,\n                                label=\"Click me!\")\n        self.label = wx.StaticText(parent=self,\n                                   label=\"There have been no clicks yet\")\n        self.Bind(event=wx.EVT_BUTTON,\n                  handler=self.click,\n                  source=self.button)\n\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(window=self.button,\n                       proportion=1,\n                       flag=wx.EXPAND)\n        self.sizer.Add(window=self.label,\n                       proportion=1,\n                       flag=wx.EXPAND)\n        self.SetSizer(self.sizer)\n        self.sizer.Fit(self)\n\n    def click(self, _):\n        self.count += 1\n        self.label.SetLabel(f\"Count: {self.count}\")\n\n\nif __name__ == '__main__':\n    app = wx.App()\n    frame = ClickCounter()\n    frame.Show()\n    app.MainLoop()\n\n", "perturbed_code": "\n\nclass ClickCounter(tk.Frame):\n\n    def __init__(self, master=None):\n        super().__init__(master)\n        tk.Pack.config(self)\n        self.label = tk.Label(self, text='There have been no clicks yet')\n        self.label.pack()\n        self.button = tk.Button(self, text='click me', command=self.click)\n        self.button.pack()\n        self.count = 0\n\n    def click(self):\n        self.count += 1\n        self.label['text'] = f'Number of clicks: {self.count}'\nimport tkinter as tk\nfrom functools import partial\nif (__name__ == '__main__'):\n    main()\nif ('__main__' == __name__):\n    ClickCounter().mainloop()\nfrom functools import partial\nfrom itertools import count\nfrom PyQt5.QtWidgets import QApplication, QLabel, QPushButton, QWidget\n\ndef main():\n    window = tk.Tk()\n    window.geometry('200x50+100+100')\n    label = tk.Label(master=window, text='There have been no clicks yet')\n    label.pack()\n    counter = tk.IntVar()\n    update_counter = partial(on_click, label=label, counter=counter)\n    button = tk.Button(master=window, text='click me', command=update_counter)\n    window.mainloop()\n    button.pack()\nfrom PyQt5.QtCore import QRect\nLABEL_GEOMETRY = QRect(0, 15, 200, 25)\nBUTTON_GEOMETRY = QRect(50, 50, 100, 25)\nif (__name__ == '__main__'):\n    main()\nimport tkinter as tk\n\ndef on_click(label: tk.Label, counter: tk.IntVar) -> None:\n    counter.set((counter.get() + 1))\n    label['text'] = f'Number of clicks: {counter.get()}'\n\ndef on_click(_, label, counter=count(1)):\n    label.setText(f'Number of clicks: {next(counter)}')\n\ndef main():\n    application = QApplication([])\n    window = QWidget()\n    label = QLabel(text='There have been no clicks yet', parent=window)\n    label.setGeometry(LABEL_GEOMETRY)\n    button = QPushButton(text='click me', parent=window)\n    button.setGeometry(BUTTON_GEOMETRY)\n    update_counter = partial(on_click, label=label)\n    button.clicked.connect(update_counter)\n    window.show()\n    application.lastWindowClosed.connect(window.close)\n    application.exec_()\nimport wx\n\nclass ClickCounter(wx.Frame):\n\n    def __init__(self):\n        super().__init__(parent=None)\n        self.count = 0\n        self.button = wx.Button(parent=self, label='Click me!')\n        self.label = wx.StaticText(parent=self, label='There have been no clicks yet')\n        self.Bind(event=wx.EVT_BUTTON, handler=self.click, source=self.button)\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(window=self.button, proportion=1, flag=wx.EXPAND)\n        self.sizer.Add(window=self.label, proportion=1, flag=wx.EXPAND)\n        self.SetSizer(self.sizer)\n        self.sizer.Fit(self)\n\n    def click(self, _):\n        self.count += 1\n        self.label.SetLabel(f'Count: {self.count}')\nif (__name__ == '__main__'):\n    app = wx.App()\n    frame = ClickCounter()\n    frame.Show()\n    app.MainLoop()\n", "incomplete_perturbed_code": "class ClickCounter(tk.Frame):\n\n    def __init__(self, master=None):\n        pass\n\n    def click(self):\n        pass\nimport tkinter as tk\nfrom functools import partial\nif __name__ == '__main__':\n    main()\nif '__main__' == __name__:\n    ClickCounter().mainloop()\nfrom functools import partial\nfrom itertools import count\nfrom PyQt5.QtWidgets import QApplication, QLabel, QPushButton, QWidget\n\ndef main():\n    pass\nfrom PyQt5.QtCore import QRect\nLABEL_GEOMETRY = QRect(0, 15, 200, 25)\nBUTTON_GEOMETRY = QRect(50, 50, 100, 25)\nif __name__ == '__main__':\n    main()\nimport tkinter as tk\n\ndef on_click(label: tk.Label, counter: tk.IntVar) -> None:\n    pass\n\ndef on_click(_, label, counter=count(1)):\n    pass\n\ndef main():\n    pass\nimport wx\n\nclass ClickCounter(wx.Frame):\n\n    def __init__(self):\n        pass\n\n    def click(self, _):\n        pass\nif __name__ == '__main__':\n    app = wx.App()\n    frame = ClickCounter()\n    frame.Show()\n    app.MainLoop()", "adversarial_score": 3, "original_score": 4, "search_time_seconds": 1816.7881705760956, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 99, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 100, "successful_llm_evaluations": 100, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 0, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 99}, "adversarial_completion": "import tkinter as tk\nfrom functools import partial\nif __name__ == '__main__':\n    main()\nif '__main__' == __name__:\n    ClickCounter().mainloop()\nfrom functools import partial\nfrom itertools import count\nfrom PyQt5.QtWidgets import QApplication, QLabel, QPushButton, QWidget\n\ndef main():\n    app = QApplication([])\n    window = QWidget()\n    window.setGeometry(100, 100, 300, 200)\n    label = QLabel(\"There have been no clicks yet\", window)\n    label.setGeometry(*LABEL_GEOMETRY)\n    button = QPushButton(\"click me\", window)\n    button.setGeometry(*BUTTON_GEOMETRY)\n    counter = count(0)\n    button.clicked.connect(partial(update_label, label, counter))\n    window.show()\n    app.exec_()\n\nfrom PyQt5.QtCore import QRect\nLABEL_GEOMETRY = QRect(0, 15, 200, 25)\nBUTTON_GEOMETRY = QRect(50, 50, 100, 25)\n\ndef update_label(label: QLabel, counter):\n    label.setText(f\"Clicked {next(counter)} times\")\n\nimport tkinter as tk\n\ndef on_click(label: tk.Label, counter: tk.IntVar) -> None:\n    counter.set(counter.get() + 1)\n    label.config(text=f\"Clicked {counter.get()} times\")\n\ndef on_click(_, label, counter=count(1)):\n    pass\n\ndef main():\n    root = tk.Tk()\n    root.title(\"Click Counter\")\n    label = tk.Label(root, text=\"There have been no clicks yet\")\n    label.pack(pady=20)\n    counter = tk.IntVar()\n    counter.set(0)\n    button = tk.Button(root, text=\"click me\", command=lambda: on_click(label, counter))\n    button.pack(pady=10)\n    root.mainloop()\n\nimport wx\n\nclass ClickCounter(wx.Frame):\n\n    def __init__(self):\n        wx.Frame.__init__(self, None, wx.ID_ANY, \"Click Counter\")\n        self.counter = 0\n        self.label = wx.StaticText(self, wx.ID_ANY, \"There have been no clicks yet\", (50, 50))\n        self.button = wx.Button(self, wx.ID_ANY, \"click me\", (50, 100))\n        self.button.Bind(wx.EVT_BUTTON, self.click)\n\n    def click(self, _):\n        self.counter += 1\n        self.label.SetLabel(f\"Clicked {self.counter} times\")\n\nif __name__ == '__main__':\n    app = wx.App()\n    frame = ClickCounter()\n    frame.Show()\n    app.MainLoop()", "score_distribution_all_attempts": [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 4, 4, 4, 4, 3, 3, 4, 4, 4, 4, 4, 4, 3, 3, 4, 4, 4, 4, 3, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 4, 4, 4, 3, 4, 4, 4, 4, 3, 4, 3, 4, 4, 4, 4, 3, 4, 4, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]}
{"lang_cluster": "Python", "source_code": "\n# Works with: Python version 3'''Vigenere encryption and decryption'''\n\nfrom itertools import starmap, cycle\n\n\ndef encrypt(message, key):\n    '''Vigenere encryption of message using key.'''\n\n    # Converted to uppercase.\n    # Non-alpha characters stripped out.\n    message = filter(str.isalpha, message.upper())\n\n    def enc(c, k):\n        '''Single letter encryption.'''\n\n        return chr(((ord(k) + ord(c) - 2 * ord('A')) % 26) + ord('A'))\n\n    return ''.join(starmap(enc, zip(message, cycle(key))))\n\n\ndef decrypt(message, key):\n    '''Vigenere decryption of message using key.'''\n\n    def dec(c, k):\n        '''Single letter decryption.'''\n\n        return chr(((ord(c) - ord(k) - 2 * ord('A')) % 26) + ord('A'))\n\n    return ''.join(starmap(dec, zip(message, cycle(key))))\n\n\ndef main():\n    '''Demonstration'''\n\n    text = 'Beware the Jabberwock, my son! The jaws that bite, ' + (\n           'the claws that catch!'\n    )\n    key = 'VIGENERECIPHER'\n\n    encr = encrypt(text, key)\n    decr = decrypt(encr, key)\n\n    print(text)\n    print(encr)\n    print(decr)\n\n\nif __name__ == '__main__':\n    main()\n\n\n", "human_summarization": "Implement both encryption and decryption of a Vigen\u00e8re cipher. The codes handle keys and text of unequal length, capitalize all characters, and discard non-alphabetic characters. Any different handling of non-alphabetic characters is noted.", "id": "4814", "incomplete_code": "from itertools import starmap, cycle\n\ndef encrypt(message, key):\n    \"\"\"Vigenere encryption of message using key.\"\"\"\n    pass\n\ndef decrypt(message, key):\n    \"\"\"Vigenere decryption of message using key.\"\"\"\n    pass\n\ndef main():\n    \"\"\"Demonstration\"\"\"\n    pass\nif __name__ == '__main__':\n    main()", "original_code": "\n# Works with: Python version 3'''Vigenere encryption and decryption'''\n\nfrom itertools import starmap, cycle\n\n\ndef encrypt(message, key):\n    '''Vigenere encryption of message using key.'''\n\n    # Converted to uppercase.\n    # Non-alpha characters stripped out.\n    message = filter(str.isalpha, message.upper())\n\n    def enc(c, k):\n        '''Single letter encryption.'''\n\n        return chr(((ord(k) + ord(c) - 2 * ord('A')) % 26) + ord('A'))\n\n    return ''.join(starmap(enc, zip(message, cycle(key))))\n\n\ndef decrypt(message, key):\n    '''Vigenere decryption of message using key.'''\n\n    def dec(c, k):\n        '''Single letter decryption.'''\n\n        return chr(((ord(c) - ord(k) - 2 * ord('A')) % 26) + ord('A'))\n\n    return ''.join(starmap(dec, zip(message, cycle(key))))\n\n\ndef main():\n    '''Demonstration'''\n\n    text = 'Beware the Jabberwock, my son! The jaws that bite, ' + (\n           'the claws that catch!'\n    )\n    key = 'VIGENERECIPHER'\n\n    encr = encrypt(text, key)\n    decr = decrypt(encr, key)\n\n    print(text)\n    print(encr)\n    print(decr)\n\n\nif __name__ == '__main__':\n    main()\n\n\n", "perturbed_code": "\n\ndef main():\n    'Demonstration'\n    text = ('the claws that catch!' + 'Beware the Jabberwock, my son! The jaws that bite, ')\n    key = 'VIGENERECIPHER'\n    encr = encrypt(text, key)\n    print(text)\n    decr = decrypt(encr, key)\n    print(encr)\n    print(decr)\nfrom itertools import starmap, cycle\n\ndef decrypt(message, key):\n    'Vigenere decryption of message using key.'\n\n    def dec(c, k):\n        'Single letter decryption.'\n        return chr(((((ord(c) - ord(k)) - (ord('A') * 2)) % 26) + ord('A')))\n    return ''.join(starmap(dec, zip(message, cycle(key))))\n\ndef encrypt(message, key):\n    'Vigenere encryption of message using key.'\n    message = filter(str.isalpha, message.upper())\n\n    def enc(c, k):\n        'Single letter encryption.'\n        return chr(((((ord(k) + ord(c)) - (ord('A') * 2)) % 26) + ord('A')))\n    return ''.join(starmap(enc, zip(message, cycle(key))))\nif (__name__ == '__main__'):\n    main()\n", "incomplete_perturbed_code": "def main():\n    \"\"\"Demonstration\"\"\"\n    pass\nfrom itertools import starmap, cycle\n\ndef decrypt(message, key):\n    \"\"\"Vigenere decryption of message using key.\"\"\"\n    pass\n\ndef encrypt(message, key):\n    \"\"\"Vigenere encryption of message using key.\"\"\"\n    pass\nif __name__ == '__main__':\n    main()", "adversarial_score": 2, "original_score": 3, "search_time_seconds": 541.1507172584534, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 99, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 100, "successful_llm_evaluations": 100, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 0, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 99}, "adversarial_completion": "def main():\n    \"\"\"Demonstration\"\"\"\n    message = \"This is a secret message.\"\n    key = \"KEY\"\n    encrypted_message = encrypt(message, key)\n    decrypted_message = decrypt(encrypted_message, key)\n    print(f\"Original message: {message}\")\n    print(f\"Encrypted message: {encrypted_message}\")\n    print(f\"Decrypted message: {decrypted_message}\")\nfrom itertools import starmap, cycle\n\ndef decrypt(message, key):\n    \"\"\"Vigenere decryption of message using key.\"\"\"\n    key_cycle = cycle(key.upper())\n    decrypted_text = \"\".join(\n        chr(((ord(char) - ord(next(key_cycle)) + 26) % 26) + ord('A'))\n        if 'A' <= char <= 'Z' or 'a' <= char <= 'z'\n        else char\n        for char in message\n    )\n    return decrypted_text\n\ndef encrypt(message, key):\n    \"\"\"Vigenere encryption of message using key.\"\"\"\n    key_cycle = cycle(key.upper())\n    encrypted_text = \"\".join(\n        chr(((ord(char) - ord(next(key_cycle)) + 26) % 26) + ord('A'))\n        if 'A' <= char <= 'Z' or 'a' <= char <= 'z'\n        else char\n        for char in message\n    )\n    return encrypted_text\nif __name__ == '__main__':\n    main()", "score_distribution_all_attempts": [3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 3, 3, 3, 3, 2, 3, 3, 2, 2, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3]}
{"lang_cluster": "Python", "source_code": "\nfrom random import shuffle, randrange\n\ndef make_maze(w = 16, h = 8):\n    vis = [[0] * w + [1] for _ in range(h)] + [[1] * (w + 1)]\n    ver = [[\"|  \"] * w + ['|'] for _ in range(h)] + [[]]\n    hor = [[\"+--\"] * w + ['+'] for _ in range(h + 1)]\n\n    def walk(x, y):\n        vis[y][x] = 1\n\n        d = [(x - 1, y), (x, y + 1), (x + 1, y), (x, y - 1)]\n        shuffle(d)\n        for (xx, yy) in d:\n            if vis[yy][xx]: continue\n            if xx == x: hor[max(y, yy)][x] = \"+  \"\n            if yy == y: ver[y][max(x, xx)] = \"   \"\n            walk(xx, yy)\n\n    walk(randrange(w), randrange(h))\n\n    s = \"\"\n    for (a, b) in zip(hor, ver):\n        s += ''.join(a + ['\\n'] + b + ['\\n'])\n    return s\n\nif __name__ == '__main__':\n    print(make_maze())\n\n\n", "human_summarization": "generate and display a maze using the Depth-first search algorithm. It starts from a random cell, marks it as visited, and gets a list of its neighbors. For each unvisited neighbor, it removes the wall between the current cell and the neighbor, and then recursively continues the process with the neighbor as the current cell.", "id": "4818", "incomplete_code": "from random import shuffle, randrange\n\ndef make_maze(w=16, h=8):\n    pass\nif __name__ == '__main__':\n    print(make_maze())", "original_code": "\nfrom random import shuffle, randrange\n\ndef make_maze(w = 16, h = 8):\n    vis = [[0] * w + [1] for _ in range(h)] + [[1] * (w + 1)]\n    ver = [[\"|  \"] * w + ['|'] for _ in range(h)] + [[]]\n    hor = [[\"+--\"] * w + ['+'] for _ in range(h + 1)]\n\n    def walk(x, y):\n        vis[y][x] = 1\n\n        d = [(x - 1, y), (x, y + 1), (x + 1, y), (x, y - 1)]\n        shuffle(d)\n        for (xx, yy) in d:\n            if vis[yy][xx]: continue\n            if xx == x: hor[max(y, yy)][x] = \"+  \"\n            if yy == y: ver[y][max(x, xx)] = \"   \"\n            walk(xx, yy)\n\n    walk(randrange(w), randrange(h))\n\n    s = \"\"\n    for (a, b) in zip(hor, ver):\n        s += ''.join(a + ['\\n'] + b + ['\\n'])\n    return s\n\nif __name__ == '__main__':\n    print(make_maze())\n\n\n", "perturbed_code": "\nfrom random import shuffle, randrange\n\ndef make_maze(w=16, h=8):\n    vis = ([([1] * (1 + w))] + [([1] + ([0] * w)) for _ in range(h)])\n    ver = ([(['|'] + (['|  '] * w)) for _ in range(h)] + [[]])\n    hor = [((['+--'] * w) + ['+']) for _ in range((1 + h))]\n\n    def walk(x, y):\n        vis[y][x] = 1\n        for (xx, yy) in d:\n            if (y == yy):\n                ver[y][max(x, xx)] = '   '\n            if (x == xx):\n                hor[max(y, yy)][x] = '+  '\n            if vis[yy][xx]:\n                continue\n            walk(xx, yy)\n        d = [((x - 1), y), (x, (y + 1)), ((x + 1), y), (x, (y - 1))]\n        shuffle(d)\n    walk(randrange(w), randrange(h))\n    for (a, b) in zip(hor, ver):\n        s += ''.join(((b + (['\\n'] + a)) + ['\\n']))\n    s = ''\n    return s\nif ('__main__' == __name__):\n    print(make_maze())\n", "incomplete_perturbed_code": "from random import shuffle, randrange\n\ndef make_maze(w=16, h=8):\n    pass\nif '__main__' == __name__:\n    print(make_maze())", "adversarial_score": 2, "original_score": 2, "search_time_seconds": 75.64587593078613, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 100, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 100, "successful_llm_evaluations": 100, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 0, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 100}, "adversarial_completion": "from random import shuffle, randrange\n\ndef make_maze(w=16, h=8):\n    \"\"\"Generates a maze using Depth-first search.\"\"\"\n    maze = [['#' for _ in range(2 * w + 1)] for _ in range(2 * h + 1)]\n\n    def carve(x, y):\n        maze[y][x] = ' '\n        directions = [(0, 2), (2, 0), (0, -2), (-2, 0)]\n        shuffle(directions)\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 < nx < 2 * w and 0 < ny < 2 * h and maze[ny][nx] == '#':\n                maze[y + dy // 2][x + dx // 2] = ' '\n                carve(nx, ny)\n\n    start_x = randrange(1, 2 * w, 2)\n    start_y = randrange(1, 2 * h, 2)\n    carve(start_x, start_y)\n\n    return '\\n'.join([''.join(row) for row in maze])\nif '__main__' == __name__:\n    print(make_maze())", "score_distribution_all_attempts": [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 3, 3, 3, 3, 3, 2, 2, 3, 3, 2, 3, 2, 3, 3, 3, 3, 2, 2, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 3, 3, 3, 2, 2, 2, 3, 3, 2, 3, 3, 2, 3, 3, 3, 2, 3, 3, 2, 2, 3, 2, 2, 3, 2, 3]}
{"lang_cluster": "Python", "source_code": "\nfrom itertools import combinations\n\ndef anycomb(items):\n    ' return combinations of any length from the items '\n    return ( comb\n             for r in range(1, len(items)+1)\n             for comb in combinations(items, r)\n             )\n\ndef totalvalue(comb):\n    ' Totalise a particular combination of items'\n    totwt = totval = 0\n    for item, wt, val in comb:\n        totwt  += wt\n        totval += val\n    return (totval, -totwt) if totwt <= 400 else (0, 0)\n\nitems = (\n    (\"map\", 9, 150), (\"compass\", 13, 35), (\"water\", 153, 200), (\"sandwich\", 50, 160),\n    (\"glucose\", 15, 60), (\"tin\", 68, 45), (\"banana\", 27, 60), (\"apple\", 39, 40),\n    (\"cheese\", 23, 30), (\"beer\", 52, 10), (\"suntan cream\", 11, 70), (\"camera\", 32, 30),\n    (\"t-shirt\", 24, 15), (\"trousers\", 48, 10), (\"umbrella\", 73, 40),\n    (\"waterproof trousers\", 42, 70), (\"waterproof overclothes\", 43, 75),\n    (\"note-case\", 22, 80), (\"sunglasses\", 7, 20), (\"towel\", 18, 12),\n    (\"socks\", 4, 50), (\"book\", 30, 10),\n    )\nbagged = max( anycomb(items), key=totalvalue) # max val or min wt if values equal\nprint(\"Bagged the following items\\n  \" +\n      '\\n  '.join(sorted(item for item,_,_ in bagged)))\nval, wt = totalvalue(bagged)\nprint(\"for a total value of %i and a total weight of %i\" % (val, -wt))\n\n\n", "human_summarization": "The code determines the optimal combination of items a tourist can carry in his knapsack, given a maximum weight limit of 4kg (or 400 dag). It considers the weight and value of each item, ensuring the total weight does not exceed the limit and the total value is maximized. The code uses the 0-1 Knapsack problem approach, reducing the number of comparisons from N! to 2^N. It does not allow for cutting or diminishing the items.", "id": "4825", "incomplete_code": "from itertools import combinations\n\ndef anycomb(items):\n    \"\"\" return combinations of any length from the items \"\"\"\n    pass\n\ndef totalvalue(comb):\n    \"\"\" Totalise a particular combination of items\"\"\"\n    pass\nitems = (('map', 9, 150), ('compass', 13, 35), ('water', 153, 200), ('sandwich', 50, 160), ('glucose', 15, 60), ('tin', 68, 45), ('banana', 27, 60), ('apple', 39, 40), ('cheese', 23, 30), ('beer', 52, 10), ('suntan cream', 11, 70), ('camera', 32, 30), ('t-shirt', 24, 15), ('trousers', 48, 10), ('umbrella', 73, 40), ('waterproof trousers', 42, 70), ('waterproof overclothes', 43, 75), ('note-case', 22, 80), ('sunglasses', 7, 20), ('towel', 18, 12), ('socks', 4, 50), ('book', 30, 10))\nbagged = max(anycomb(items), key=totalvalue)\nprint('Bagged the following items\\n  ' + '\\n  '.join(sorted((item for item, _, _ in bagged))))\nval, wt = totalvalue(bagged)\nprint('for a total value of %i and a total weight of %i' % (val, -wt))", "original_code": "\nfrom itertools import combinations\n\ndef anycomb(items):\n    ' return combinations of any length from the items '\n    return ( comb\n             for r in range(1, len(items)+1)\n             for comb in combinations(items, r)\n             )\n\ndef totalvalue(comb):\n    ' Totalise a particular combination of items'\n    totwt = totval = 0\n    for item, wt, val in comb:\n        totwt  += wt\n        totval += val\n    return (totval, -totwt) if totwt <= 400 else (0, 0)\n\nitems = (\n    (\"map\", 9, 150), (\"compass\", 13, 35), (\"water\", 153, 200), (\"sandwich\", 50, 160),\n    (\"glucose\", 15, 60), (\"tin\", 68, 45), (\"banana\", 27, 60), (\"apple\", 39, 40),\n    (\"cheese\", 23, 30), (\"beer\", 52, 10), (\"suntan cream\", 11, 70), (\"camera\", 32, 30),\n    (\"t-shirt\", 24, 15), (\"trousers\", 48, 10), (\"umbrella\", 73, 40),\n    (\"waterproof trousers\", 42, 70), (\"waterproof overclothes\", 43, 75),\n    (\"note-case\", 22, 80), (\"sunglasses\", 7, 20), (\"towel\", 18, 12),\n    (\"socks\", 4, 50), (\"book\", 30, 10),\n    )\nbagged = max( anycomb(items), key=totalvalue) # max val or min wt if values equal\nprint(\"Bagged the following items\\n  \" +\n      '\\n  '.join(sorted(item for item,_,_ in bagged)))\nval, wt = totalvalue(bagged)\nprint(\"for a total value of %i and a total weight of %i\" % (val, -wt))\n\n\n", "perturbed_code": "\n\ndef totalvalue(comb):\n    ' Totalise a particular combination of items'\n    for (item, wt, val) in comb:\n        totwt += wt\n        totval += val\n    totwt = totval = 0\n    return ((totval, (- totwt)) if (totwt <= 400) else (0, 0))\nfrom itertools import combinations\n\ndef anycomb(items):\n    ' return combinations of any length from the items '\n    return (comb for r in range(1, (len(items) + 1)) for comb in combinations(items, r))\nitems = (('map', 9, 150), ('compass', 13, 35), ('water', 153, 200), ('sandwich', 50, 160), ('glucose', 15, 60), ('tin', 68, 45), ('banana', 27, 60), ('apple', 39, 40), ('cheese', 23, 30), ('beer', 52, 10), ('suntan cream', 11, 70), ('camera', 32, 30), ('t-shirt', 24, 15), ('trousers', 48, 10), ('umbrella', 73, 40), ('waterproof trousers', 42, 70), ('waterproof overclothes', 43, 75), ('note-case', 22, 80), ('sunglasses', 7, 20), ('towel', 18, 12), ('socks', 4, 50), ('book', 30, 10))\nprint(('for a total value of %i and a total weight of %i' % (val, (- wt))))\nbagged = max(anycomb(items), key=totalvalue)\nprint(('Bagged the following items\\n  ' + '\\n  '.join(sorted((item for (item, _, _) in bagged)))))\n(val, wt) = totalvalue(bagged)\n", "incomplete_perturbed_code": "def totalvalue(comb):\n    \"\"\" Totalise a particular combination of items\"\"\"\n    pass\nfrom itertools import combinations\n\ndef anycomb(items):\n    \"\"\" return combinations of any length from the items \"\"\"\n    pass\nitems = (('map', 9, 150), ('compass', 13, 35), ('water', 153, 200), ('sandwich', 50, 160), ('glucose', 15, 60), ('tin', 68, 45), ('banana', 27, 60), ('apple', 39, 40), ('cheese', 23, 30), ('beer', 52, 10), ('suntan cream', 11, 70), ('camera', 32, 30), ('t-shirt', 24, 15), ('trousers', 48, 10), ('umbrella', 73, 40), ('waterproof trousers', 42, 70), ('waterproof overclothes', 43, 75), ('note-case', 22, 80), ('sunglasses', 7, 20), ('towel', 18, 12), ('socks', 4, 50), ('book', 30, 10))\nprint('for a total value of %i and a total weight of %i' % (val, -wt))\nbagged = max(anycomb(items), key=totalvalue)\nprint('Bagged the following items\\n  ' + '\\n  '.join(sorted((item for item, _, _ in bagged))))\nval, wt = totalvalue(bagged)", "adversarial_score": 2, "original_score": 4, "search_time_seconds": 230.36180877685547, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 12, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 22, "successful_llm_evaluations": 22, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 78, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 12}, "adversarial_completion": "def totalvalue(comb):\n    \"\"\" Totalise a particular combination of items\"\"\"\n    total_value = 0\n    for item, value, _ in comb:\n        total_value += value\n    return total_value\nfrom itertools import combinations\n\ndef anycomb(items):\n    \"\"\" return combinations of any length from the items \"\"\"\n    all_combs = []\n    for i in range(len(items) + 1):\n        for comb in combinations(items, i):\n            all_combs.append(comb)\n    return all_combs\nitems = (('map', 9, 150), ('compass', 13, 35), ('water', 153, 200), ('sandwich', 50, 160), ('glucose', 15, 60), ('tin', 68, 45), ('banana', 27, 60), ('apple', 39, 40), ('cheese', 23, 30), ('beer', 52, 10), ('suntan cream', 11, 70), ('camera', 32, 30), ('t-shirt', 24, 15), ('trousers', 48, 10), ('umbrella', 73, 40), ('waterproof trousers', 42, 70), ('waterproof overclothes', 43, 75), ('note-case', 22, 80), ('sunglasses', 7, 20), ('towel', 18, 12), ('socks', 4, 50), ('book', 30, 10))\nbagged = max(anycomb(items), key=lambda comb: totalvalue(comb) if sum(w for _, w, _ in comb) <= 400 else -1)\nval, wt = 0, 0\nfor item, weight, value in bagged:\n    wt += weight\n    val += value\nprint('for a total value of %i and a total weight of %i' % (val, wt))\nprint('Bagged the following items\\n  ' + '\\n  '.join(sorted((item for item, _, _ in bagged))))", "score_distribution_all_attempts": [3, 3, 2, 2, 2, 3, 3, 3, 2, 4, 2, 3, 3, 3, 4, 3, 3, 3, 4, 4, 3, 3, 3, 2, 3, 2, 3, 3, 2, 2, 3, 3, 2, 2, 2, 3, 3, 3, 2, 3, 3, 3, 2, 3, 2, 2, 3, 2, 2, 3, 4, 3, 2, 2, 3, 4, 3, 3, 3, 4, 2, 2, 3, 2, 3, 2, 3, 3, 3, 2, 3, 3, 2, 3, 3, 3, 3, 3, 3, 2, 2, 3, 4, 2, 4, 3, 3, 2, 3, 3, 3, 4, 3, 3, 3, 2, 4, 2, 2, 2]}
{"lang_cluster": "Python", "source_code": "\nimport copy\n\nguyprefers = {\n 'abe':  ['abi', 'eve', 'cath', 'ivy', 'jan', 'dee', 'fay', 'bea', 'hope', 'gay'],\n 'bob':  ['cath', 'hope', 'abi', 'dee', 'eve', 'fay', 'bea', 'jan', 'ivy', 'gay'],\n 'col':  ['hope', 'eve', 'abi', 'dee', 'bea', 'fay', 'ivy', 'gay', 'cath', 'jan'],\n 'dan':  ['ivy', 'fay', 'dee', 'gay', 'hope', 'eve', 'jan', 'bea', 'cath', 'abi'],\n 'ed':   ['jan', 'dee', 'bea', 'cath', 'fay', 'eve', 'abi', 'ivy', 'hope', 'gay'],\n 'fred': ['bea', 'abi', 'dee', 'gay', 'eve', 'ivy', 'cath', 'jan', 'hope', 'fay'],\n 'gav':  ['gay', 'eve', 'ivy', 'bea', 'cath', 'abi', 'dee', 'hope', 'jan', 'fay'],\n 'hal':  ['abi', 'eve', 'hope', 'fay', 'ivy', 'cath', 'jan', 'bea', 'gay', 'dee'],\n 'ian':  ['hope', 'cath', 'dee', 'gay', 'bea', 'abi', 'fay', 'ivy', 'jan', 'eve'],\n 'jon':  ['abi', 'fay', 'jan', 'gay', 'eve', 'bea', 'dee', 'cath', 'ivy', 'hope']}\ngalprefers = {\n 'abi':  ['bob', 'fred', 'jon', 'gav', 'ian', 'abe', 'dan', 'ed', 'col', 'hal'],\n 'bea':  ['bob', 'abe', 'col', 'fred', 'gav', 'dan', 'ian', 'ed', 'jon', 'hal'],\n 'cath': ['fred', 'bob', 'ed', 'gav', 'hal', 'col', 'ian', 'abe', 'dan', 'jon'],\n 'dee':  ['fred', 'jon', 'col', 'abe', 'ian', 'hal', 'gav', 'dan', 'bob', 'ed'],\n 'eve':  ['jon', 'hal', 'fred', 'dan', 'abe', 'gav', 'col', 'ed', 'ian', 'bob'],\n 'fay':  ['bob', 'abe', 'ed', 'ian', 'jon', 'dan', 'fred', 'gav', 'col', 'hal'],\n 'gay':  ['jon', 'gav', 'hal', 'fred', 'bob', 'abe', 'col', 'ed', 'dan', 'ian'],\n 'hope': ['gav', 'jon', 'bob', 'abe', 'ian', 'dan', 'hal', 'ed', 'col', 'fred'],\n 'ivy':  ['ian', 'col', 'hal', 'gav', 'fred', 'bob', 'abe', 'ed', 'jon', 'dan'],\n 'jan':  ['ed', 'hal', 'gav', 'abe', 'bob', 'jon', 'col', 'ian', 'fred', 'dan']}\n\nguys = sorted(guyprefers.keys())\ngals = sorted(galprefers.keys())\n\n\ndef check(engaged):\n    inverseengaged = dict((v,k) for k,v in engaged.items())\n    for she, he in engaged.items():\n        shelikes = galprefers[she]\n        shelikesbetter = shelikes[:shelikes.index(he)]\n        helikes = guyprefers[he]\n        helikesbetter = helikes[:helikes.index(she)]\n        for guy in shelikesbetter:\n            guysgirl = inverseengaged[guy]\n            guylikes = guyprefers[guy]\n            if guylikes.index(guysgirl) > guylikes.index(she):\n                print(\"%s and %s like each other better than \"\n                      \"their present partners: %s and %s, respectively\"\n                      % (she, guy, he, guysgirl))\n                return False\n        for gal in helikesbetter:\n            girlsguy = engaged[gal]\n            gallikes = galprefers[gal]\n            if gallikes.index(girlsguy) > gallikes.index(he):\n                print(\"%s and %s like each other better than \"\n                      \"their present partners: %s and %s, respectively\"\n                      % (he, gal, she, girlsguy))\n                return False\n    return True\n\ndef matchmaker():\n    guysfree = guys[:]\n    engaged  = {}\n    guyprefers2 = copy.deepcopy(guyprefers)\n    galprefers2 = copy.deepcopy(galprefers)\n    while guysfree:\n        guy = guysfree.pop(0)\n        guyslist = guyprefers2[guy]\n        gal = guyslist.pop(0)\n        fiance = engaged.get(gal)\n        if not fiance:\n            # She's free\n            engaged[gal] = guy\n            print(\"  %s and %s\" % (guy, gal))\n        else:\n            # The bounder proposes to an engaged lass!\n            galslist = galprefers2[gal]\n            if galslist.index(fiance) > galslist.index(guy):\n                # She prefers new guy\n                engaged[gal] = guy\n                print(\"  %s dumped %s for %s\" % (gal, fiance, guy))\n                if guyprefers2[fiance]:\n                    # Ex has more girls to try\n                    guysfree.append(fiance)\n            else:\n                # She is faithful to old fiance\n                if guyslist:\n                    # Look again\n                    guysfree.append(guy)\n    return engaged\n\n\nprint('\\nEngagements:')\nengaged = matchmaker()\n\nprint('\\nCouples:')\nprint('  ' + ',\\n  '.join('%s is engaged to %s' % couple\n                          for couple in sorted(engaged.items())))\nprint()\nprint('Engagement stability check PASSED'\n      if check(engaged) else 'Engagement stability check FAILED')\n\nprint('\\n\\nSwapping two fiances to introduce an error')\nengaged[gals[0]], engaged[gals[1]] = engaged[gals[1]], engaged[gals[0]]\nfor gal in gals[:2]:\n    print('  %s is now engaged to %s' % (gal, engaged[gal]))\nprint()\nprint('Engagement stability check PASSED'\n      if check(engaged) else 'Engagement stability check FAILED')\n\n\n", "human_summarization": "\"Implement the Gale-Shapley algorithm to solve the Stable Marriage problem. The program takes as input the preferences of ten men and ten women, and outputs a stable set of engagements. It then perturbs this set to form an unstable set of engagements and checks this new set for stability.\"", "id": "4826", "incomplete_code": "import copy\nguyprefers = {'abe': ['abi', 'eve', 'cath', 'ivy', 'jan', 'dee', 'fay', 'bea', 'hope', 'gay'], 'bob': ['cath', 'hope', 'abi', 'dee', 'eve', 'fay', 'bea', 'jan', 'ivy', 'gay'], 'col': ['hope', 'eve', 'abi', 'dee', 'bea', 'fay', 'ivy', 'gay', 'cath', 'jan'], 'dan': ['ivy', 'fay', 'dee', 'gay', 'hope', 'eve', 'jan', 'bea', 'cath', 'abi'], 'ed': ['jan', 'dee', 'bea', 'cath', 'fay', 'eve', 'abi', 'ivy', 'hope', 'gay'], 'fred': ['bea', 'abi', 'dee', 'gay', 'eve', 'ivy', 'cath', 'jan', 'hope', 'fay'], 'gav': ['gay', 'eve', 'ivy', 'bea', 'cath', 'abi', 'dee', 'hope', 'jan', 'fay'], 'hal': ['abi', 'eve', 'hope', 'fay', 'ivy', 'cath', 'jan', 'bea', 'gay', 'dee'], 'ian': ['hope', 'cath', 'dee', 'gay', 'bea', 'abi', 'fay', 'ivy', 'jan', 'eve'], 'jon': ['abi', 'fay', 'jan', 'gay', 'eve', 'bea', 'dee', 'cath', 'ivy', 'hope']}\ngalprefers = {'abi': ['bob', 'fred', 'jon', 'gav', 'ian', 'abe', 'dan', 'ed', 'col', 'hal'], 'bea': ['bob', 'abe', 'col', 'fred', 'gav', 'dan', 'ian', 'ed', 'jon', 'hal'], 'cath': ['fred', 'bob', 'ed', 'gav', 'hal', 'col', 'ian', 'abe', 'dan', 'jon'], 'dee': ['fred', 'jon', 'col', 'abe', 'ian', 'hal', 'gav', 'dan', 'bob', 'ed'], 'eve': ['jon', 'hal', 'fred', 'dan', 'abe', 'gav', 'col', 'ed', 'ian', 'bob'], 'fay': ['bob', 'abe', 'ed', 'ian', 'jon', 'dan', 'fred', 'gav', 'col', 'hal'], 'gay': ['jon', 'gav', 'hal', 'fred', 'bob', 'abe', 'col', 'ed', 'dan', 'ian'], 'hope': ['gav', 'jon', 'bob', 'abe', 'ian', 'dan', 'hal', 'ed', 'col', 'fred'], 'ivy': ['ian', 'col', 'hal', 'gav', 'fred', 'bob', 'abe', 'ed', 'jon', 'dan'], 'jan': ['ed', 'hal', 'gav', 'abe', 'bob', 'jon', 'col', 'ian', 'fred', 'dan']}\nguys = sorted(guyprefers.keys())\ngals = sorted(galprefers.keys())\n\ndef check(engaged):\n    pass\n\ndef matchmaker():\n    pass\nprint('\\nEngagements:')\nengaged = matchmaker()\nprint('\\nCouples:')\nprint('  ' + ',\\n  '.join(('%s is engaged to %s' % couple for couple in sorted(engaged.items()))))\nprint()\nprint('Engagement stability check PASSED' if check(engaged) else 'Engagement stability check FAILED')\nprint('\\n\\nSwapping two fiances to introduce an error')\nengaged[gals[0]], engaged[gals[1]] = (engaged[gals[1]], engaged[gals[0]])\nfor gal in gals[:2]:\n    print('  %s is now engaged to %s' % (gal, engaged[gal]))\nprint()\nprint('Engagement stability check PASSED' if check(engaged) else 'Engagement stability check FAILED')", "original_code": "\nimport copy\n\nguyprefers = {\n 'abe':  ['abi', 'eve', 'cath', 'ivy', 'jan', 'dee', 'fay', 'bea', 'hope', 'gay'],\n 'bob':  ['cath', 'hope', 'abi', 'dee', 'eve', 'fay', 'bea', 'jan', 'ivy', 'gay'],\n 'col':  ['hope', 'eve', 'abi', 'dee', 'bea', 'fay', 'ivy', 'gay', 'cath', 'jan'],\n 'dan':  ['ivy', 'fay', 'dee', 'gay', 'hope', 'eve', 'jan', 'bea', 'cath', 'abi'],\n 'ed':   ['jan', 'dee', 'bea', 'cath', 'fay', 'eve', 'abi', 'ivy', 'hope', 'gay'],\n 'fred': ['bea', 'abi', 'dee', 'gay', 'eve', 'ivy', 'cath', 'jan', 'hope', 'fay'],\n 'gav':  ['gay', 'eve', 'ivy', 'bea', 'cath', 'abi', 'dee', 'hope', 'jan', 'fay'],\n 'hal':  ['abi', 'eve', 'hope', 'fay', 'ivy', 'cath', 'jan', 'bea', 'gay', 'dee'],\n 'ian':  ['hope', 'cath', 'dee', 'gay', 'bea', 'abi', 'fay', 'ivy', 'jan', 'eve'],\n 'jon':  ['abi', 'fay', 'jan', 'gay', 'eve', 'bea', 'dee', 'cath', 'ivy', 'hope']}\ngalprefers = {\n 'abi':  ['bob', 'fred', 'jon', 'gav', 'ian', 'abe', 'dan', 'ed', 'col', 'hal'],\n 'bea':  ['bob', 'abe', 'col', 'fred', 'gav', 'dan', 'ian', 'ed', 'jon', 'hal'],\n 'cath': ['fred', 'bob', 'ed', 'gav', 'hal', 'col', 'ian', 'abe', 'dan', 'jon'],\n 'dee':  ['fred', 'jon', 'col', 'abe', 'ian', 'hal', 'gav', 'dan', 'bob', 'ed'],\n 'eve':  ['jon', 'hal', 'fred', 'dan', 'abe', 'gav', 'col', 'ed', 'ian', 'bob'],\n 'fay':  ['bob', 'abe', 'ed', 'ian', 'jon', 'dan', 'fred', 'gav', 'col', 'hal'],\n 'gay':  ['jon', 'gav', 'hal', 'fred', 'bob', 'abe', 'col', 'ed', 'dan', 'ian'],\n 'hope': ['gav', 'jon', 'bob', 'abe', 'ian', 'dan', 'hal', 'ed', 'col', 'fred'],\n 'ivy':  ['ian', 'col', 'hal', 'gav', 'fred', 'bob', 'abe', 'ed', 'jon', 'dan'],\n 'jan':  ['ed', 'hal', 'gav', 'abe', 'bob', 'jon', 'col', 'ian', 'fred', 'dan']}\n\nguys = sorted(guyprefers.keys())\ngals = sorted(galprefers.keys())\n\n\ndef check(engaged):\n    inverseengaged = dict((v,k) for k,v in engaged.items())\n    for she, he in engaged.items():\n        shelikes = galprefers[she]\n        shelikesbetter = shelikes[:shelikes.index(he)]\n        helikes = guyprefers[he]\n        helikesbetter = helikes[:helikes.index(she)]\n        for guy in shelikesbetter:\n            guysgirl = inverseengaged[guy]\n            guylikes = guyprefers[guy]\n            if guylikes.index(guysgirl) > guylikes.index(she):\n                print(\"%s and %s like each other better than \"\n                      \"their present partners: %s and %s, respectively\"\n                      % (she, guy, he, guysgirl))\n                return False\n        for gal in helikesbetter:\n            girlsguy = engaged[gal]\n            gallikes = galprefers[gal]\n            if gallikes.index(girlsguy) > gallikes.index(he):\n                print(\"%s and %s like each other better than \"\n                      \"their present partners: %s and %s, respectively\"\n                      % (he, gal, she, girlsguy))\n                return False\n    return True\n\ndef matchmaker():\n    guysfree = guys[:]\n    engaged  = {}\n    guyprefers2 = copy.deepcopy(guyprefers)\n    galprefers2 = copy.deepcopy(galprefers)\n    while guysfree:\n        guy = guysfree.pop(0)\n        guyslist = guyprefers2[guy]\n        gal = guyslist.pop(0)\n        fiance = engaged.get(gal)\n        if not fiance:\n            # She's free\n            engaged[gal] = guy\n            print(\"  %s and %s\" % (guy, gal))\n        else:\n            # The bounder proposes to an engaged lass!\n            galslist = galprefers2[gal]\n            if galslist.index(fiance) > galslist.index(guy):\n                # She prefers new guy\n                engaged[gal] = guy\n                print(\"  %s dumped %s for %s\" % (gal, fiance, guy))\n                if guyprefers2[fiance]:\n                    # Ex has more girls to try\n                    guysfree.append(fiance)\n            else:\n                # She is faithful to old fiance\n                if guyslist:\n                    # Look again\n                    guysfree.append(guy)\n    return engaged\n\n\nprint('\\nEngagements:')\nengaged = matchmaker()\n\nprint('\\nCouples:')\nprint('  ' + ',\\n  '.join('%s is engaged to %s' % couple\n                          for couple in sorted(engaged.items())))\nprint()\nprint('Engagement stability check PASSED'\n      if check(engaged) else 'Engagement stability check FAILED')\n\nprint('\\n\\nSwapping two fiances to introduce an error')\nengaged[gals[0]], engaged[gals[1]] = engaged[gals[1]], engaged[gals[0]]\nfor gal in gals[:2]:\n    print('  %s is now engaged to %s' % (gal, engaged[gal]))\nprint()\nprint('Engagement stability check PASSED'\n      if check(engaged) else 'Engagement stability check FAILED')\n\n\n", "perturbed_code": "\nimport copy\nguyprefers = {'abe': ['abi', 'eve', 'cath', 'ivy', 'jan', 'dee', 'fay', 'bea', 'hope', 'gay'], 'bob': ['cath', 'hope', 'abi', 'dee', 'eve', 'fay', 'bea', 'jan', 'ivy', 'gay'], 'col': ['hope', 'eve', 'abi', 'dee', 'bea', 'fay', 'ivy', 'gay', 'cath', 'jan'], 'dan': ['ivy', 'fay', 'dee', 'gay', 'hope', 'eve', 'jan', 'bea', 'cath', 'abi'], 'ed': ['jan', 'dee', 'bea', 'cath', 'fay', 'eve', 'abi', 'ivy', 'hope', 'gay'], 'fred': ['bea', 'abi', 'dee', 'gay', 'eve', 'ivy', 'cath', 'jan', 'hope', 'fay'], 'gav': ['gay', 'eve', 'ivy', 'bea', 'cath', 'abi', 'dee', 'hope', 'jan', 'fay'], 'hal': ['abi', 'eve', 'hope', 'fay', 'ivy', 'cath', 'jan', 'bea', 'gay', 'dee'], 'ian': ['hope', 'cath', 'dee', 'gay', 'bea', 'abi', 'fay', 'ivy', 'jan', 'eve'], 'jon': ['abi', 'fay', 'jan', 'gay', 'eve', 'bea', 'dee', 'cath', 'ivy', 'hope']}\ngalprefers = {'abi': ['bob', 'fred', 'jon', 'gav', 'ian', 'abe', 'dan', 'ed', 'col', 'hal'], 'bea': ['bob', 'abe', 'col', 'fred', 'gav', 'dan', 'ian', 'ed', 'jon', 'hal'], 'cath': ['fred', 'bob', 'ed', 'gav', 'hal', 'col', 'ian', 'abe', 'dan', 'jon'], 'dee': ['fred', 'jon', 'col', 'abe', 'ian', 'hal', 'gav', 'dan', 'bob', 'ed'], 'eve': ['jon', 'hal', 'fred', 'dan', 'abe', 'gav', 'col', 'ed', 'ian', 'bob'], 'fay': ['bob', 'abe', 'ed', 'ian', 'jon', 'dan', 'fred', 'gav', 'col', 'hal'], 'gay': ['jon', 'gav', 'hal', 'fred', 'bob', 'abe', 'col', 'ed', 'dan', 'ian'], 'hope': ['gav', 'jon', 'bob', 'abe', 'ian', 'dan', 'hal', 'ed', 'col', 'fred'], 'ivy': ['ian', 'col', 'hal', 'gav', 'fred', 'bob', 'abe', 'ed', 'jon', 'dan'], 'jan': ['ed', 'hal', 'gav', 'abe', 'bob', 'jon', 'col', 'ian', 'fred', 'dan']}\n\ndef check(engaged):\n    for (she, he) in engaged.items():\n        for gal in helikesbetter:\n            if (gallikes.index(girlsguy) > gallikes.index(he)):\n                print(('%s and %s like each other better than their present partners: %s and %s, respectively' % (he, gal, she, girlsguy)))\n                return False\n            girlsguy = engaged[gal]\n            gallikes = galprefers[gal]\n        for guy in shelikesbetter:\n            if (guylikes.index(guysgirl) > guylikes.index(she)):\n                print(('%s and %s like each other better than their present partners: %s and %s, respectively' % (she, guy, he, guysgirl)))\n                return False\n            guysgirl = inverseengaged[guy]\n            guylikes = guyprefers[guy]\n        shelikes = galprefers[she]\n        shelikesbetter = shelikes[:shelikes.index(he)]\n        helikes = guyprefers[he]\n        helikesbetter = helikes[:helikes.index(she)]\n    return True\n    inverseengaged = dict(((v, k) for (k, v) in engaged.items()))\n\ndef matchmaker():\n    while guysfree:\n        if (not fiance):\n            engaged[gal] = guy\n            print(('  %s and %s' % (guy, gal)))\n        else:\n            if (galslist.index(fiance) > galslist.index(guy)):\n                if guyprefers2[fiance]:\n                    guysfree.append(fiance)\n                engaged[gal] = guy\n                print(('  %s dumped %s for %s' % (gal, fiance, guy)))\n            elif guyslist:\n                guysfree.append(guy)\n            galslist = galprefers2[gal]\n        guy = guysfree.pop(0)\n        guyslist = guyprefers2[guy]\n        gal = guyslist.pop(0)\n        fiance = engaged.get(gal)\n    guysfree = guys[:]\n    engaged = {}\n    guyprefers2 = copy.deepcopy(guyprefers)\n    galprefers2 = copy.deepcopy(galprefers)\n    return engaged\nprint('\\nEngagements:')\nprint('\\nCouples:')\nprint()\nprint('\\n\\nSwapping two fiances to introduce an error')\nprint()\nguys = sorted(guyprefers.keys())\ngals = sorted(galprefers.keys())\nengaged = matchmaker()\nprint(('  ' + ',\\n  '.join((('%s is engaged to %s' % couple) for couple in sorted(engaged.items())))))\nfor gal in gals[:2]:\n    print(('  %s is now engaged to %s' % (gal, engaged[gal])))\nprint(('Engagement stability check PASSED' if check(engaged) else 'Engagement stability check FAILED'))\n(engaged[gals[0]], engaged[gals[1]]) = (engaged[gals[1]], engaged[gals[0]])\nprint(('Engagement stability check PASSED' if check(engaged) else 'Engagement stability check FAILED'))\n", "incomplete_perturbed_code": "import copy\nguyprefers = {'abe': ['abi', 'eve', 'cath', 'ivy', 'jan', 'dee', 'fay', 'bea', 'hope', 'gay'], 'bob': ['cath', 'hope', 'abi', 'dee', 'eve', 'fay', 'bea', 'jan', 'ivy', 'gay'], 'col': ['hope', 'eve', 'abi', 'dee', 'bea', 'fay', 'ivy', 'gay', 'cath', 'jan'], 'dan': ['ivy', 'fay', 'dee', 'gay', 'hope', 'eve', 'jan', 'bea', 'cath', 'abi'], 'ed': ['jan', 'dee', 'bea', 'cath', 'fay', 'eve', 'abi', 'ivy', 'hope', 'gay'], 'fred': ['bea', 'abi', 'dee', 'gay', 'eve', 'ivy', 'cath', 'jan', 'hope', 'fay'], 'gav': ['gay', 'eve', 'ivy', 'bea', 'cath', 'abi', 'dee', 'hope', 'jan', 'fay'], 'hal': ['abi', 'eve', 'hope', 'fay', 'ivy', 'cath', 'jan', 'bea', 'gay', 'dee'], 'ian': ['hope', 'cath', 'dee', 'gay', 'bea', 'abi', 'fay', 'ivy', 'jan', 'eve'], 'jon': ['abi', 'fay', 'jan', 'gay', 'eve', 'bea', 'dee', 'cath', 'ivy', 'hope']}\ngalprefers = {'abi': ['bob', 'fred', 'jon', 'gav', 'ian', 'abe', 'dan', 'ed', 'col', 'hal'], 'bea': ['bob', 'abe', 'col', 'fred', 'gav', 'dan', 'ian', 'ed', 'jon', 'hal'], 'cath': ['fred', 'bob', 'ed', 'gav', 'hal', 'col', 'ian', 'abe', 'dan', 'jon'], 'dee': ['fred', 'jon', 'col', 'abe', 'ian', 'hal', 'gav', 'dan', 'bob', 'ed'], 'eve': ['jon', 'hal', 'fred', 'dan', 'abe', 'gav', 'col', 'ed', 'ian', 'bob'], 'fay': ['bob', 'abe', 'ed', 'ian', 'jon', 'dan', 'fred', 'gav', 'col', 'hal'], 'gay': ['jon', 'gav', 'hal', 'fred', 'bob', 'abe', 'col', 'ed', 'dan', 'ian'], 'hope': ['gav', 'jon', 'bob', 'abe', 'ian', 'dan', 'hal', 'ed', 'col', 'fred'], 'ivy': ['ian', 'col', 'hal', 'gav', 'fred', 'bob', 'abe', 'ed', 'jon', 'dan'], 'jan': ['ed', 'hal', 'gav', 'abe', 'bob', 'jon', 'col', 'ian', 'fred', 'dan']}\n\ndef check(engaged):\n    pass\n\ndef matchmaker():\n    pass\nprint('\\nEngagements:')\nprint('\\nCouples:')\nprint()\nprint('\\n\\nSwapping two fiances to introduce an error')\nprint()\nguys = sorted(guyprefers.keys())\ngals = sorted(galprefers.keys())\nengaged = matchmaker()\nprint('  ' + ',\\n  '.join(('%s is engaged to %s' % couple for couple in sorted(engaged.items()))))\nfor gal in gals[:2]:\n    print('  %s is now engaged to %s' % (gal, engaged[gal]))\nprint('Engagement stability check PASSED' if check(engaged) else 'Engagement stability check FAILED')\nengaged[gals[0]], engaged[gals[1]] = (engaged[gals[1]], engaged[gals[0]])\nprint('Engagement stability check PASSED' if check(engaged) else 'Engagement stability check FAILED')", "adversarial_score": 3, "original_score": 4, "search_time_seconds": 592.8717660903931, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 4, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 20, "successful_llm_evaluations": 20, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 80, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 4}, "adversarial_completion": "import copy\n\nguyprefers = {'abe': ['abi', 'eve', 'cath', 'ivy', 'jan', 'dee', 'fay', 'bea', 'hope', 'gay'], 'bob': ['cath', 'hope', 'abi', 'dee', 'eve', 'fay', 'bea', 'jan', 'ivy', 'gay'], 'col': ['hope', 'eve', 'abi', 'dee', 'bea', 'fay', 'ivy', 'gay', 'cath', 'jan'], 'dan': ['ivy', 'fay', 'dee', 'gay', 'hope', 'eve', 'jan', 'bea', 'cath', 'abi'], 'ed': ['jan', 'dee', 'bea', 'cath', 'fay', 'eve', 'abi', 'ivy', 'hope', 'gay'], 'fred': ['bea', 'abi', 'dee', 'gay', 'eve', 'ivy', 'cath', 'jan', 'hope', 'fay'], 'gav': ['gay', 'eve', 'ivy', 'bea', 'cath', 'abi', 'dee', 'hope', 'jan', 'fay'], 'hal': ['abi', 'eve', 'hope', 'fay', 'ivy', 'cath', 'jan', 'bea', 'gay', 'dee'], 'ian': ['hope', 'cath', 'dee', 'gay', 'bea', 'abi', 'fay', 'ivy', 'jan', 'eve'], 'jon': ['abi', 'fay', 'jan', 'gay', 'eve', 'bea', 'dee', 'cath', 'ivy', 'hope']}\ngalprefers = {'abi': ['bob', 'fred', 'jon', 'gav', 'ian', 'abe', 'dan', 'ed', 'col', 'hal'], 'bea': ['bob', 'abe', 'col', 'fred', 'gav', 'dan', 'ian', 'ed', 'jon', 'hal'], 'cath': ['fred', 'bob', 'ed', 'gav', 'hal', 'col', 'ian', 'abe', 'dan', 'jon'], 'dee': ['fred', 'jon', 'col', 'abe', 'ian', 'hal', 'gav', 'dan', 'bob', 'ed'], 'eve': ['jon', 'hal', 'fred', 'dan', 'abe', 'gav', 'col', 'ed', 'ian', 'bob'], 'fay': ['bob', 'abe', 'ed', 'ian', 'jon', 'dan', 'fred', 'gav', 'col', 'hal'], 'gay': ['jon', 'gav', 'hal', 'fred', 'bob', 'abe', 'col', 'ed', 'dan', 'ian'], 'hope': ['gav', 'jon', 'bob', 'abe', 'ian', 'dan', 'hal', 'ed', 'col', 'fred'], 'ivy': ['ian', 'col', 'hal', 'gav', 'fred', 'bob', 'abe', 'ed', 'jon', 'dan'], 'jan': ['ed', 'hal', 'gav', 'abe', 'bob', 'jon', 'col', 'ian', 'fred', 'dan']}\n\ndef check(engaged):\n    for guy, gal in engaged.items():\n        for preferred_gal in guyprefers[guy]:\n            if preferred_gal == gal:\n                break\n            other_guy = None\n            for g, g_gal in engaged.items():\n                if g_gal == preferred_gal:\n                    other_guy = g\n                    break\n            if other_guy is not None and galprefers[preferred_gal].index(guy) < galprefers[preferred_gal].index(other_guy):\n                return False\n    return True\n\ndef matchmaker():\n    guys = sorted(guyprefers.keys())\n    gals = sorted(galprefers.keys())\n    engaged = {}\n    guy_available = {guy: True for guy in guys}\n    gal_engaged_to = {gal: None for gal in gals}\n\n    while any(guy_available.values()):\n        guy = next(guy for guy, available in guy_available.items() if available)\n        for gal in guyprefers[guy]:\n            if gal_engaged_to[gal] is None:\n                engaged[gal] = guy\n                gal_engaged_to[gal] = guy\n                guy_available[guy] = False\n                break\n            else:\n                current_guy = gal_engaged_to[gal]\n                if galprefers[gal].index(guy) < galprefers[gal].index(current_guy):\n                    engaged[gal] = guy\n                    gal_engaged_to[gal] = guy\n                    guy_available[guy] = False\n                    guy_available[current_guy] = True\n                    break\n    return engaged\nprint('\\nEngagements:')\nprint('\\nCouples:')\nprint()\nprint('\\n\\nSwapping two fiances to introduce an error')\nprint()\nguys = sorted(guyprefers.keys())\ngals = sorted(galprefers.keys())\nengaged = matchmaker()\nprint('  ' + ',\\n  '.join(('%s is engaged to %s' % couple for couple in sorted(engaged.items()))))\nfor gal in gals[:2]:\n    print('  %s is now engaged to %s' % (gal, engaged[gal]))\nprint('Engagement stability check PASSED' if check(engaged) else 'Engagement stability check FAILED')\nengaged[gals[0]], engaged[gals[1]] = (engaged[gals[1]], engaged[gals[0]])\nprint('Engagement stability check PASSED' if check(engaged) else 'Engagement stability check FAILED')", "score_distribution_all_attempts": [3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 4, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 4, 3, 4, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4]}
{"lang_cluster": "Python", "source_code": "\nimport time, winsound #, sys\n\nchar2morse = {          \n          \"!\": \"---.\",      \"\\\"\": \".-..-.\",     \"$\": \"...-..-\",    \"'\": \".----.\",  \n          \"(\": \"-.--.\",      \")\": \"-.--.-\",     \"+\": \".-.-.\",      \",\": \"--..--\", \n          \"-\": \"-....-\",     \".\": \".-.-.-\",     \"/\": \"-..-.\", \n          \"0\": \"-----\",      \"1\": \".----\",      \"2\": \"..---\",      \"3\": \"...--\", \n          \"4\": \"....-\",      \"5\": \".....\",      \"6\": \"-....\",      \"7\": \"--...\", \n          \"8\": \"---..\",      \"9\": \"----.\", \n          \":\": \"---...\",     \";\": \"-.-.-.\",     \"=\": \"-...-\",      \"?\": \"..--..\", \n          \"@\": \".--.-.\", \n          \"A\": \".-\",         \"B\": \"-...\",       \"C\": \"-.-.\",       \"D\": \"-..\", \n          \"E\": \".\",          \"F\": \"..-.\",       \"G\": \"--.\",        \"H\": \"....\", \n          \"I\": \"..\",         \"J\": \".---\",       \"K\": \"-.-\",        \"L\": \".-..\", \n          \"M\": \"--\",         \"N\": \"-.\",         \"O\": \"---\",        \"P\": \".--.\", \n          \"Q\": \"--.-\",       \"R\": \".-.\",        \"S\": \"...\",        \"T\": \"-\", \n          \"U\": \"..-\",        \"V\": \"...-\",       \"W\": \".--\",        \"X\": \"-..-\", \n          \"Y\": \"-.--\",       \"Z\": \"--..\", \n          \"[\": \"-.--.\",      \"]\": \"-.--.-\",     \"_\": \"..--.-\",\n }\n\ne = 50      # Element time in ms. one dit is on for e then off for e\nf = 1280    # Tone freq. in hertz\nchargap = 1 # Time between characters of a word, in units of e\nwordgap = 7 # Time between words, in units of e\n\ndef gap(n=1):\n    time.sleep(n * e / 1000)\noff = gap\n\ndef on(n=1):\n    winsound.Beep(f, n * e)\n\ndef dit():\n    on(); off()\n\ndef dah():\n    on(3); off()\n\ndef bloop(n=3):\n    winsound.Beep(f//2, n * e)\n\ndef windowsmorse(text):\n    for word in text.strip().upper().split():\n        for char in word:\n            for element in char2morse.get(char, '?'):\n                if element == '-':\n                    dah()\n                elif element == '.':\n                    dit()\n                else:\n                    bloop()\n            gap(chargap)\n        gap(wordgap)\n\n# Outputs its own source file as Morse. An audible quine!\n#with open(sys.argv[0], 'r') as thisfile:\n#    windowsmorse(thisfile.read())\n    \nwhile True:\n    windowsmorse(input('A string to change into morse: '))\n\n", "human_summarization": "<output> convert a given string into audible Morse code and send it to an audio device such as a PC speaker. It either ignores unknown characters or indicates them with a different pitch. </output>", "id": "4828", "incomplete_code": "import time, winsound\nchar2morse = {'!': '---.', '\"': '.-..-.', '$': '...-..-', \"'\": '.----.', '(': '-.--.', ')': '-.--.-', '+': '.-.-.', ',': '--..--', '-': '-....-', '.': '.-.-.-', '/': '-..-.', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', ':': '---...', ';': '-.-.-.', '=': '-...-', '?': '..--..', '@': '.--.-.', 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '[': '-.--.', ']': '-.--.-', '_': '..--.-'}\ne = 50\nf = 1280\nchargap = 1\nwordgap = 7\n\ndef gap(n=1):\n    pass\noff = gap\n\ndef on(n=1):\n    pass\n\ndef dit():\n    pass\n\ndef dah():\n    pass\n\ndef bloop(n=3):\n    pass\n\ndef windowsmorse(text):\n    pass\nwhile True:\n    windowsmorse(input('A string to change into morse: '))", "original_code": "\nimport time, winsound #, sys\n\nchar2morse = {          \n          \"!\": \"---.\",      \"\\\"\": \".-..-.\",     \"$\": \"...-..-\",    \"'\": \".----.\",  \n          \"(\": \"-.--.\",      \")\": \"-.--.-\",     \"+\": \".-.-.\",      \",\": \"--..--\", \n          \"-\": \"-....-\",     \".\": \".-.-.-\",     \"/\": \"-..-.\", \n          \"0\": \"-----\",      \"1\": \".----\",      \"2\": \"..---\",      \"3\": \"...--\", \n          \"4\": \"....-\",      \"5\": \".....\",      \"6\": \"-....\",      \"7\": \"--...\", \n          \"8\": \"---..\",      \"9\": \"----.\", \n          \":\": \"---...\",     \";\": \"-.-.-.\",     \"=\": \"-...-\",      \"?\": \"..--..\", \n          \"@\": \".--.-.\", \n          \"A\": \".-\",         \"B\": \"-...\",       \"C\": \"-.-.\",       \"D\": \"-..\", \n          \"E\": \".\",          \"F\": \"..-.\",       \"G\": \"--.\",        \"H\": \"....\", \n          \"I\": \"..\",         \"J\": \".---\",       \"K\": \"-.-\",        \"L\": \".-..\", \n          \"M\": \"--\",         \"N\": \"-.\",         \"O\": \"---\",        \"P\": \".--.\", \n          \"Q\": \"--.-\",       \"R\": \".-.\",        \"S\": \"...\",        \"T\": \"-\", \n          \"U\": \"..-\",        \"V\": \"...-\",       \"W\": \".--\",        \"X\": \"-..-\", \n          \"Y\": \"-.--\",       \"Z\": \"--..\", \n          \"[\": \"-.--.\",      \"]\": \"-.--.-\",     \"_\": \"..--.-\",\n }\n\ne = 50      # Element time in ms. one dit is on for e then off for e\nf = 1280    # Tone freq. in hertz\nchargap = 1 # Time between characters of a word, in units of e\nwordgap = 7 # Time between words, in units of e\n\ndef gap(n=1):\n    time.sleep(n * e / 1000)\noff = gap\n\ndef on(n=1):\n    winsound.Beep(f, n * e)\n\ndef dit():\n    on(); off()\n\ndef dah():\n    on(3); off()\n\ndef bloop(n=3):\n    winsound.Beep(f//2, n * e)\n\ndef windowsmorse(text):\n    for word in text.strip().upper().split():\n        for char in word:\n            for element in char2morse.get(char, '?'):\n                if element == '-':\n                    dah()\n                elif element == '.':\n                    dit()\n                else:\n                    bloop()\n            gap(chargap)\n        gap(wordgap)\n\n# Outputs its own source file as Morse. An audible quine!\n#with open(sys.argv[0], 'r') as thisfile:\n#    windowsmorse(thisfile.read())\n    \nwhile True:\n    windowsmorse(input('A string to change into morse: '))\n\n", "perturbed_code": "\ne = 50\nchar2morse = {'!': '---.', '\"': '.-..-.', '$': '...-..-', \"'\": '.----.', '(': '-.--.', ')': '-.--.-', '+': '.-.-.', ',': '--..--', '-': '-....-', '.': '.-.-.-', '/': '-..-.', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', ':': '---...', ';': '-.-.-.', '=': '-...-', '?': '..--..', '@': '.--.-.', 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '[': '-.--.', ']': '-.--.-', '_': '..--.-'}\n\ndef windowsmorse(text):\n    for word in text.strip().upper().split():\n        for char in word:\n            for element in char2morse.get(char, '?'):\n                if (element == '-'):\n                    dah()\n                elif (element == '.'):\n                    dit()\n                else:\n                    bloop()\n            gap(chargap)\n        gap(wordgap)\nimport time, winsound\nf = 1280\nwordgap = 7\nchargap = 1\n\ndef dah():\n    on(3)\n    off()\n\ndef gap(n=1):\n    time.sleep(((n * e) / 1000))\noff = gap\n\ndef bloop(n=3):\n    winsound.Beep((f // 2), (n * e))\n\ndef dit():\n    on()\n    off()\n\ndef on(n=1):\n    winsound.Beep(f, (n * e))\nwhile True:\n    windowsmorse(input('A string to change into morse: '))\n", "incomplete_perturbed_code": "e = 50\nchar2morse = {'!': '---.', '\"': '.-..-.', '$': '...-..-', \"'\": '.----.', '(': '-.--.', ')': '-.--.-', '+': '.-.-.', ',': '--..--', '-': '-....-', '.': '.-.-.-', '/': '-..-.', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', ':': '---...', ';': '-.-.-.', '=': '-...-', '?': '..--..', '@': '.--.-.', 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '[': '-.--.', ']': '-.--.-', '_': '..--.-'}\n\ndef windowsmorse(text):\n    pass\nimport time, winsound\nf = 1280\nwordgap = 7\nchargap = 1\n\ndef dah():\n    pass\n\ndef gap(n=1):\n    pass\noff = gap\n\ndef bloop(n=3):\n    pass\n\ndef dit():\n    pass\n\ndef on(n=1):\n    pass\nwhile True:\n    windowsmorse(input('A string to change into morse: '))", "adversarial_score": 2, "original_score": 3, "search_time_seconds": 1535.7119736671448, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 100, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 100, "successful_llm_evaluations": 100, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 0, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 100}, "adversarial_completion": "e = 50\nchar2morse = {'!': '---.', '\"': '.-..-.', '$': '...-..-', \"'\": '.----.', '(': '-.--.', ')': '-.--.-', '+': '.-.-.', ',': '--..--', '-': '-....-', '.': '.-.-.-', '/': '-..-.', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', ':': '---...', ';': '-.-.-.', '=': '-...-', '?': '..--..', '@': '.--.-.', 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '[': '-.--.', ']': '-.--.-', '_': '..--.-'}\n\ndef windowsmorse(text):\n    for char in text.upper():\n        if char in char2morse:\n            morse = char2morse[char]\n            for bit in morse:\n                if bit == '.':\n                    dit()\n                elif bit == '-':\n                    dah()\n                else:\n                    bloop()\n            gap(chargap)\n        else:\n            bloop()\n            gap(chargap)\n    gap(wordgap)\n\nimport time, winsound\nf = 1280\nwordgap = 7\nchargap = 1\n\ndef dah():\n    winsound.Beep(f, e)\n    time.sleep(3 * chargap)\n\ndef gap(n=1):\n    time.sleep(n * chargap)\n\ndef bloop(n=3):\n    winsound.Beep(f + 100, e)\n    time.sleep(0.5)\n\ndef dit():\n    winsound.Beep(f, e)\n    time.sleep(chargap)\n\ndef on(n=1):\n    time.sleep(n * chargap)\n\nwhile True:\n    windowsmorse(input('A string to change into morse: '))", "score_distribution_all_attempts": [2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 2, 3, 3, 3, 3, 2, 2, 3, 3, 3, 2, 2, 2, 2, 2, 2, 3, 2, 3, 2, 2, 3, 2, 2, 2, 2, 2, 3, 2, 2, 3, 3, 2, 2, 3, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 3, 2, 3, 3, 3, 3, 2, 2, 2, 2, 2, 3, 2, 2, 3, 2, 2, 3, 3, 2, 3, 2, 2, 2, 2, 2, 3, 2, 2, 3, 2, 3, 3, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 2]}
{"lang_cluster": "Python", "source_code": "\n'''\nNote that this code is broken, e.g., it won't work when \nblocks = [(\"A\", \"B\"), (\"A\",\"C\")] and the word is \"AB\", where the answer\nshould be True, but the code returns False.\n'''\nblocks = [(\"B\", \"O\"),\n          (\"X\", \"K\"),\n          (\"D\", \"Q\"),\n          (\"C\", \"P\"),\n          (\"N\", \"A\"),\n          (\"G\", \"T\"),\n          (\"R\", \"E\"),\n          (\"T\", \"G\"),\n          (\"Q\", \"D\"),\n          (\"F\", \"S\"),\n          (\"J\", \"W\"),\n          (\"H\", \"U\"),\n          (\"V\", \"I\"),\n          (\"A\", \"N\"),\n          (\"O\", \"B\"),\n          (\"E\", \"R\"),\n          (\"F\", \"S\"),\n          (\"L\", \"Y\"),\n          (\"P\", \"C\"),\n          (\"Z\", \"M\")]\n\n\ndef can_make_word(word, block_collection=blocks):\n    \"\"\"\n    Return True if `word` can be made from the blocks in `block_collection`.\n\n    >>> can_make_word(\"\")\n    False\n    >>> can_make_word(\"a\")\n    True\n    >>> can_make_word(\"bark\")\n    True\n    >>> can_make_word(\"book\")\n    False\n    >>> can_make_word(\"treat\")\n    True\n    >>> can_make_word(\"common\")\n    False\n    >>> can_make_word(\"squad\")\n    True\n    >>> can_make_word(\"coNFused\")\n    True\n    \"\"\"\n    if not word:\n        return False\n\n    blocks_remaining = block_collection[:]\n    for char in word.upper():\n        for block in blocks_remaining:\n            if char in block:\n                blocks_remaining.remove(block)\n                break\n        else:\n            return False\n    return True\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n    print(\", \".join(\"'%s': %s\" % (w, can_make_word(w)) for w in\n                    [\"\", \"a\", \"baRk\", \"booK\", \"treat\", \n                     \"COMMON\", \"squad\", \"Confused\"]))\n\n\n", "human_summarization": "The code implements a function that checks if a given word can be spelled using a predefined collection of ABC blocks. Each block contains two letters and can only be used once. The function is case-insensitive and returns a boolean value based on whether the word can be formed or not. It also handles the case of an empty string input.", "id": "4829", "incomplete_code": "\"\"\"\nNote that this code is broken, e.g., it won't work when \nblocks = [(\"A\", \"B\"), (\"A\",\"C\")] and the word is \"AB\", where the answer\nshould be True, but the code returns False.\n\"\"\"\nblocks = [('B', 'O'), ('X', 'K'), ('D', 'Q'), ('C', 'P'), ('N', 'A'), ('G', 'T'), ('R', 'E'), ('T', 'G'), ('Q', 'D'), ('F', 'S'), ('J', 'W'), ('H', 'U'), ('V', 'I'), ('A', 'N'), ('O', 'B'), ('E', 'R'), ('F', 'S'), ('L', 'Y'), ('P', 'C'), ('Z', 'M')]\n\ndef can_make_word(word, block_collection=blocks):\n    \"\"\"\n    Return True if `word` can be made from the blocks in `block_collection`.\n\n    >>> can_make_word(\"\")\n    False\n    >>> can_make_word(\"a\")\n    True\n    >>> can_make_word(\"bark\")\n    True\n    >>> can_make_word(\"book\")\n    False\n    >>> can_make_word(\"treat\")\n    True\n    >>> can_make_word(\"common\")\n    False\n    >>> can_make_word(\"squad\")\n    True\n    >>> can_make_word(\"coNFused\")\n    True\n    \"\"\"\n    pass\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n    print(', '.join((\"'%s': %s\" % (w, can_make_word(w)) for w in ['', 'a', 'baRk', 'booK', 'treat', 'COMMON', 'squad', 'Confused'])))", "original_code": "\n'''\nNote that this code is broken, e.g., it won't work when \nblocks = [(\"A\", \"B\"), (\"A\",\"C\")] and the word is \"AB\", where the answer\nshould be True, but the code returns False.\n'''\nblocks = [(\"B\", \"O\"),\n          (\"X\", \"K\"),\n          (\"D\", \"Q\"),\n          (\"C\", \"P\"),\n          (\"N\", \"A\"),\n          (\"G\", \"T\"),\n          (\"R\", \"E\"),\n          (\"T\", \"G\"),\n          (\"Q\", \"D\"),\n          (\"F\", \"S\"),\n          (\"J\", \"W\"),\n          (\"H\", \"U\"),\n          (\"V\", \"I\"),\n          (\"A\", \"N\"),\n          (\"O\", \"B\"),\n          (\"E\", \"R\"),\n          (\"F\", \"S\"),\n          (\"L\", \"Y\"),\n          (\"P\", \"C\"),\n          (\"Z\", \"M\")]\n\n\ndef can_make_word(word, block_collection=blocks):\n    \"\"\"\n    Return True if `word` can be made from the blocks in `block_collection`.\n\n    >>> can_make_word(\"\")\n    False\n    >>> can_make_word(\"a\")\n    True\n    >>> can_make_word(\"bark\")\n    True\n    >>> can_make_word(\"book\")\n    False\n    >>> can_make_word(\"treat\")\n    True\n    >>> can_make_word(\"common\")\n    False\n    >>> can_make_word(\"squad\")\n    True\n    >>> can_make_word(\"coNFused\")\n    True\n    \"\"\"\n    if not word:\n        return False\n\n    blocks_remaining = block_collection[:]\n    for char in word.upper():\n        for block in blocks_remaining:\n            if char in block:\n                blocks_remaining.remove(block)\n                break\n        else:\n            return False\n    return True\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n    print(\", \".join(\"'%s': %s\" % (w, can_make_word(w)) for w in\n                    [\"\", \"a\", \"baRk\", \"booK\", \"treat\", \n                     \"COMMON\", \"squad\", \"Confused\"]))\n\n\n", "perturbed_code": "\n\ndef can_make_word(word, block_collection=blocks):\n    '\\n    Return True if `word` can be made from the blocks in `block_collection`.\\n\\n    >>> can_make_word(\"\")\\n    False\\n    >>> can_make_word(\"a\")\\n    True\\n    >>> can_make_word(\"bark\")\\n    True\\n    >>> can_make_word(\"book\")\\n    False\\n    >>> can_make_word(\"treat\")\\n    True\\n    >>> can_make_word(\"common\")\\n    False\\n    >>> can_make_word(\"squad\")\\n    True\\n    >>> can_make_word(\"coNFused\")\\n    True\\n    '\n    for char in word.upper():\n        for block in blocks_remaining:\n            if (char in block):\n                blocks_remaining.remove(block)\n                break\n        else:\n            return False\n    return True\n    if (not word):\n        return False\n    blocks_remaining = block_collection[:]\n'\\nNote that this code is broken, e.g., it won\\'t work when \\nblocks = [(\"A\", \"B\"), (\"A\",\"C\")] and the word is \"AB\", where the answer\\nshould be True, but the code returns False.\\n'\nblocks = [('B', 'O'), ('X', 'K'), ('D', 'Q'), ('C', 'P'), ('N', 'A'), ('G', 'T'), ('R', 'E'), ('T', 'G'), ('Q', 'D'), ('F', 'S'), ('J', 'W'), ('H', 'U'), ('V', 'I'), ('A', 'N'), ('O', 'B'), ('E', 'R'), ('F', 'S'), ('L', 'Y'), ('P', 'C'), ('Z', 'M')]\nif (__name__ == '__main__'):\n    import doctest\n    print(', '.join(((\"'%s': %s\" % (w, can_make_word(w))) for w in ['', 'a', 'baRk', 'booK', 'treat', 'COMMON', 'squad', 'Confused'])))\n    doctest.testmod()\n", "incomplete_perturbed_code": "def can_make_word(word, block_collection=blocks):\n    \"\"\"\n    Return True if `word` can be made from the blocks in `block_collection`.\n\n    >>> can_make_word(\"\")\n    False\n    >>> can_make_word(\"a\")\n    True\n    >>> can_make_word(\"bark\")\n    True\n    >>> can_make_word(\"book\")\n    False\n    >>> can_make_word(\"treat\")\n    True\n    >>> can_make_word(\"common\")\n    False\n    >>> can_make_word(\"squad\")\n    True\n    >>> can_make_word(\"coNFused\")\n    True\n    \"\"\"\n    pass\n'\\nNote that this code is broken, e.g., it won\\'t work when \\nblocks = [(\"A\", \"B\"), (\"A\",\"C\")] and the word is \"AB\", where the answer\\nshould be True, but the code returns False.\\n'\nblocks = [('B', 'O'), ('X', 'K'), ('D', 'Q'), ('C', 'P'), ('N', 'A'), ('G', 'T'), ('R', 'E'), ('T', 'G'), ('Q', 'D'), ('F', 'S'), ('J', 'W'), ('H', 'U'), ('V', 'I'), ('A', 'N'), ('O', 'B'), ('E', 'R'), ('F', 'S'), ('L', 'Y'), ('P', 'C'), ('Z', 'M')]\nif __name__ == '__main__':\n    import doctest\n    print(', '.join((\"'%s': %s\" % (w, can_make_word(w)) for w in ['', 'a', 'baRk', 'booK', 'treat', 'COMMON', 'squad', 'Confused'])))\n    doctest.testmod()", "adversarial_score": 3, "original_score": 4, "search_time_seconds": 270.26353645324707, "search_stats": {"total_reordering_attempts": 100, "unique_reorderings_generated": 23, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 32, "successful_llm_evaluations": 32, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 68, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 100, "unique_perturbations": 23}, "adversarial_completion": "def can_make_word(word, block_collection=blocks):\n    \"\"\"\n    Return True if `word` can be made from the blocks in `block_collection`.\n\n    >>> can_make_word(\"\")\n    False\n    >>> can_make_word(\"a\")\n    True\n    >>> can_make_word(\"bark\")\n    True\n    >>> can_make_word(\"book\")\n    False\n    >>> can_make_word(\"treat\")\n    True\n    >>> can_make_word(\"common\")\n    False\n    >>> can_make_word(\"squad\")\n    True\n    >>> can_make_word(\"coNFused\")\n    True\n    \"\"\"\n    if not word:\n        return False\n\n    word = word.lower()\n    available_blocks = block_collection[:]  # Create a copy to avoid modifying the original\n\n    for char in word:\n        found = False\n        for block in available_blocks:\n            if char in block:\n                available_blocks.remove(block)\n                found = True\n                break\n        if not found:\n            return False\n\n    return True\nblocks = [('B', 'O'), ('X', 'K'), ('D', 'Q'), ('C', 'P'), ('N', 'A'), ('G', 'T'), ('R', 'E'), ('T', 'G'), ('Q', 'D'), ('F', 'S'), ('J', 'W'), ('H', 'U'), ('V', 'I'), ('A', 'N'), ('O', 'B'), ('E', 'R'), ('F', 'S'), ('L', 'Y'), ('P', 'C'), ('Z', 'M')]\nif __name__ == '__main__':\n    import doctest\n    print(', '.join((\"'%s': %s\" % (w, can_make_word(w)) for w in ['', 'a', 'baRk', 'booK', 'treat', 'COMMON', 'squad', 'Confused'])))\n    doctest.testmod()", "score_distribution_all_attempts": [4, 4, 3, 3, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 4, 3, 3, 4, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 4, 4, 3, 3, 3, 3, 4, 3, 3, 4, 3, 4, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 4, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 4, 4, 3, 3, 3, 4, 4, 4, 3, 3, 4, 4, 4, 3, 3, 3, 4, 3, 4, 4, 4, 4]}
