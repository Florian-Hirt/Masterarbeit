{"lang_cluster": "Python", "source_code": "\n# Works with: Python version 2.5\n\nfrom collections import deque\nstack = deque()\nstack.append(value) # pushing\nvalue = stack.pop()\nnot stack # is empty?\n\nfrom collections import deque\n\nclass Stack:\n    def __init__(self):\n        self._items = deque()\n    def append(self, item):\n        self._items.append(item)\n    def pop(self):\n        return self._items.pop()\n    def __nonzero__(self):\n        return bool(self._items)\n\nclass Stack:\n    def __init__(self):\n        self._first = None\n    def __nonzero__(self):\n        return self._first is not None \n    def append(self, value):\n        self._first = (value, self._first)\n    def pop(self):\n        if self._first is None:\n            raise IndexError(\"pop from empty stack\")\n        value, self._first = self._first\n        return value\n\nwhile not stack.empty():\n pass \nwhile stack:\n pass\n", "human_summarization": "implement a stack data structure supporting basic operations such as push, pop, and empty check. The stack follows a last in, first out (LIFO) access policy. The implementation can be done using a deque for faster performance or a linked list for a simpler interface.", "id": 4672, "incomplete_code": "from collections import deque\nstack = deque()\nstack.append(value)\nvalue = stack.pop()\nnot stack\nfrom collections import deque\n\nclass Stack:\n\n    def __init__(self):\n        pass\n\n    def append(self, item):\n        pass\n\n    def pop(self):\n        pass\n\n    def __nonzero__(self):\n        pass\n\nclass Stack:\n\n    def __init__(self):\n        pass\n\n    def __nonzero__(self):\n        pass\n\n    def append(self, value):\n        pass\n\n    def pop(self):\n        pass\nwhile not stack.empty():\n    pass\nwhile stack:\n    pass", "original_code": "\n# Works with: Python version 2.5\n\nfrom collections import deque\nstack = deque()\nstack.append(value) # pushing\nvalue = stack.pop()\nnot stack # is empty?\n\nfrom collections import deque\n\nclass Stack:\n    def __init__(self):\n        self._items = deque()\n    def append(self, item):\n        self._items.append(item)\n    def pop(self):\n        return self._items.pop()\n    def __nonzero__(self):\n        return bool(self._items)\n\nclass Stack:\n    def __init__(self):\n        self._first = None\n    def __nonzero__(self):\n        return self._first is not None \n    def append(self, value):\n        self._first = (value, self._first)\n    def pop(self):\n        if self._first is None:\n            raise IndexError(\"pop from empty stack\")\n        value, self._first = self._first\n        return value\n\nwhile not stack.empty():\n pass \nwhile stack:\n pass\n", "perturbed_code": "\nfrom collections import deque\nwhile stack:\n    pass\nstack = deque()\nstack.append(value)\nvalue = stack.pop()\n(not stack)\nfrom collections import deque\n\nclass Stack():\n\n    def __init__(self):\n        self._items = deque()\n\n    def append(self, item):\n        self._items.append(item)\n\n    def pop(self):\n        return self._items.pop()\n\n    def __nonzero__(self):\n        return bool(self._items)\n\nclass Stack():\n\n    def __init__(self):\n        self._first = None\n\n    def __nonzero__(self):\n        return (self._first is not None)\n\n    def append(self, value):\n        self._first = (value, self._first)\n\n    def pop(self):\n        if (self._first is None):\n            raise IndexError('pop from empty stack')\n        (value, self._first) = self._first\n        return value\nwhile (not stack.empty()):\n    pass\n", "incomplete_perturbed_code": "from collections import deque\nwhile stack:\n    pass\nstack = deque()\nstack.append(value)\nvalue = stack.pop()\nnot stack\nfrom collections import deque\n\nclass Stack:\n\n    def __init__(self):\n        pass\n\n    def append(self, item):\n        pass\n\n    def pop(self):\n        pass\n\n    def __nonzero__(self):\n        pass\n\nclass Stack:\n\n    def __init__(self):\n        pass\n\n    def __nonzero__(self):\n        pass\n\n    def append(self, value):\n        pass\n\n    def pop(self):\n        pass\nwhile not stack.empty():\n    pass", "adversarial_score": 4, "original_score": 4, "search_time": 39.38280940055847, "stats": {"total_attempts": 100, "unique_perturbations": 5, "cache_hits": 80, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "from collections import deque\n\nclass Stack:\n\n    def __init__(self):\n        self._stack = deque()\n\n    def __nonzero__(self):\n        return len(self._stack) > 0\n\n    def append(self, value):\n        self._stack.append(value)\n\n    def pop(self):\n        if not self.empty():\n            return self._stack.pop()\n        else:\n            return None\n\n    def __nonzero__(self):\n        return len(self._stack) > 0", "score_distribution": [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]}
{"lang_cluster": "Python", "source_code": "\n\nfrom collections import namedtuple, deque\nfrom pprint import pprint as pp\n \n \ninf = float('inf')\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\n \nclass Graph():\n    def __init__(self, edges):\n        self.edges = [Edge(*edge) for edge in edges]\n        # print(dir(self.edges[0]))\n        self.vertices = {e.start for e in self.edges} | {e.end for e in self.edges}\n \n    def dijkstra(self, source, dest):\n        assert source in self.vertices\n        dist = {vertex: inf for vertex in self.vertices}\n        previous = {vertex: None for vertex in self.vertices}\n        dist[source] = 0\n        q = self.vertices.copy()\n        neighbours = {vertex: set() for vertex in self.vertices}\n        for start, end, cost in self.edges:\n            neighbours[start].add((end, cost))\n            neighbours[end].add((start, cost))\n\n        #pp(neighbours)\n \n        while q:\n            # pp(q)\n            u = min(q, key=lambda vertex: dist[vertex])\n            q.remove(u)\n            if dist[u] == inf or u == dest:\n                break\n            for v, cost in neighbours[u]:\n                alt = dist[u] + cost\n                if alt < dist[v]:                                  # Relax (u,v,a)\n                    dist[v] = alt\n                    previous[v] = u\n        #pp(previous)\n        s, u = deque(), dest\n        while previous[u]:\n            s.appendleft(u)\n            u = previous[u]\n        s.appendleft(u)\n        return s\n \n \ngraph = Graph([(\"a\", \"b\", 7),  (\"a\", \"c\", 9),  (\"a\", \"f\", 14), (\"b\", \"c\", 10),\n               (\"b\", \"d\", 15), (\"c\", \"d\", 11), (\"c\", \"f\", 2),  (\"d\", \"e\", 6),\n               (\"e\", \"f\", 9)])\npp(graph.dijkstra(\"a\", \"e\"))\n\n\n", "human_summarization": "Implement Dijkstra's algorithm to find the shortest path from a given source node to all other nodes in a graph. The graph is represented by an adjacency matrix or list and a start node. The algorithm outputs a set of edges that depict the shortest path to each reachable node from the origin. The code also includes functionality to interpret the output and display the shortest path from the source node to specific nodes.", "id": 4678, "incomplete_code": "from collections import namedtuple, deque\nfrom pprint import pprint as pp\ninf = float('inf')\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\n\nclass Graph:\n\n    def __init__(self, edges):\n        pass\n\n    def dijkstra(self, source, dest):\n        pass\ngraph = Graph([('a', 'b', 7), ('a', 'c', 9), ('a', 'f', 14), ('b', 'c', 10), ('b', 'd', 15), ('c', 'd', 11), ('c', 'f', 2), ('d', 'e', 6), ('e', 'f', 9)])\npp(graph.dijkstra('a', 'e'))", "original_code": "\n\nfrom collections import namedtuple, deque\nfrom pprint import pprint as pp\n \n \ninf = float('inf')\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\n \nclass Graph():\n    def __init__(self, edges):\n        self.edges = [Edge(*edge) for edge in edges]\n        # print(dir(self.edges[0]))\n        self.vertices = {e.start for e in self.edges} | {e.end for e in self.edges}\n \n    def dijkstra(self, source, dest):\n        assert source in self.vertices\n        dist = {vertex: inf for vertex in self.vertices}\n        previous = {vertex: None for vertex in self.vertices}\n        dist[source] = 0\n        q = self.vertices.copy()\n        neighbours = {vertex: set() for vertex in self.vertices}\n        for start, end, cost in self.edges:\n            neighbours[start].add((end, cost))\n            neighbours[end].add((start, cost))\n\n        #pp(neighbours)\n \n        while q:\n            # pp(q)\n            u = min(q, key=lambda vertex: dist[vertex])\n            q.remove(u)\n            if dist[u] == inf or u == dest:\n                break\n            for v, cost in neighbours[u]:\n                alt = dist[u] + cost\n                if alt < dist[v]:                                  # Relax (u,v,a)\n                    dist[v] = alt\n                    previous[v] = u\n        #pp(previous)\n        s, u = deque(), dest\n        while previous[u]:\n            s.appendleft(u)\n            u = previous[u]\n        s.appendleft(u)\n        return s\n \n \ngraph = Graph([(\"a\", \"b\", 7),  (\"a\", \"c\", 9),  (\"a\", \"f\", 14), (\"b\", \"c\", 10),\n               (\"b\", \"d\", 15), (\"c\", \"d\", 11), (\"c\", \"f\", 2),  (\"d\", \"e\", 6),\n               (\"e\", \"f\", 9)])\npp(graph.dijkstra(\"a\", \"e\"))\n\n\n", "perturbed_code": "\nfrom pprint import pprint as pp\nfrom collections import namedtuple, deque\ninf = float('inf')\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\ngraph = Graph([('a', 'b', 7), ('a', 'c', 9), ('a', 'f', 14), ('b', 'c', 10), ('b', 'd', 15), ('c', 'd', 11), ('c', 'f', 2), ('d', 'e', 6), ('e', 'f', 9)])\n\nclass Graph():\n\n    def __init__(self, edges):\n        self.edges = [Edge(*edge) for edge in edges]\n        self.vertices = ({e.start for e in self.edges} | {e.end for e in self.edges})\n\n    def dijkstra(self, source, dest):\n        while previous[u]:\n            s.appendleft(u)\n            u = previous[u]\n        assert (source in self.vertices)\n        while q:\n            for (v, cost) in neighbours[u]:\n                alt = (cost + dist[u])\n                if (alt < dist[v]):\n                    dist[v] = alt\n                    previous[v] = u\n            if ((dist[u] == inf) or (dest == u)):\n                break\n            u = min(q, key=(lambda vertex: dist[vertex]))\n            q.remove(u)\n        for (start, end, cost) in self.edges:\n            neighbours[start].add((end, cost))\n            neighbours[end].add((start, cost))\n        dist = {vertex: inf for vertex in self.vertices}\n        previous = {vertex: None for vertex in self.vertices}\n        dist[source] = 0\n        q = self.vertices.copy()\n        neighbours = {vertex: set() for vertex in self.vertices}\n        (s, u) = (deque(), dest)\n        s.appendleft(u)\n        return s\npp(graph.dijkstra('a', 'e'))\n", "incomplete_perturbed_code": "from pprint import pprint as pp\nfrom collections import namedtuple, deque\ninf = float('inf')\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\ngraph = Graph([('a', 'b', 7), ('a', 'c', 9), ('a', 'f', 14), ('b', 'c', 10), ('b', 'd', 15), ('c', 'd', 11), ('c', 'f', 2), ('d', 'e', 6), ('e', 'f', 9)])\n\nclass Graph:\n\n    def __init__(self, edges):\n        pass\n\n    def dijkstra(self, source, dest):\n        pass\npp(graph.dijkstra('a', 'e'))", "adversarial_score": 2, "original_score": 3, "search_time": 578.4235289096832, "stats": {"total_attempts": 100, "unique_perturbations": 81, "cache_hits": 19, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "from pprint import pprint as pp\nfrom collections import namedtuple, deque\ninf = float('inf')\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\ngraph = Graph([('a', 'b', 7), ('a', 'c', 9), ('a', 'f', 14), ('b', 'c', 10), ('b', 'd', 15), ('c', 'd', 11), ('c', 'f', 2), ('d', 'e', 6), ('e', 'f', 9)])\n\nclass Graph:\n\n    def __init__(self, edges):\n        self.edges = edges\n        self.graph = {}\n        for start, end, cost in edges:\n            if start not in self.graph:\n                self.graph[start] = []\n            self.graph[start].append((end, cost))\n\n    def dijkstra(self, source, dest):\n        distances = {node: inf for node in self.graph}\n        distances[source] = 0\n        predecessors = {node: None for node in self.graph}\n        queue = deque([source])\n\n        while queue:\n            node = queue.popleft()\n            if node == dest:\n                break\n\n            if node not in self.graph:\n                continue\n\n            for neighbor, cost in self.graph[node]:\n                new_distance = distances[node] + cost\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    predecessors[neighbor] = node\n                    queue.append(neighbor)\n\n        path = []\n        current = dest\n        while current is not None:\n            path.insert(0, current)\n            current = predecessors[current]\n\n        if distances[dest] == inf:\n            return None\n\n        return path\npp(graph.dijkstra('a', 'e'))", "score_distribution": [3, 2, 2, 3, 3, 3, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 3, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 3, 3, 2, 2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 3, 3, 2, 2, 3, 2, 2]}
{"lang_cluster": "Python", "source_code": "k8 = [\t14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7 ] \nk7 = [\t15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10 ]\nk6 = [\t10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8 ]\nk5 = [\t 7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15 ]\nk4 = [\t 2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9 ]\nk3 = [\t12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11 ]\nk2 = [\t 4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1 ]\nk1 = [\t13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7 ]\n \nk87 = [0] * 256\nk65 = [0] * 256\nk43 = [0] * 256\nk21 = [0] * 256\n \ndef kboxinit():\n\tfor i in range(256):\n\t\tk87[i] = k8[i >> 4] << 4 | k7[i & 15]\n\t\tk65[i] = k6[i >> 4] << 4 | k5[i & 15]\n\t\tk43[i] = k4[i >> 4] << 4 | k3[i & 15]\n\t\tk21[i] = k2[i >> 4] << 4 | k1[i & 15]\n \ndef f(x):\n\tx = ( k87[x>>24 & 255] << 24 | k65[x>>16 & 255] << 16 |\n\t      k43[x>> 8 & 255] <<  8 | k21[x & 255] )\n\treturn x<<11 | x>>(32-11)\n\n", "human_summarization": "Implement the main step of the GOST 28147-89 symmetric encryption algorithm, which involves taking a 64-bit block of text and one of the eight 32-bit encryption key elements, using a replacement table, and returning an encrypted block.", "id": 4680, "incomplete_code": "k8 = [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7]\nk7 = [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10]\nk6 = [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8]\nk5 = [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15]\nk4 = [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9]\nk3 = [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11]\nk2 = [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1]\nk1 = [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7]\nk87 = [0] * 256\nk65 = [0] * 256\nk43 = [0] * 256\nk21 = [0] * 256\n\ndef kboxinit():\n    pass\n\ndef f(x):\n    pass", "original_code": "k8 = [\t14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7 ] \nk7 = [\t15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10 ]\nk6 = [\t10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8 ]\nk5 = [\t 7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15 ]\nk4 = [\t 2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9 ]\nk3 = [\t12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11 ]\nk2 = [\t 4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1 ]\nk1 = [\t13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7 ]\n \nk87 = [0] * 256\nk65 = [0] * 256\nk43 = [0] * 256\nk21 = [0] * 256\n \ndef kboxinit():\n\tfor i in range(256):\n\t\tk87[i] = k8[i >> 4] << 4 | k7[i & 15]\n\t\tk65[i] = k6[i >> 4] << 4 | k5[i & 15]\n\t\tk43[i] = k4[i >> 4] << 4 | k3[i & 15]\n\t\tk21[i] = k2[i >> 4] << 4 | k1[i & 15]\n \ndef f(x):\n\tx = ( k87[x>>24 & 255] << 24 | k65[x>>16 & 255] << 16 |\n\t      k43[x>> 8 & 255] <<  8 | k21[x & 255] )\n\treturn x<<11 | x>>(32-11)\n\n", "perturbed_code": "\nk5 = [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15]\nk7 = [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10]\nk1 = [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7]\nk3 = [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11]\nk2 = [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1]\nk4 = [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9]\nk21 = ([0] * 256)\nk43 = (256 * [0])\nk8 = [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7]\nk87 = (256 * [0])\nk65 = ([0] * 256)\nk6 = [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8]\n\ndef f(x):\n    x = (k21[(255 & x)] | ((k43[((x >> 8) & 255)] << 8) | ((k87[((x >> 24) & 255)] << 24) | (k65[(255 & (x >> 16))] << 16))))\n    return ((x << 11) | (x >> (32 - 11)))\n\ndef kboxinit():\n    for i in range(256):\n        k21[i] = (k1[(15 & i)] | (k2[(i >> 4)] << 4))\n        k43[i] = ((k4[(i >> 4)] << 4) | k3[(i & 15)])\n        k87[i] = (k7[(15 & i)] | (k8[(i >> 4)] << 4))\n        k65[i] = ((k6[(i >> 4)] << 4) | k5[(15 & i)])\n", "incomplete_perturbed_code": "k5 = [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15]\nk7 = [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10]\nk1 = [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7]\nk3 = [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11]\nk2 = [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1]\nk4 = [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9]\nk21 = [0] * 256\nk43 = 256 * [0]\nk8 = [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7]\nk87 = 256 * [0]\nk65 = [0] * 256\nk6 = [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8]\n\ndef f(x):\n    pass\n\ndef kboxinit():\n    pass", "adversarial_score": 2, "original_score": 2, "search_time": 3883.284200668335, "stats": {"total_attempts": 100, "unique_perturbations": 100, "cache_hits": 0, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "k5 = [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15]\nk7 = [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10]\nk1 = [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7]\nk3 = [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11]\nk2 = [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1]\nk4 = [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9]\nk21 = [0] * 256\nk43 = 256 * [0]\nk8 = [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7]\nk87 = 256 * [0]\nk65 = [0] * 256\nk6 = [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8]\n\ndef f(x):\n    return (x * 0x9e3779b9) & 0xffffffff\n\ndef kboxinit():\n    pass", "score_distribution": [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]}
{"lang_cluster": "Python", "source_code": "\n\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = list(set(items))\n\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nhelperset = set()\nfor x in items:\n    if x not in helperset:\n        unique.append(x)\n        helperset.add(x)\n\nimport itertools\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = [k for k,g in itertools.groupby(sorted(items))]\n\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nfor x in items:\n    if x not in unique:\n        unique.append(x)\n\nfrom collections import OrderedDict as od\n\nprint(list(od.fromkeys([1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']).keys()))\n\nfrom itertools import (groupby)\n\n\n# nubByKey\u00a0:: (a -> b) -> [a] -> [a]\ndef nubByKey(k, xs):\n    return list(list(v)[0] for _, v in groupby(sorted(xs, key=k), key=k))\n\n\nxs = [\n    'apple', 'apple',\n    'ampersand', 'aPPLE', 'Apple',\n    'orange', 'ORANGE', 'Orange', 'orange', 'apple'\n]\nfor k in [\n    id,                      # default case sensitive uniqueness\n    lambda x: x.lower(),     # case-insensitive uniqueness\n    lambda x: x[0],          # unique first character (case-sensitive)\n    lambda x: x[0].lower(),  # unique first character (case-insensitive)\n]:\n    print (\n        nubByKey(k, xs)\n    )\n\n", "human_summarization": "implement methods to remove duplicate elements from an array. The methods include using a hash table, sorting and removing consecutive duplicates, and checking each element against the rest of the list. Additionally, the codes handle cases where elements are hashable or comparable, and provide a brute-force method when both conditions fail. The codes also consider the order of elements and offer solutions using the OrderedDict module. The codes can handle different types of uniqueness and duplication, including case-insensitivity with strings and uniqueness with respect to a dictionary key. The codes also allow the use of an equality predicate or a key function to define uniqueness.", "id": 4687, "incomplete_code": "items = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = list(set(items))\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nhelperset = set()\nfor x in items:\n    if x not in helperset:\n        unique.append(x)\n        helperset.add(x)\nimport itertools\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = [k for k, g in itertools.groupby(sorted(items))]\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nfor x in items:\n    if x not in unique:\n        unique.append(x)\nfrom collections import OrderedDict as od\nprint(list(od.fromkeys([1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']).keys()))\nfrom itertools import groupby\n\ndef nubByKey(k, xs):\n    pass\nxs = ['apple', 'apple', 'ampersand', 'aPPLE', 'Apple', 'orange', 'ORANGE', 'Orange', 'orange', 'apple']\nfor k in [id, lambda x: x.lower(), lambda x: x[0], lambda x: x[0].lower()]:\n    print(nubByKey(k, xs))", "original_code": "\n\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = list(set(items))\n\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nhelperset = set()\nfor x in items:\n    if x not in helperset:\n        unique.append(x)\n        helperset.add(x)\n\nimport itertools\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = [k for k,g in itertools.groupby(sorted(items))]\n\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nfor x in items:\n    if x not in unique:\n        unique.append(x)\n\nfrom collections import OrderedDict as od\n\nprint(list(od.fromkeys([1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']).keys()))\n\nfrom itertools import (groupby)\n\n\n# nubByKey\u00a0:: (a -> b) -> [a] -> [a]\ndef nubByKey(k, xs):\n    return list(list(v)[0] for _, v in groupby(sorted(xs, key=k), key=k))\n\n\nxs = [\n    'apple', 'apple',\n    'ampersand', 'aPPLE', 'Apple',\n    'orange', 'ORANGE', 'Orange', 'orange', 'apple'\n]\nfor k in [\n    id,                      # default case sensitive uniqueness\n    lambda x: x.lower(),     # case-insensitive uniqueness\n    lambda x: x[0],          # unique first character (case-sensitive)\n    lambda x: x[0].lower(),  # unique first character (case-insensitive)\n]:\n    print (\n        nubByKey(k, xs)\n    )\n\n", "perturbed_code": "\nfor k in [id, (lambda x: x.lower()), (lambda x: x[0]), (lambda x: x[0].lower())]:\n    print(nubByKey(k, xs))\nfor x in items:\n    if (x not in unique):\n        unique.append(x)\nfor x in items:\n    if (x not in helperset):\n        unique.append(x)\n        helperset.add(x)\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = list(set(items))\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nhelperset = set()\nimport itertools\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = [k for (k, g) in itertools.groupby(sorted(items))]\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nfrom collections import OrderedDict as od\nprint(list(od.fromkeys([1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']).keys()))\nfrom itertools import groupby\n\ndef nubByKey(k, xs):\n    return list((list(v)[0] for (_, v) in groupby(sorted(xs, key=k), key=k)))\nxs = ['apple', 'apple', 'ampersand', 'aPPLE', 'Apple', 'orange', 'ORANGE', 'Orange', 'orange', 'apple']\n", "incomplete_perturbed_code": "for k in [id, lambda x: x.lower(), lambda x: x[0], lambda x: x[0].lower()]:\n    print(nubByKey(k, xs))\nfor x in items:\n    if x not in unique:\n        unique.append(x)\nfor x in items:\n    if x not in helperset:\n        unique.append(x)\n        helperset.add(x)\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = list(set(items))\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nhelperset = set()\nimport itertools\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = [k for k, g in itertools.groupby(sorted(items))]\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nfrom collections import OrderedDict as od\nprint(list(od.fromkeys([1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']).keys()))\nfrom itertools import groupby\n\ndef nubByKey(k, xs):\n    pass\nxs = ['apple', 'apple', 'ampersand', 'aPPLE', 'Apple', 'orange', 'ORANGE', 'Orange', 'orange', 'apple']", "adversarial_score": 3, "original_score": 4, "search_time": 31.385929346084595, "stats": {"total_attempts": 100, "unique_perturbations": 1, "cache_hits": 80, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "from collections import OrderedDict as od\n\ndef nubByKey(k, xs):\n    unique = []\n    helperset = set()\n    for x in xs:\n        if x not in helperset:\n            unique.append(x)\n            helperset.add(x)\n    return unique\n\nfor k in [id, lambda x: x.lower(), lambda x: x[0], lambda x: x[0].lower()]:\n    print(nubByKey(k, xs))\nfor x in items:\n    if x not in unique:\n        unique.append(x)\nfor x in items:\n    if x not in helperset:\n        unique.append(x)\n        helperset.add(x)\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = list(set(items))\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nhelperset = set()\nimport itertools\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = [k for k, g in itertools.groupby(sorted(items))]\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nfrom collections import OrderedDict as od\nprint(list(od.fromkeys([1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']).keys()))\nfrom itertools import groupby\n\nxs = ['apple', 'apple', 'ampersand', 'aPPLE', 'Apple', 'orange', 'ORANGE', 'Orange', 'orange', 'apple']", "score_distribution": [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]}
{"lang_cluster": "Python", "source_code": "\ndef quickSort(arr):\n    less = []\n    pivotList = []\n    more = []\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr[0]\n        for i in arr:\n            if i < pivot:\n                less.append(i)\n            elif i > pivot:\n                more.append(i)\n            else:\n                pivotList.append(i)\n        less = quickSort(less)\n        more = quickSort(more)\n        return less + pivotList + more\n\na = [4, 65, 2, -31, 0, 99, 83, 782, 1]\na = quickSort(a)\n\ndef qsort(L):\n    return (qsort([y for y in L[1:] if y <  L[0]]) + \n            [L[0]] + \n            qsort([y for y in L[1:] if y >= L[0]])) if len(L) > 1 else L\n\ndef qsort(list):\n    if not list:\n        return []\n    else:\n        pivot = list[0]\n        less = [x for x in list[1:]   if x <  pivot]\n        more = [x for x in list[1:] if x >= pivot]\n        return qsort(less) + [pivot] + qsort(more)\n\nfrom random import *\n\ndef qSort(a):\n    if len(a) <= 1:\n        return a\n    else:\n        q = choice(a)\n        return qSort([elem for elem in a if elem < q]) + [q] * a.count(q) + qSort([elem for elem in a if elem > q])\n\ndef quickSort(a):\n    if len(a) <= 1:\n        return a\n    else:\n        less = []\n        more = []\n        pivot = choice(a)\n        for i in a:\n            if i < pivot:\n                less.append(i)\n            if i > pivot:\n                more.append(i)\n        less = quickSort(less)\n        more = quickSort(more)\n        return less + [pivot] * a.count(pivot) + more\n\ndef qsort(array):\n    if len(array) < 2:\n        return array\n    head, *tail = array\n    less = qsort([i for i in tail if i < head])\n    more = qsort([i for i in tail if i >= head])\n    return less + [head] + more\n\ndef quicksort(array):\n    _quicksort(array, 0, len(array) - 1)\n\ndef _quicksort(array, start, stop):\n    if stop - start > 0:\n        pivot, left, right = array[start], start, stop\n        while left <= right:\n            while array[left] < pivot:\n                left += 1\n            while array[right] > pivot:\n                right -= 1\n            if left <= right:\n                array[left], array[right] = array[right], array[left]\n                left += 1\n                right -= 1\n        _quicksort(array, start, right)\n        _quicksort(array, left, stop)\n", "human_summarization": "implement the quicksort algorithm to sort an array or list of elements. The elements have a strict weak order and the index of the array can be of any type. The algorithm works by choosing a pivot element and dividing the rest of the elements into two partitions based on their relation to the pivot. It then recursively sorts both partitions and combines them with the pivot to form the sorted array. The algorithm also includes an optimized version that works in place by swapping elements within the array to avoid additional memory allocation. The pivot selection method is not specified.", "id": 4688, "incomplete_code": "def quickSort(arr):\n    pass\na = [4, 65, 2, -31, 0, 99, 83, 782, 1]\na = quickSort(a)\n\ndef qsort(L):\n    pass\n\ndef qsort(list):\n    pass\nfrom random import *\n\ndef qSort(a):\n    pass\n\ndef quickSort(a):\n    pass\n\ndef qsort(array):\n    pass\n\ndef quicksort(array):\n    pass\n\ndef _quicksort(array, start, stop):\n    pass", "original_code": "\ndef quickSort(arr):\n    less = []\n    pivotList = []\n    more = []\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr[0]\n        for i in arr:\n            if i < pivot:\n                less.append(i)\n            elif i > pivot:\n                more.append(i)\n            else:\n                pivotList.append(i)\n        less = quickSort(less)\n        more = quickSort(more)\n        return less + pivotList + more\n\na = [4, 65, 2, -31, 0, 99, 83, 782, 1]\na = quickSort(a)\n\ndef qsort(L):\n    return (qsort([y for y in L[1:] if y <  L[0]]) + \n            [L[0]] + \n            qsort([y for y in L[1:] if y >= L[0]])) if len(L) > 1 else L\n\ndef qsort(list):\n    if not list:\n        return []\n    else:\n        pivot = list[0]\n        less = [x for x in list[1:]   if x <  pivot]\n        more = [x for x in list[1:] if x >= pivot]\n        return qsort(less) + [pivot] + qsort(more)\n\nfrom random import *\n\ndef qSort(a):\n    if len(a) <= 1:\n        return a\n    else:\n        q = choice(a)\n        return qSort([elem for elem in a if elem < q]) + [q] * a.count(q) + qSort([elem for elem in a if elem > q])\n\ndef quickSort(a):\n    if len(a) <= 1:\n        return a\n    else:\n        less = []\n        more = []\n        pivot = choice(a)\n        for i in a:\n            if i < pivot:\n                less.append(i)\n            if i > pivot:\n                more.append(i)\n        less = quickSort(less)\n        more = quickSort(more)\n        return less + [pivot] * a.count(pivot) + more\n\ndef qsort(array):\n    if len(array) < 2:\n        return array\n    head, *tail = array\n    less = qsort([i for i in tail if i < head])\n    more = qsort([i for i in tail if i >= head])\n    return less + [head] + more\n\ndef quicksort(array):\n    _quicksort(array, 0, len(array) - 1)\n\ndef _quicksort(array, start, stop):\n    if stop - start > 0:\n        pivot, left, right = array[start], start, stop\n        while left <= right:\n            while array[left] < pivot:\n                left += 1\n            while array[right] > pivot:\n                right -= 1\n            if left <= right:\n                array[left], array[right] = array[right], array[left]\n                left += 1\n                right -= 1\n        _quicksort(array, start, right)\n        _quicksort(array, left, stop)\n", "perturbed_code": "\n\ndef quickSort(arr):\n    if (len(arr) <= 1):\n        return arr\n    else:\n        for i in arr:\n            if (i < pivot):\n                less.append(i)\n            else:\n                if (i > pivot):\n                    more.append(i)\n                else:\n                    pivotList.append(i)\n        less = quickSort(less)\n        more = quickSort(more)\n        return ((less + pivotList) + more)\n        pivot = arr[0]\n    more = []\n    pivotList = []\n    less = []\na = [4, 65, 2, (- 31), 0, 99, 83, 782, 1]\n\ndef qsort(L):\n    return ((qsort([y for y in L[1:] if (y >= L[0])]) + (qsort([y for y in L[1:] if (y < L[0])]) + [L[0]])) if (len(L) > 1) else L)\n\ndef qsort(list):\n    if (not list):\n        return []\n    else:\n        pivot = list[0]\n        less = [x for x in list[1:] if (x < pivot)]\n        more = [x for x in list[1:] if (x >= pivot)]\n        return (qsort(more) + ([pivot] + qsort(less)))\nfrom random import *\n\ndef qSort(a):\n    if (len(a) <= 1):\n        return a\n    else:\n        q = choice(a)\n        return (qSort([elem for elem in a if (elem > q)]) + (qSort([elem for elem in a if (elem < q)]) + (a.count(q) * [q])))\n\ndef quickSort(a):\n    if (len(a) <= 1):\n        return a\n    else:\n        for i in a:\n            if (i > pivot):\n                more.append(i)\n            if (i < pivot):\n                less.append(i)\n        less = []\n        more = []\n        less = quickSort(less)\n        pivot = choice(a)\n        more = quickSort(more)\n        return (more + ((a.count(pivot) * [pivot]) + less))\n\ndef qsort(array):\n    if (len(array) < 2):\n        return array\n    (head, *tail) = array\n    less = qsort([i for i in tail if (i < head)])\n    more = qsort([i for i in tail if (i >= head)])\n    return ((less + [head]) + more)\n\ndef quicksort(array):\n    _quicksort(array, 0, (len(array) - 1))\n\ndef _quicksort(array, start, stop):\n    if ((stop - start) > 0):\n        (pivot, left, right) = (array[start], start, stop)\n        while (left <= right):\n            if (left <= right):\n                (array[left], array[right]) = (array[right], array[left])\n                left += 1\n                right -= 1\n            while (array[right] > pivot):\n                right -= 1\n            while (array[left] < pivot):\n                left += 1\n        _quicksort(array, start, right)\n        _quicksort(array, left, stop)\na = quickSort(a)\n", "incomplete_perturbed_code": "def quickSort(arr):\n    pass\na = [4, 65, 2, -31, 0, 99, 83, 782, 1]\n\ndef qsort(L):\n    pass\n\ndef qsort(list):\n    pass\nfrom random import *\n\ndef qSort(a):\n    pass\n\ndef quickSort(a):\n    pass\n\ndef qsort(array):\n    pass\n\ndef quicksort(array):\n    pass\n\ndef _quicksort(array, start, stop):\n    pass\na = quickSort(a)", "adversarial_score": 4, "original_score": 4, "search_time": 36.344987869262695, "stats": {"total_attempts": 100, "unique_perturbations": 100, "cache_hits": 0, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "def quickSort(arr):\n    pass\n\na = [4, 65, 2, -31, 0, 99, 83, 782, 1]\n\ndef qsort(L):\n    pass\n\ndef qsort(list):\n    pass\nfrom random import *\n\ndef qSort(a):\n    pass\n\ndef quickSort(a):\n    pass\n\ndef qsort(array):\n    pass\n\ndef quicksort(array):\n    pass\n\ndef _quicksort(array, start, stop):\n    if start < stop:\n        pivot_index = partition(array, start, stop)\n        _quicksort(array, start, pivot_index - 1)\n        _quicksort(array, pivot_index + 1, stop)\n\n\ndef partition(array, start, stop):\n    pivot = array[start]\n    i = start + 1\n    for j in range(start + 1, stop + 1):\n        if array[j] < pivot:\n            i += 1\n            array[i], array[j] = array[j], array[i]\n    array[start], array[i] = array[i], array[start]\n    return i\n\na = quickSort(a)", "score_distribution": [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]}
{"lang_cluster": "Python", "source_code": "\n# Works with: Python version 2.7+ and 3.1+\nimport collections, sys\n\ndef filecharcount(openfile):\n    return sorted(collections.Counter(c for l in openfile for c in l).items())\n\nf = open(sys.argv[1])\nprint(filecharcount(f))\n\n\n# Works with: Python version 3\n'''Character counting as a fold'''\n\nfrom functools import reduce\nfrom itertools import repeat\nfrom os.path import expanduser\n\n\n# charCounts\u00a0:: String -> Dict Char Int\ndef charCounts(s):\n    '''A dictionary of\n       (character, frequency) mappings\n    '''\n    def tally(dct, c):\n        dct[c] = 1 + dct[c] if c in dct else 1\n        return dct\n    return reduce(tally, list(s), {})\n\n\n# TEST ----------------------------------------------------\n# main\u00a0:: IO ()\ndef main():\n    '''Listing in descending order of frequency.'''\n\n    print(\n        tabulated(\n            'Descending order of frequency:\\n'\n        )(compose(repr)(fst))(compose(str)(snd))(\n            5\n        )(stet)(\n            sorted(\n                charCounts(\n                    readFile('~/Code/charCount/readme.txt')\n                ).items(),\n                key=swap,\n                reverse=True\n            )\n        )\n    )\n\n\n# GENERIC -------------------------------------------------\n\n# chunksOf\u00a0:: Int -> [a] -> [[a]]\ndef chunksOf(n):\n    '''A series of lists of length n,\n       subdividing the contents of xs.\n       Where the length of xs is not evenly divible,\n       the final list will be shorter than n.'''\n    return lambda xs: reduce(\n        lambda a, i: a + [xs[i:n + i]],\n        range(0, len(xs), n), []\n    ) if 0 < n else []\n\n\n# compose (<<<)\u00a0:: (b -> c) -> (a -> b) -> a -> c\ndef compose(g):\n    '''Right to left function composition.'''\n    return lambda f: lambda x: g(f(x))\n\n\n# fst\u00a0:: (a, b) -> a\ndef fst(tpl):\n    '''First member of a pair.'''\n    return tpl[0]\n\n\n# readFile\u00a0:: FilePath -> IO String\ndef readFile(fp):\n    '''The contents of any file at the path\n       derived by expanding any ~ in fp.'''\n    with open(expanduser(fp), 'r', encoding='utf-8') as f:\n        return f.read()\n\n\n# paddedMatrix\u00a0:: a -> [[a]] -> [[a]]\ndef paddedMatrix(v):\n    ''''A list of rows padded to equal length\n        (where needed) with instances of the value v.'''\n    def go(rows):\n        return paddedRows(\n            len(max(rows, key=len))\n        )(v)(rows)\n    return lambda rows: go(rows) if rows else []\n\n\n# paddedRows\u00a0:: Int -> a -> [[a]] -[[a]]\ndef paddedRows(n):\n    '''A list of rows padded (but never truncated)\n       to length n with copies of value v.'''\n    def go(v, xs):\n        def pad(x):\n            d = n - len(x)\n            return (x + list(repeat(v, d))) if 0 < d else x\n        return list(map(pad, xs))\n    return lambda v: lambda xs: go(v, xs) if xs else []\n\n\n# showColumns\u00a0:: Int -> [String] -> String\ndef showColumns(n):\n    '''A column-wrapped string\n       derived from a list of rows.'''\n    def go(xs):\n        def fit(col):\n            w = len(max(col, key=len))\n\n            def pad(x):\n                return x.ljust(4 + w, ' ')\n            return ''.join(map(pad, col)).rstrip()\n\n        q, r = divmod(len(xs), n)\n        return '\\n'.join(map(\n            fit,\n            zip(*paddedMatrix('')(\n                chunksOf(q + int(bool(r)))(xs)\n            ))\n        ))\n    return lambda xs: go(xs)\n\n\n# snd\u00a0:: (a, b) -> b\ndef snd(tpl):\n    '''Second member of a pair.'''\n    return tpl[1]\n\n\n# stet\u00a0:: a -> a\ndef stet(x):\n    '''The identity function.\n       The usual 'id' is reserved in Python.'''\n    return x\n\n\n# swap\u00a0:: (a, b) -> (b, a)\ndef swap(tpl):\n    '''The swapped components of a pair.'''\n    return (tpl[1], tpl[0])\n\n\n# tabulated\u00a0:: String -> (a -> String) ->\n#                        (b -> String) ->\n#                        Int ->\n#                        (a -> b) -> [a] -> String\ndef tabulated(s):\n    '''Heading -> x display function -> fx display function ->\n          number of columns -> f -> value list -> tabular string.'''\n    def go(xShow, fxShow, intCols, f, xs):\n        def mxw(fshow, g):\n            return max(map(compose(len)(fshow), map(g, xs)))\n        w = mxw(xShow, lambda x: x)\n        fw = mxw(fxShow, f)\n        return s + '\\n' + showColumns(intCols)([\n            xShow(x).rjust(w, ' ') + ' -> ' + (\n                fxShow(f(x)).rjust(fw, ' ')\n            )\n            for x in xs\n        ])\n    return lambda xShow: lambda fxShow: lambda nCols: (\n        lambda f: lambda xs: go(\n            xShow, fxShow, nCols, f, xs\n        )\n    )\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\n\n", "human_summarization": "open a text file, count the frequency of each letter (A to Z), and print the results. The counting process is expressed using fold/reduce. The code can be imported into other Python scripts or used as a standalone script. It avoids unnecessary complexity by not using a numerically indexed array and by eliminating the need for converting letters into list indices.", "id": 4705, "incomplete_code": "import collections, sys\n\ndef filecharcount(openfile):\n    pass\nf = open(sys.argv[1])\nprint(filecharcount(f))\n'Character counting as a fold'\nfrom functools import reduce\nfrom itertools import repeat\nfrom os.path import expanduser\n\ndef charCounts(s):\n    \"\"\"A dictionary of\n       (character, frequency) mappings\n    \"\"\"\n    pass\n\ndef main():\n    \"\"\"Listing in descending order of frequency.\"\"\"\n    pass\n\ndef chunksOf(n):\n    \"\"\"A series of lists of length n,\n       subdividing the contents of xs.\n       Where the length of xs is not evenly divible,\n       the final list will be shorter than n.\"\"\"\n    pass\n\ndef compose(g):\n    \"\"\"Right to left function composition.\"\"\"\n    pass\n\ndef fst(tpl):\n    \"\"\"First member of a pair.\"\"\"\n    pass\n\ndef readFile(fp):\n    \"\"\"The contents of any file at the path\n       derived by expanding any ~ in fp.\"\"\"\n    pass\n\ndef paddedMatrix(v):\n    \"\"\"'A list of rows padded to equal length\n        (where needed) with instances of the value v.\"\"\"\n    pass\n\ndef paddedRows(n):\n    \"\"\"A list of rows padded (but never truncated)\n       to length n with copies of value v.\"\"\"\n    pass\n\ndef showColumns(n):\n    \"\"\"A column-wrapped string\n       derived from a list of rows.\"\"\"\n    pass\n\ndef snd(tpl):\n    \"\"\"Second member of a pair.\"\"\"\n    pass\n\ndef stet(x):\n    \"\"\"The identity function.\n       The usual 'id' is reserved in Python.\"\"\"\n    pass\n\ndef swap(tpl):\n    \"\"\"The swapped components of a pair.\"\"\"\n    pass\n\ndef tabulated(s):\n    \"\"\"Heading -> x display function -> fx display function ->\n          number of columns -> f -> value list -> tabular string.\"\"\"\n    pass\nif __name__ == '__main__':\n    main()", "original_code": "\n# Works with: Python version 2.7+ and 3.1+\nimport collections, sys\n\ndef filecharcount(openfile):\n    return sorted(collections.Counter(c for l in openfile for c in l).items())\n\nf = open(sys.argv[1])\nprint(filecharcount(f))\n\n\n# Works with: Python version 3\n'''Character counting as a fold'''\n\nfrom functools import reduce\nfrom itertools import repeat\nfrom os.path import expanduser\n\n\n# charCounts\u00a0:: String -> Dict Char Int\ndef charCounts(s):\n    '''A dictionary of\n       (character, frequency) mappings\n    '''\n    def tally(dct, c):\n        dct[c] = 1 + dct[c] if c in dct else 1\n        return dct\n    return reduce(tally, list(s), {})\n\n\n# TEST ----------------------------------------------------\n# main\u00a0:: IO ()\ndef main():\n    '''Listing in descending order of frequency.'''\n\n    print(\n        tabulated(\n            'Descending order of frequency:\\n'\n        )(compose(repr)(fst))(compose(str)(snd))(\n            5\n        )(stet)(\n            sorted(\n                charCounts(\n                    readFile('~/Code/charCount/readme.txt')\n                ).items(),\n                key=swap,\n                reverse=True\n            )\n        )\n    )\n\n\n# GENERIC -------------------------------------------------\n\n# chunksOf\u00a0:: Int -> [a] -> [[a]]\ndef chunksOf(n):\n    '''A series of lists of length n,\n       subdividing the contents of xs.\n       Where the length of xs is not evenly divible,\n       the final list will be shorter than n.'''\n    return lambda xs: reduce(\n        lambda a, i: a + [xs[i:n + i]],\n        range(0, len(xs), n), []\n    ) if 0 < n else []\n\n\n# compose (<<<)\u00a0:: (b -> c) -> (a -> b) -> a -> c\ndef compose(g):\n    '''Right to left function composition.'''\n    return lambda f: lambda x: g(f(x))\n\n\n# fst\u00a0:: (a, b) -> a\ndef fst(tpl):\n    '''First member of a pair.'''\n    return tpl[0]\n\n\n# readFile\u00a0:: FilePath -> IO String\ndef readFile(fp):\n    '''The contents of any file at the path\n       derived by expanding any ~ in fp.'''\n    with open(expanduser(fp), 'r', encoding='utf-8') as f:\n        return f.read()\n\n\n# paddedMatrix\u00a0:: a -> [[a]] -> [[a]]\ndef paddedMatrix(v):\n    ''''A list of rows padded to equal length\n        (where needed) with instances of the value v.'''\n    def go(rows):\n        return paddedRows(\n            len(max(rows, key=len))\n        )(v)(rows)\n    return lambda rows: go(rows) if rows else []\n\n\n# paddedRows\u00a0:: Int -> a -> [[a]] -[[a]]\ndef paddedRows(n):\n    '''A list of rows padded (but never truncated)\n       to length n with copies of value v.'''\n    def go(v, xs):\n        def pad(x):\n            d = n - len(x)\n            return (x + list(repeat(v, d))) if 0 < d else x\n        return list(map(pad, xs))\n    return lambda v: lambda xs: go(v, xs) if xs else []\n\n\n# showColumns\u00a0:: Int -> [String] -> String\ndef showColumns(n):\n    '''A column-wrapped string\n       derived from a list of rows.'''\n    def go(xs):\n        def fit(col):\n            w = len(max(col, key=len))\n\n            def pad(x):\n                return x.ljust(4 + w, ' ')\n            return ''.join(map(pad, col)).rstrip()\n\n        q, r = divmod(len(xs), n)\n        return '\\n'.join(map(\n            fit,\n            zip(*paddedMatrix('')(\n                chunksOf(q + int(bool(r)))(xs)\n            ))\n        ))\n    return lambda xs: go(xs)\n\n\n# snd\u00a0:: (a, b) -> b\ndef snd(tpl):\n    '''Second member of a pair.'''\n    return tpl[1]\n\n\n# stet\u00a0:: a -> a\ndef stet(x):\n    '''The identity function.\n       The usual 'id' is reserved in Python.'''\n    return x\n\n\n# swap\u00a0:: (a, b) -> (b, a)\ndef swap(tpl):\n    '''The swapped components of a pair.'''\n    return (tpl[1], tpl[0])\n\n\n# tabulated\u00a0:: String -> (a -> String) ->\n#                        (b -> String) ->\n#                        Int ->\n#                        (a -> b) -> [a] -> String\ndef tabulated(s):\n    '''Heading -> x display function -> fx display function ->\n          number of columns -> f -> value list -> tabular string.'''\n    def go(xShow, fxShow, intCols, f, xs):\n        def mxw(fshow, g):\n            return max(map(compose(len)(fshow), map(g, xs)))\n        w = mxw(xShow, lambda x: x)\n        fw = mxw(fxShow, f)\n        return s + '\\n' + showColumns(intCols)([\n            xShow(x).rjust(w, ' ') + ' -> ' + (\n                fxShow(f(x)).rjust(fw, ' ')\n            )\n            for x in xs\n        ])\n    return lambda xShow: lambda fxShow: lambda nCols: (\n        lambda f: lambda xs: go(\n            xShow, fxShow, nCols, f, xs\n        )\n    )\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\n\n", "perturbed_code": "\nimport collections, sys\n\ndef filecharcount(openfile):\n    return sorted(collections.Counter((c for l in openfile for c in l)).items())\nf = open(sys.argv[1])\n'Character counting as a fold'\nfrom functools import reduce\nfrom itertools import repeat\nfrom os.path import expanduser\n\ndef charCounts(s):\n    'A dictionary of\\n       (character, frequency) mappings\\n    '\n\n    def tally(dct, c):\n        dct[c] = ((1 + dct[c]) if (c in dct) else 1)\n        return dct\n    return reduce(tally, list(s), {})\n\ndef main():\n    'Listing in descending order of frequency.'\n    print(tabulated('Descending order of frequency:\\n')(compose(repr)(fst))(compose(str)(snd))(5)(stet)(sorted(charCounts(readFile('~/Code/charCount/readme.txt')).items(), key=swap, reverse=True)))\n\ndef chunksOf(n):\n    'A series of lists of length n,\\n       subdividing the contents of xs.\\n       Where the length of xs is not evenly divible,\\n       the final list will be shorter than n.'\n    return (lambda xs: (reduce((lambda a, i: ([xs[i:(i + n)]] + a)), range(0, len(xs), n), []) if (0 < n) else []))\n\ndef compose(g):\n    'Right to left function composition.'\n    return (lambda f: (lambda x: g(f(x))))\n\ndef fst(tpl):\n    'First member of a pair.'\n    return tpl[0]\n\ndef readFile(fp):\n    'The contents of any file at the path\\n       derived by expanding any ~ in fp.'\n    with open(expanduser(fp), 'r', encoding='utf-8') as f:\n        return f.read()\n\ndef paddedMatrix(v):\n    \"'A list of rows padded to equal length\\n        (where needed) with instances of the value v.\"\n\n    def go(rows):\n        return paddedRows(len(max(rows, key=len)))(v)(rows)\n    return (lambda rows: (go(rows) if rows else []))\n\ndef paddedRows(n):\n    'A list of rows padded (but never truncated)\\n       to length n with copies of value v.'\n\n    def go(v, xs):\n\n        def pad(x):\n            d = (n - len(x))\n            return ((list(repeat(v, d)) + x) if (0 < d) else x)\n        return list(map(pad, xs))\n    return (lambda v: (lambda xs: (go(v, xs) if xs else [])))\n\ndef showColumns(n):\n    'A column-wrapped string\\n       derived from a list of rows.'\n\n    def go(xs):\n\n        def fit(col):\n            w = len(max(col, key=len))\n\n            def pad(x):\n                return x.ljust((4 + w), ' ')\n            return ''.join(map(pad, col)).rstrip()\n        (q, r) = divmod(len(xs), n)\n        return '\\n'.join(map(fit, zip(*paddedMatrix('')(chunksOf((q + int(bool(r))))(xs)))))\n    return (lambda xs: go(xs))\n\ndef snd(tpl):\n    'Second member of a pair.'\n    return tpl[1]\n\ndef stet(x):\n    \"The identity function.\\n       The usual 'id' is reserved in Python.\"\n    return x\n\ndef swap(tpl):\n    'The swapped components of a pair.'\n    return (tpl[1], tpl[0])\n\ndef tabulated(s):\n    'Heading -> x display function -> fx display function ->\\n          number of columns -> f -> value list -> tabular string.'\n\n    def go(xShow, fxShow, intCols, f, xs):\n\n        def mxw(fshow, g):\n            return max(map(compose(len)(fshow), map(g, xs)))\n        w = mxw(xShow, (lambda x: x))\n        fw = mxw(fxShow, f)\n        return (('\\n' + s) + showColumns(intCols)([((xShow(x).rjust(w, ' ') + ' -> ') + fxShow(f(x)).rjust(fw, ' ')) for x in xs]))\n    return (lambda xShow: (lambda fxShow: (lambda nCols: (lambda f: (lambda xs: go(xShow, fxShow, nCols, f, xs))))))\nif (__name__ == '__main__'):\n    main()\nprint(filecharcount(f))\n", "incomplete_perturbed_code": "import collections, sys\n\ndef filecharcount(openfile):\n    pass\nf = open(sys.argv[1])\n'Character counting as a fold'\nfrom functools import reduce\nfrom itertools import repeat\nfrom os.path import expanduser\n\ndef charCounts(s):\n    \"\"\"A dictionary of\n       (character, frequency) mappings\n    \"\"\"\n    pass\n\ndef main():\n    \"\"\"Listing in descending order of frequency.\"\"\"\n    pass\n\ndef chunksOf(n):\n    \"\"\"A series of lists of length n,\n       subdividing the contents of xs.\n       Where the length of xs is not evenly divible,\n       the final list will be shorter than n.\"\"\"\n    pass\n\ndef compose(g):\n    \"\"\"Right to left function composition.\"\"\"\n    pass\n\ndef fst(tpl):\n    \"\"\"First member of a pair.\"\"\"\n    pass\n\ndef readFile(fp):\n    \"\"\"The contents of any file at the path\n       derived by expanding any ~ in fp.\"\"\"\n    pass\n\ndef paddedMatrix(v):\n    \"\"\"'A list of rows padded to equal length\n        (where needed) with instances of the value v.\"\"\"\n    pass\n\ndef paddedRows(n):\n    \"\"\"A list of rows padded (but never truncated)\n       to length n with copies of value v.\"\"\"\n    pass\n\ndef showColumns(n):\n    \"\"\"A column-wrapped string\n       derived from a list of rows.\"\"\"\n    pass\n\ndef snd(tpl):\n    \"\"\"Second member of a pair.\"\"\"\n    pass\n\ndef stet(x):\n    \"\"\"The identity function.\n       The usual 'id' is reserved in Python.\"\"\"\n    pass\n\ndef swap(tpl):\n    \"\"\"The swapped components of a pair.\"\"\"\n    pass\n\ndef tabulated(s):\n    \"\"\"Heading -> x display function -> fx display function ->\n          number of columns -> f -> value list -> tabular string.\"\"\"\n    pass\nif __name__ == '__main__':\n    main()\nprint(filecharcount(f))", "adversarial_score": 2, "original_score": 3, "search_time": 114.54830360412598, "stats": {"total_attempts": 100, "unique_perturbations": 100, "cache_hits": 0, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "import collections, sys\n\ndef filecharcount(openfile):\n    \"\"\"Summarization: open a text file, count the frequency of each letter (A to Z), and print the results. The counting process is expressed using fold/reduce. The code can be imported into other Python scripts or used as a standalone script. It avoids unnecessary complexity by not using a numerically indexed array and by eliminating the need for converting letters into list indices.\"\"\"\n    f = open(openfile)\n    'Character counting as a fold'\n    from functools import reduce\n    from itertools import repeat\n    from os.path import expanduser\n\n    def charCounts(s):\n        \"\"\"A dictionary of\n           (character, frequency) mappings\n        \"\"\"\n        counts = collections.defaultdict(int)\n        for char in s:\n            if 'A' <= char <= 'Z':\n                counts[char] += 1\n            elif 'a' <= char <= 'z':\n                counts[char.upper()] += 1\n        return counts\n\n    def main():\n        \"\"\"Listing in descending order of frequency.\"\"\"\n        text = readFile(f)\n        counts = charCounts(text)\n        sorted_counts = sorted(counts.items(), key=lambda item: item[1], reverse=True)\n        for char, count in sorted_counts:\n            print(f\"{char}: {count}\")\n\n    def chunksOf(n):\n        \"\"\"A series of lists of length n,\n           subdividing the contents of xs.\n           Where the length of xs is not evenly divible,\n           the final list will be shorter than n.\"\"\"\n        from itertools import zip_longest\n        return list(map(list, zip_longest(*[iter(xs)]*n, fillvalue=None)))\n\n    def compose(g):\n        \"\"\"Right to left function composition.\"\"\"\n        def composed(x):\n            return g(x)\n        return composed\n\n    def fst(tpl):\n        \"\"\"First member of a pair.\"\"\"\n        return tpl[0]\n\n    def readFile(fp):\n        \"\"\"The contents of any file at the path\n           derived by expanding any ~ in fp.\"\"\"\n        fp = expanduser(fp)\n        try:\n            with open(fp, 'r') as f:\n                return f.read()\n        except FileNotFoundError:\n            print(f\"File not found: {fp}\")\n            return \"\"\n\n    def paddedMatrix(v):\n        \"\"\"'A list of rows padded to equal length\n           (where needed) with instances of the value v.'\"\"\"\n        return [v] * 10\n\n    def paddedRows(n):\n        \"\"\"A list of rows padded (but never truncated)\n           to length n with copies of value v.\"\"\"\n        return [v] * n\n\n    def showColumns(n):\n        \"\"\"A column-wrapped string\n           derived from a list of rows.\"\"\"\n        from itertools import zip_longest\n        return '\\n'.join([''.join(p) for p in zip_longest(*[iter(paddedRows(n))]*n, fillvalue='')])\n\n    def snd(tpl):\n        \"\"\"Second member of a pair.\"\"\"\n        return tpl[1]\n\n    def stet(x):\n        \"\"\"The identity function.\n           The usual 'id' is reserved in Python.\"\"\"\n        return x\n\n    def swap(tpl):\n        \"\"\"The swapped components of a pair.\"\"\"\n        return (tpl[1], tpl[0])\n\n    def tabulated(s):\n        \"\"\"Heading -> x display function -> fx display function ->\n           number of columns -> f -> value list -> tabular string.\"\"\"\n        from itertools import zip_longest\n        n = len(s[0])\n        header = s[0]\n        values = s[1:]\n        return '\\n'.join([showColumns(n)])\n\n    main()\n    return filecharcount\nif __name__ == '__main__':\n    main()\nprint(filecharcount(f))", "score_distribution": [3, 2, 3, 3, 3, 2, 2, 2, 2, 3, 2, 2, 2, 3, 2, 3, 3, 3, 2, 2, 3, 3, 2, 2, 3, 2, 2, 3, 2, 3, 2, 2, 2, 2, 3, 3, 2, 3, 3, 2, 2, 2, 3, 3, 2, 2, 3, 2, 2, 3, 2, 3, 2, 3, 3, 2, 3, 2, 3, 3, 3, 3, 2, 2, 3, 3, 3, 2, 2, 2, 3, 2, 3, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 2, 2, 3, 2, 3, 2, 2, 3, 2, 2, 3, 2, 3, 2, 3, 2, 2]}
{"lang_cluster": "Python", "source_code": "\nFile:Fractal-tree-python.png\nLibrary: pygame\nimport pygame, math\n\npygame.init()\nwindow = pygame.display.set_mode((600, 600))\npygame.display.set_caption(\"Fractal Tree\")\nscreen = pygame.display.get_surface()\n\ndef drawTree(x1, y1, angle, depth):\n    fork_angle = 20\n    base_len = 10.0\n    if depth > 0:\n        x2 = x1 + int(math.cos(math.radians(angle)) * depth * base_len)\n        y2 = y1 + int(math.sin(math.radians(angle)) * depth * base_len)\n        pygame.draw.line(screen, (255,255,255), (x1, y1), (x2, y2), 2)\n        drawTree(x2, y2, angle - fork_angle, depth - 1)\n        drawTree(x2, y2, angle + fork_angle, depth - 1)\n\ndef input(event):\n    if event.type == pygame.QUIT:\n        exit(0)\n\ndrawTree(300, 550, -90, 9)\npygame.display.flip()\nwhile True:\n    input(pygame.event.wait())\n\n", "human_summarization": "generate and draw a fractal tree by first drawing the trunk, then splitting the trunk at the end by a certain angle to form two branches, and repeating this process until a desired level of branching is reached.", "id": 4707, "incomplete_code": "File: Fractal - tree - python.png\nLibrary: pygame\nimport pygame, math\npygame.init()\nwindow = pygame.display.set_mode((600, 600))\npygame.display.set_caption('Fractal Tree')\nscreen = pygame.display.get_surface()\n\ndef drawTree(x1, y1, angle, depth):\n    pass\n\ndef input(event):\n    pass\ndrawTree(300, 550, -90, 9)\npygame.display.flip()\nwhile True:\n    input(pygame.event.wait())", "original_code": "\nFile:Fractal-tree-python.png\nLibrary: pygame\nimport pygame, math\n\npygame.init()\nwindow = pygame.display.set_mode((600, 600))\npygame.display.set_caption(\"Fractal Tree\")\nscreen = pygame.display.get_surface()\n\ndef drawTree(x1, y1, angle, depth):\n    fork_angle = 20\n    base_len = 10.0\n    if depth > 0:\n        x2 = x1 + int(math.cos(math.radians(angle)) * depth * base_len)\n        y2 = y1 + int(math.sin(math.radians(angle)) * depth * base_len)\n        pygame.draw.line(screen, (255,255,255), (x1, y1), (x2, y2), 2)\n        drawTree(x2, y2, angle - fork_angle, depth - 1)\n        drawTree(x2, y2, angle + fork_angle, depth - 1)\n\ndef input(event):\n    if event.type == pygame.QUIT:\n        exit(0)\n\ndrawTree(300, 550, -90, 9)\npygame.display.flip()\nwhile True:\n    input(pygame.event.wait())\n\n", "perturbed_code": "\nimport pygame, math\n\ndef input(event):\n    if (event.type == pygame.QUIT):\n        exit(0)\n\ndef drawTree(x1, y1, angle, depth):\n    fork_angle = 20\n    base_len = 10.0\n    if (depth > 0):\n        x2 = (int(((math.cos(math.radians(angle)) * depth) * base_len)) + x1)\n        y2 = (y1 + int((base_len * (math.sin(math.radians(angle)) * depth))))\n        pygame.draw.line(screen, (255, 255, 255), (x1, y1), (x2, y2), 2)\n        drawTree(x2, y2, (angle - fork_angle), (depth - 1))\n        drawTree(x2, y2, (angle + fork_angle), (depth - 1))\npygame.init()\nFile: ((Fractal - tree) - python.png)\nLibrary: pygame\nwindow = pygame.display.set_mode((600, 600))\npygame.display.set_caption('Fractal Tree')\nscreen = pygame.display.get_surface()\npygame.display.flip()\nwhile True:\n    input(pygame.event.wait())\ndrawTree(300, 550, (- 90), 9)\n", "incomplete_perturbed_code": "import pygame, math\n\ndef input(event):\n    pass\n\ndef drawTree(x1, y1, angle, depth):\n    pass\npygame.init()\nFile: Fractal - tree - python.png\nLibrary: pygame\nwindow = pygame.display.set_mode((600, 600))\npygame.display.set_caption('Fractal Tree')\nscreen = pygame.display.get_surface()\npygame.display.flip()\nwhile True:\n    input(pygame.event.wait())\ndrawTree(300, 550, -90, 9)", "adversarial_score": 2, "original_score": 3, "search_time": 542.5491313934326, "stats": {"total_attempts": 100, "unique_perturbations": 100, "cache_hits": 0, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "import pygame, math\n\ndef input(event):\n    pass\n\ndef drawTree(x1, y1, angle, depth):\n    if depth > 0:\n        color = (0, 100, 0)\n        pygame.draw.line(screen, color, (x1, y1), (x1 + 20 * math.cos(math.radians(angle)), y1 - 20 * math.sin(math.radians(angle))), 3)\n        drawTree(x1 + 20 * math.cos(math.radians(angle)), y1 - 20 * math.sin(math.radians(angle)), angle - 20, depth - 1)\n        drawTree(x1 + 20 * math.cos(math.radians(angle)), y1 - 20 * math.sin(math.radians(angle)), angle + 20, depth - 1)\n\npygame.init()\nFile: Fractal - tree - python.png\nLibrary: pygame\nwindow = pygame.display.set_mode((600, 600))\npygame.display.set_caption('Fractal Tree')\nscreen = pygame.display.get_surface()\npygame.display.flip()\nwhile True:\n    input(pygame.event.wait())\ndrawTree(300, 550, -90, 9)", "score_distribution": [3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 2, 3, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 3, 3, 2, 3, 3, 2, 3, 3, 3, 3, 3, 2, 2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 3, 3, 2, 3, 2, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 3, 2, 3, 2, 3]}
{"lang_cluster": "Python", "source_code": "\ndef _pr(t, x, y, z):\n    txt = '\\n'.join(''.join(t[(n,m)] for n in range(3+x+z)).rstrip()\n                    for m in reversed(range(3+y+z)))\n    return txt\n\t\t\ndef cuboid(x,y,z):\n    t = {(n,m):' ' for n in range(3+x+z) for m in range(3+y+z)}\n    xrow = ['+'] + ['%i' % (i % 10) for i in range(x)] + ['+']\n    for i,ch in enumerate(xrow):\n        t[(i,0)] = t[(i,1+y)] = t[(1+z+i,2+y+z)] = ch\n    if _debug: print(_pr(t, x, y, z))\n    ycol = ['+'] + ['%i' % (j % 10) for j in range(y)] + ['+']\n    for j,ch in enumerate(ycol):\n        t[(0,j)] = t[(x+1,j)] = t[(2+x+z,1+z+j)] = ch\n    zdepth = ['+'] + ['%i' % (k % 10) for k in range(z)] + ['+']\n    if _debug: print(_pr(t, x, y, z))\n    for k,ch in enumerate(zdepth):\n        t[(k,1+y+k)] = t[(1+x+k,1+y+k)] = t[(1+x+k,k)] = ch\n\t\n    return _pr(t, x, y, z)\n\n\n_debug = False\nif __name__ == '__main__':\n    for dim in ((2,3,4), (3,4,2), (4,2,3)):\n        print(\"CUBOID%r\" % (dim,), cuboid(*dim), sep='\\n')\n\n\n", "human_summarization": "The following codes output a graphical or ASCII art representation of a cuboid with dimensions 2x3x4. The cuboid has three visible faces and can be displayed either statically or in rotational projection. Additional features include the ability to rotate the cuboid, change its background, color, transparency, and material, display information about the scene and object, and a self-running demo mode.", "id": 4710, "incomplete_code": "def _pr(t, x, y, z):\n    pass\n\ndef cuboid(x, y, z):\n    pass\n_debug = False\nif __name__ == '__main__':\n    for dim in ((2, 3, 4), (3, 4, 2), (4, 2, 3)):\n        print('CUBOID%r' % (dim,), cuboid(*dim), sep='\\n')", "original_code": "\ndef _pr(t, x, y, z):\n    txt = '\\n'.join(''.join(t[(n,m)] for n in range(3+x+z)).rstrip()\n                    for m in reversed(range(3+y+z)))\n    return txt\n\t\t\ndef cuboid(x,y,z):\n    t = {(n,m):' ' for n in range(3+x+z) for m in range(3+y+z)}\n    xrow = ['+'] + ['%i' % (i % 10) for i in range(x)] + ['+']\n    for i,ch in enumerate(xrow):\n        t[(i,0)] = t[(i,1+y)] = t[(1+z+i,2+y+z)] = ch\n    if _debug: print(_pr(t, x, y, z))\n    ycol = ['+'] + ['%i' % (j % 10) for j in range(y)] + ['+']\n    for j,ch in enumerate(ycol):\n        t[(0,j)] = t[(x+1,j)] = t[(2+x+z,1+z+j)] = ch\n    zdepth = ['+'] + ['%i' % (k % 10) for k in range(z)] + ['+']\n    if _debug: print(_pr(t, x, y, z))\n    for k,ch in enumerate(zdepth):\n        t[(k,1+y+k)] = t[(1+x+k,1+y+k)] = t[(1+x+k,k)] = ch\n\t\n    return _pr(t, x, y, z)\n\n\n_debug = False\nif __name__ == '__main__':\n    for dim in ((2,3,4), (3,4,2), (4,2,3)):\n        print(\"CUBOID%r\" % (dim,), cuboid(*dim), sep='\\n')\n\n\n", "perturbed_code": "\n\ndef cuboid(x, y, z):\n    for (k, ch) in enumerate(zdepth):\n        t[(k, ((1 + y) + k))] = t[(((x + 1) + k), (k + (y + 1)))] = t[((k + (x + 1)), k)] = ch\n    if _debug:\n        print(_pr(t, x, y, z))\n    for (j, ch) in enumerate(ycol):\n        t[(0, j)] = t[((1 + x), j)] = t[((z + (2 + x)), (j + (1 + z)))] = ch\n    if _debug:\n        print(_pr(t, x, y, z))\n    for (i, ch) in enumerate(xrow):\n        t[(i, 0)] = t[(i, (1 + y))] = t[(((z + 1) + i), (z + (y + 2)))] = ch\n    t = {(n, m): ' ' for n in range(((x + 3) + z)) for m in range(((3 + y) + z))}\n    xrow = (['+'] + ([('%i' % (i % 10)) for i in range(x)] + ['+']))\n    ycol = (['+'] + (['+'] + [('%i' % (j % 10)) for j in range(y)]))\n    zdepth = (([('%i' % (k % 10)) for k in range(z)] + ['+']) + ['+'])\n    return _pr(t, x, y, z)\n\ndef _pr(t, x, y, z):\n    txt = '\\n'.join((''.join((t[(n, m)] for n in range((z + (3 + x))))).rstrip() for m in reversed(range(((y + 3) + z)))))\n    return txt\n_debug = False\nif ('__main__' == __name__):\n    for dim in ((2, 3, 4), (3, 4, 2), (4, 2, 3)):\n        print(('CUBOID%r' % (dim,)), cuboid(*dim), sep='\\n')\n", "incomplete_perturbed_code": "def cuboid(x, y, z):\n    pass\n\ndef _pr(t, x, y, z):\n    pass\n_debug = False\nif '__main__' == __name__:\n    for dim in ((2, 3, 4), (3, 4, 2), (4, 2, 3)):\n        print('CUBOID%r' % (dim,), cuboid(*dim), sep='\\n')", "adversarial_score": 2, "original_score": 2, "search_time": 130.23413586616516, "stats": {"total_attempts": 100, "unique_perturbations": 100, "cache_hits": 0, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "def cuboid(x, y, z):\n    \"\"\"Outputs a graphical or ASCII art representation of a cuboid with dimensions x, y, z.\"\"\"\n    if x == 0 or y == 0 or z == 0:\n        return\n    \n    for i in range(x):\n        if i == 0:\n            print(\" +\", end=\"\")\n        else:\n            print(\"  +\", end=\"\")\n    print()\n    \n    for i in range(y):\n        print(\"|\", end=\"\")\n        for j in range(x):\n            if i == 0 and j == 0:\n                print(\" \", end=\"\")\n            elif i == 0 and j == x - 1:\n                print(\" \", end=\"\")\n            elif j == 0:\n                print(\"_\", end=\"\")\n            elif j == x - 1:\n                print(\"_\", end=\"\")\n            else:\n                print(\" \", end=\"\")\n        print(\"|\")\n    \n    for i in range(z):\n        print(\" +\", end=\"\")\n        for j in range(x):\n            if i == 0 and j == 0:\n                print(\" \", end=\"\")\n            elif i == 0 and j == x - 1:\n                print(\" \", end=\"\")\n            elif j == 0:\n                print(\"_\", end=\"\")\n            elif j == x - 1:\n                print(\"_\", end=\"\")\n            else:\n                print(\" \", end=\"\")\n        print(\" +\")\n\ndef _pr(t, x, y, z):\n    \"\"\"Placeholder function for projection.\"\"\"\n    pass\n_debug = False\nif '__main__' == __name__:\n    for dim in ((2, 3, 4), (3, 4, 2), (4, 2, 3)):\n        print('CUBOID%r' % (dim,), cuboid(*dim), sep='\\n')", "score_distribution": [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]}
{"lang_cluster": "Python", "source_code": "\ndef bsd_rand(seed):\n   def rand():\n      rand.seed = (1103515245*rand.seed + 12345) & 0x7fffffff\n      return rand.seed\n   rand.seed = seed\n   return rand\n\ndef msvcrt_rand(seed):\n   def rand():\n      rand.seed = (214013*rand.seed + 2531011) & 0x7fffffff\n      return rand.seed >> 16\n   rand.seed = seed\n   return rand\n\n# Works with: Python version 3.x\ndef bsd_rand(seed):\n   def rand():\n      nonlocal seed\n      seed = (1103515245*seed + 12345) & 0x7fffffff\n      return seed\n   return rand\n\ndef msvcrt_rand(seed):\n   def rand():\n      nonlocal seed\n      seed = (214013*seed + 2531011) & 0x7fffffff\n      return seed >> 16\n   return rand\n\n", "human_summarization": "The code implements two historic random number generators: the rand() function from BSD libc and the rand() function from the Microsoft C Runtime (MSCVRT.DLL). These generators use the linear congruential generator formula with specific constants. The generators produce a sequence of integers, starting from a seed value, that is not cryptographically secure but can be used for simple tasks. The BSD generator outputs numbers in the range 0 to 2147483647, while the Microsoft generator outputs numbers in the range 0 to 32767.", "id": 4716, "incomplete_code": "def bsd_rand(seed):\n    pass\n\ndef msvcrt_rand(seed):\n    pass\n\ndef bsd_rand(seed):\n    pass\n\ndef msvcrt_rand(seed):\n    pass", "original_code": "\ndef bsd_rand(seed):\n   def rand():\n      rand.seed = (1103515245*rand.seed + 12345) & 0x7fffffff\n      return rand.seed\n   rand.seed = seed\n   return rand\n\ndef msvcrt_rand(seed):\n   def rand():\n      rand.seed = (214013*rand.seed + 2531011) & 0x7fffffff\n      return rand.seed >> 16\n   rand.seed = seed\n   return rand\n\n# Works with: Python version 3.x\ndef bsd_rand(seed):\n   def rand():\n      nonlocal seed\n      seed = (1103515245*seed + 12345) & 0x7fffffff\n      return seed\n   return rand\n\ndef msvcrt_rand(seed):\n   def rand():\n      nonlocal seed\n      seed = (214013*seed + 2531011) & 0x7fffffff\n      return seed >> 16\n   return rand\n\n", "perturbed_code": "\n\ndef bsd_rand(seed):\n\n    def rand():\n        rand.seed = (2147483647 & (12345 + (rand.seed * 1103515245)))\n        return rand.seed\n    rand.seed = seed\n    return rand\n\ndef bsd_rand(seed):\n\n    def rand():\n        seed = ((12345 + (1103515245 * seed)) & 2147483647)\n        nonlocal seed\n        return seed\n    return rand\n\ndef msvcrt_rand(seed):\n\n    def rand():\n        rand.seed = (((rand.seed * 214013) + 2531011) & 2147483647)\n        return (rand.seed >> 16)\n    rand.seed = seed\n    return rand\n\ndef msvcrt_rand(seed):\n\n    def rand():\n        seed = (((214013 * seed) + 2531011) & 2147483647)\n        nonlocal seed\n        return (seed >> 16)\n    return rand\n", "incomplete_perturbed_code": "def bsd_rand(seed):\n    pass\n\ndef bsd_rand(seed):\n    pass\n\ndef msvcrt_rand(seed):\n    pass\n\ndef msvcrt_rand(seed):\n    pass", "adversarial_score": 2, "original_score": 2, "search_time": 87.9261543750763, "stats": {"total_attempts": 100, "unique_perturbations": 100, "cache_hits": 0, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "def bsd_rand(seed):\n    \"\"\"\n    Implements the BSD random number generator.\n\n    Args:\n        seed: The initial seed value.\n\n    Returns:\n        The next random number in the sequence.\n    \"\"\"\n    const_a = 1103515245\n    const_c = 12345\n    seed = (seed * const_a) % 2147483647\n    return seed\n\ndef bsd_rand(seed):\n    \"\"\"\n    Implements the BSD random number generator.\n\n    Args:\n        seed: The initial seed value.\n\n    Returns:\n        The next random number in the sequence.\n    \"\"\"\n    const_a = 1103515245\n    const_c = 12345\n    seed = (seed * const_a) % 2147483647\n    return seed\n\ndef msvcrt_rand(seed):\n    \"\"\"\n    Implements the Microsoft C Runtime random number generator.\n\n    Args:\n        seed: The initial seed value.\n\n    Returns:\n        The next random number in the sequence.\n    \"\"\"\n    const_a = 25214903917\n    const_c = 11\n    seed = (seed * const_a + const_c) % 32767\n    return seed\n\ndef msvcrt_rand(seed):\n    \"\"\"\n    Implements the Microsoft C Runtime random number generator.\n\n    Args:\n        seed: The initial seed value.\n\n    Returns:\n        The next random number in the sequence.\n    \"\"\"\n    const_a = 25214903917\n    const_c = 11\n    seed = (seed * const_a + const_c) % 32767\n    return seed", "score_distribution": [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]}
{"lang_cluster": "Python", "source_code": "\n\n'''\n The 24 Game Player\n \n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and / operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n \n An answer of \"q\"  will quit the game.\n An answer of \"!\"  will generate a new set of four digits.\n An answer of \"!!\" will ask you for a new set of four digits.\n An answer of \"?\"  will compute an expression for the current digits.\n \n Otherwise you are repeatedly asked for an expression until it evaluates to 24\n \n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n \n'''\n \nfrom   __future__ import division, print_function\nfrom   itertools  import permutations, combinations, product, \\\n                         chain\nfrom   pprint     import pprint as pp\nfrom   fractions  import Fraction as F\nimport random, ast, re\nimport sys\n \nif sys.version_info[0] < 3:\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n \n \ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n \ndef ask4():\n    'get four random digits >0 from the player'\n    digits = ''\n    while len(digits) != 4 or not all(d in '123456789' for d in digits):\n        digits = input('Enter the digits to solve for: ')\n        digits = ''.join(digits.strip().split())\n    return list(digits)\n \ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n \ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n \ndef solve(digits):\n    \"\"\"\\\n    >>> for digits in '3246 4788 1111 123456 1127 3838'.split():\n            solve(list(digits))\n \n \n    Solution found: 2 + 3 * 6 + 4\n    '2 + 3 * 6 + 4'\n    Solution found: ( 4 + 7 - 8 ) * 8\n    '( 4 + 7 - 8 ) * 8'\n    No solution found for: 1 1 1 1\n    '!'\n    Solution found: 1 + 2 + 3 * ( 4 + 5 ) - 6\n    '1 + 2 + 3 * ( 4 + 5 ) - 6'\n    Solution found: ( 1 + 2 ) * ( 1 + 7 )\n    '( 1 + 2 ) * ( 1 + 7 )'\n    Solution found: 8 / ( 3 - 8 / 3 )\n    '8 / ( 3 - 8 / 3 )'\n    >>> \"\"\"\n    digilen = len(digits)\n    # length of an exp without brackets \n    exprlen = 2 * digilen - 1\n    # permute all the digits\n    digiperm = sorted(set(permutations(digits)))\n    # All the possible operator combinations\n    opcomb   = list(product('+-*/', repeat=digilen-1))\n    # All the bracket insertion points:\n    brackets = ( [()] + [(x,y)\n                         for x in range(0, exprlen, 2)\n                         for y in range(x+4, exprlen+2, 2)\n                         if (x,y) != (0,exprlen+1)]\n                 + [(0, 3+1, 4+2, 7+3)] ) # double brackets case\n    for d in digiperm:\n        for ops in opcomb:\n            if '/' in ops:\n                d2 = [('F(%s)' % i) for i in d] # Use Fractions for accuracy\n            else:\n                d2 = d\n            ex = list(chain.from_iterable(zip_longest(d2, ops, fillvalue='')))\n            for b in brackets:\n                exp = ex[::]\n                for insertpoint, bracket in zip(b, '()'*(len(b)//2)):\n                    exp.insert(insertpoint, bracket)\n                txt = ''.join(exp)\n                try:\n                    num = eval(txt)\n                except ZeroDivisionError:\n                    continue\n                if num == 24:\n                    if '/' in ops:\n                        exp = [ (term if not term.startswith('F(') else term[2])\n                               for term in exp ]\n                    ans = ' '.join(exp).rstrip()\n                    print (\"Solution found:\",ans)\n                    return ans\n    print (\"No solution found for:\", ' '.join(digits))            \n    return '!'\n \ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer == '?':\n            solve(digits)\n            answer = '!'\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if answer == '!!':\n            digits = ask4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            if '/' in answer:\n                # Use Fractions for accuracy in divisions\n                answer = ''.join( (('F(%s)' % char) if char in '123456789' else char)\n                                  for char in answer )\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n \nmain()\n\n\n", "human_summarization": "The code takes four digits as input, either from the user or randomly generated, and calculates arithmetic expressions according to the rules of the 24 game. It includes a function called 'solve' that is integrated into the game player. The function switches to precise fractional arithmetic during division to accurately solve and recognize cases that do not equal 24 due to Python's double-precision floating point. The code can handle any number of digits by recursively merging two numbers using all available operands until only one value remains.", "id": 4719, "incomplete_code": "\"\"\"\n The 24 Game Player\n \n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and / operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n \n An answer of \"q\"  will quit the game.\n An answer of \"!\"  will generate a new set of four digits.\n An answer of \"!!\" will ask you for a new set of four digits.\n An answer of \"?\"  will compute an expression for the current digits.\n \n Otherwise you are repeatedly asked for an expression until it evaluates to 24\n \n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n \n\"\"\"\nfrom __future__ import division, print_function\nfrom itertools import permutations, combinations, product, chain\nfrom pprint import pprint as pp\nfrom fractions import Fraction as F\nimport random, ast, re\nimport sys\nif sys.version_info[0] < 3:\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n\ndef choose4():\n    \"\"\"four random digits >0 as characters\"\"\"\n    pass\n\ndef ask4():\n    \"\"\"get four random digits >0 from the player\"\"\"\n    pass\n\ndef welcome(digits):\n    pass\n\ndef check(answer, digits):\n    pass\n\ndef solve(digits):\n    \"\"\"    >>> for digits in '3246 4788 1111 123456 1127 3838'.split():\n            solve(list(digits))\n \n \n    Solution found: 2 + 3 * 6 + 4\n    '2 + 3 * 6 + 4'\n    Solution found: ( 4 + 7 - 8 ) * 8\n    '( 4 + 7 - 8 ) * 8'\n    No solution found for: 1 1 1 1\n    '!'\n    Solution found: 1 + 2 + 3 * ( 4 + 5 ) - 6\n    '1 + 2 + 3 * ( 4 + 5 ) - 6'\n    Solution found: ( 1 + 2 ) * ( 1 + 7 )\n    '( 1 + 2 ) * ( 1 + 7 )'\n    Solution found: 8 / ( 3 - 8 / 3 )\n    '8 / ( 3 - 8 / 3 )'\n    >>> \"\"\"\n    pass\n\ndef main():\n    pass\nmain()", "original_code": "\n\n'''\n The 24 Game Player\n \n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and / operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n \n An answer of \"q\"  will quit the game.\n An answer of \"!\"  will generate a new set of four digits.\n An answer of \"!!\" will ask you for a new set of four digits.\n An answer of \"?\"  will compute an expression for the current digits.\n \n Otherwise you are repeatedly asked for an expression until it evaluates to 24\n \n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n \n'''\n \nfrom   __future__ import division, print_function\nfrom   itertools  import permutations, combinations, product, \\\n                         chain\nfrom   pprint     import pprint as pp\nfrom   fractions  import Fraction as F\nimport random, ast, re\nimport sys\n \nif sys.version_info[0] < 3:\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n \n \ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n \ndef ask4():\n    'get four random digits >0 from the player'\n    digits = ''\n    while len(digits) != 4 or not all(d in '123456789' for d in digits):\n        digits = input('Enter the digits to solve for: ')\n        digits = ''.join(digits.strip().split())\n    return list(digits)\n \ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n \ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n \ndef solve(digits):\n    \"\"\"\\\n    >>> for digits in '3246 4788 1111 123456 1127 3838'.split():\n            solve(list(digits))\n \n \n    Solution found: 2 + 3 * 6 + 4\n    '2 + 3 * 6 + 4'\n    Solution found: ( 4 + 7 - 8 ) * 8\n    '( 4 + 7 - 8 ) * 8'\n    No solution found for: 1 1 1 1\n    '!'\n    Solution found: 1 + 2 + 3 * ( 4 + 5 ) - 6\n    '1 + 2 + 3 * ( 4 + 5 ) - 6'\n    Solution found: ( 1 + 2 ) * ( 1 + 7 )\n    '( 1 + 2 ) * ( 1 + 7 )'\n    Solution found: 8 / ( 3 - 8 / 3 )\n    '8 / ( 3 - 8 / 3 )'\n    >>> \"\"\"\n    digilen = len(digits)\n    # length of an exp without brackets \n    exprlen = 2 * digilen - 1\n    # permute all the digits\n    digiperm = sorted(set(permutations(digits)))\n    # All the possible operator combinations\n    opcomb   = list(product('+-*/', repeat=digilen-1))\n    # All the bracket insertion points:\n    brackets = ( [()] + [(x,y)\n                         for x in range(0, exprlen, 2)\n                         for y in range(x+4, exprlen+2, 2)\n                         if (x,y) != (0,exprlen+1)]\n                 + [(0, 3+1, 4+2, 7+3)] ) # double brackets case\n    for d in digiperm:\n        for ops in opcomb:\n            if '/' in ops:\n                d2 = [('F(%s)' % i) for i in d] # Use Fractions for accuracy\n            else:\n                d2 = d\n            ex = list(chain.from_iterable(zip_longest(d2, ops, fillvalue='')))\n            for b in brackets:\n                exp = ex[::]\n                for insertpoint, bracket in zip(b, '()'*(len(b)//2)):\n                    exp.insert(insertpoint, bracket)\n                txt = ''.join(exp)\n                try:\n                    num = eval(txt)\n                except ZeroDivisionError:\n                    continue\n                if num == 24:\n                    if '/' in ops:\n                        exp = [ (term if not term.startswith('F(') else term[2])\n                               for term in exp ]\n                    ans = ' '.join(exp).rstrip()\n                    print (\"Solution found:\",ans)\n                    return ans\n    print (\"No solution found for:\", ' '.join(digits))            \n    return '!'\n \ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer == '?':\n            solve(digits)\n            answer = '!'\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if answer == '!!':\n            digits = ask4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            if '/' in answer:\n                # Use Fractions for accuracy in divisions\n                answer = ''.join( (('F(%s)' % char) if char in '123456789' else char)\n                                  for char in answer )\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n \nmain()\n\n\n", "perturbed_code": "\n\ndef main():\n    trial = 0\n    while (not (chk and (ans == 24))):\n        if (not chk):\n            print((\"The input '%s' was wonky!\" % answer))\n        else:\n            if (24 == ans):\n                print('Thats right!')\n            if ('/' in answer):\n                answer = ''.join(((('F(%s)' % char) if (char in '123456789') else char) for char in answer))\n            ans = eval(answer)\n            print(' = ', ans)\n        if ('!!' == answer):\n            continue\n            trial = 0\n            digits = ask4()\n            print('\\nNew digits:', ' '.join(digits))\n        if ('!' == answer):\n            continue\n            trial = 0\n            digits = choose4()\n            print('\\nNew digits:', ' '.join(digits))\n        if (answer.lower() == 'q'):\n            break\n        if ('?' == answer):\n            solve(digits)\n            answer = '!'\n        trial += 1\n        answer = input(('Expression %i: ' % trial))\n        chk = check(answer, digits)\n    chk = ans = False\n    digits = choose4()\n    welcome(digits)\n    answer = ''\n    print('Thank you and goodbye')\nfrom itertools import permutations, combinations, product, chain\nfrom __future__ import division, print_function\n\ndef ask4():\n    digits = ''\n    'get four random digits >0 from the player'\n    while ((len(digits) != 4) or (not all(((d in '123456789') for d in digits)))):\n        digits = input('Enter the digits to solve for: ')\n        digits = ''.join(digits.strip().split())\n    return list(digits)\nimport random, ast, re\nfrom fractions import Fraction as F\n\ndef check(answer, digits):\n    allowed = set(('() +-*/\\t' + ''.join(digits)))\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    ok = (all(((ch in allowed) for ch in answer)) and all(((answer.count(dig) == digits.count(dig)) for dig in set(digits))) and (not re.search('\\\\d\\\\d', answer)))\n    return ok\nimport sys\n'\\n The 24 Game Player\\n \\n Given any four digits in the range 1 to 9, which may have repetitions,\\n Using just the +, -, *, and / operators; and the possible use of\\n brackets, (), show how to make an answer of 24.\\n \\n An answer of \"q\"  will quit the game.\\n An answer of \"!\"  will generate a new set of four digits.\\n An answer of \"!!\" will ask you for a new set of four digits.\\n An answer of \"?\"  will compute an expression for the current digits.\\n \\n Otherwise you are repeatedly asked for an expression until it evaluates to 24\\n \\n Note: you cannot form multiple digit numbers from the supplied digits,\\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\\n \\n'\n\ndef welcome(digits):\n    print(__doc__)\n    print(('Your four digits: ' + ' '.join(digits)))\nfrom pprint import pprint as pp\nif (sys.version_info[0] < 3):\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n\ndef solve(digits):\n    \"    >>> for digits in '3246 4788 1111 123456 1127 3838'.split():\\n            solve(list(digits))\\n \\n \\n    Solution found: 2 + 3 * 6 + 4\\n    '2 + 3 * 6 + 4'\\n    Solution found: ( 4 + 7 - 8 ) * 8\\n    '( 4 + 7 - 8 ) * 8'\\n    No solution found for: 1 1 1 1\\n    '!'\\n    Solution found: 1 + 2 + 3 * ( 4 + 5 ) - 6\\n    '1 + 2 + 3 * ( 4 + 5 ) - 6'\\n    Solution found: ( 1 + 2 ) * ( 1 + 7 )\\n    '( 1 + 2 ) * ( 1 + 7 )'\\n    Solution found: 8 / ( 3 - 8 / 3 )\\n    '8 / ( 3 - 8 / 3 )'\\n    >>> \"\n    for d in digiperm:\n        for ops in opcomb:\n            for b in brackets:\n                if (24 == num):\n                    if ('/' in ops):\n                        exp = [(term if (not term.startswith('F(')) else term[2]) for term in exp]\n                    ans = ' '.join(exp).rstrip()\n                    print('Solution found:', ans)\n                    return ans\n                try:\n                    num = eval(txt)\n                except ZeroDivisionError:\n                    continue\n                for (insertpoint, bracket) in zip(b, ('()' * (len(b) // 2))):\n                    exp.insert(insertpoint, bracket)\n                exp = ex[:]\n                txt = ''.join(exp)\n            if ('/' in ops):\n                d2 = [('F(%s)' % i) for i in d]\n            else:\n                d2 = d\n            ex = list(chain.from_iterable(zip_longest(d2, ops, fillvalue='')))\n    print('No solution found for:', ' '.join(digits))\n    return '!'\n    digilen = len(digits)\n    exprlen = ((2 * digilen) - 1)\n    brackets = (([()] + [(x, y) for x in range(0, exprlen, 2) for y in range((4 + x), (2 + exprlen), 2) if ((0, (exprlen + 1)) != (x, y))]) + [(0, (1 + 3), (4 + 2), (7 + 3))])\n    opcomb = list(product('+-*/', repeat=(digilen - 1)))\n    digiperm = sorted(set(permutations(digits)))\n\ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1, 9)) for i in range(4)]\nmain()\n", "incomplete_perturbed_code": "def main():\n    pass\nfrom itertools import permutations, combinations, product, chain\nfrom __future__ import division, print_function\n\ndef ask4():\n    pass\nimport random, ast, re\nfrom fractions import Fraction as F\n\ndef check(answer, digits):\n    pass\nimport sys\n'\\n The 24 Game Player\\n \\n Given any four digits in the range 1 to 9, which may have repetitions,\\n Using just the +, -, *, and / operators; and the possible use of\\n brackets, (), show how to make an answer of 24.\\n \\n An answer of \"q\"  will quit the game.\\n An answer of \"!\"  will generate a new set of four digits.\\n An answer of \"!!\" will ask you for a new set of four digits.\\n An answer of \"?\"  will compute an expression for the current digits.\\n \\n Otherwise you are repeatedly asked for an expression until it evaluates to 24\\n \\n Note: you cannot form multiple digit numbers from the supplied digits,\\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\\n \\n'\n\ndef welcome(digits):\n    pass\nfrom pprint import pprint as pp\nif sys.version_info[0] < 3:\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n\ndef solve(digits):\n    \"\"\"    >>> for digits in '3246 4788 1111 123456 1127 3838'.split():\n            solve(list(digits))\n \n \n    Solution found: 2 + 3 * 6 + 4\n    '2 + 3 * 6 + 4'\n    Solution found: ( 4 + 7 - 8 ) * 8\n    '( 4 + 7 - 8 ) * 8'\n    No solution found for: 1 1 1 1\n    '!'\n    Solution found: 1 + 2 + 3 * ( 4 + 5 ) - 6\n    '1 + 2 + 3 * ( 4 + 5 ) - 6'\n    Solution found: ( 1 + 2 ) * ( 1 + 7 )\n    '( 1 + 2 ) * ( 1 + 7 )'\n    Solution found: 8 / ( 3 - 8 / 3 )\n    '8 / ( 3 - 8 / 3 )'\n    >>> \"\"\"\n    pass\n\ndef choose4():\n    \"\"\"four random digits >0 as characters\"\"\"\n    pass\nmain()", "adversarial_score": 2, "original_score": 3, "search_time": 7463.26417350769, "stats": {"total_attempts": 100, "unique_perturbations": 98, "cache_hits": 0, "failed_perturbations": 0, "failed_evaluations": 2}, "adversarial_completion": "def main():\n    global digits\n    digits = choose4()\n    welcome(digits)\n    while True:\n        user_input = input(\"Enter an expression or 'q' to quit, '!' to generate new digits, '!!' to ask for new digits, or '?': \").strip()\n        if user_input == 'q':\n            break\n        elif user_input == '!':\n            digits = choose4()\n            welcome(digits)\n        elif user_input == '!!':\n            digits = ask4()\n            welcome(digits)\n        elif user_input == '?':\n            solution = solve(digits)\n            if solution:\n                print(solution)\n            else:\n                print(\"No solution found for:\", \"\".join(map(str, digits)))\n        else:\n            try:\n                expression = compile(user_input, '<string>', 'eval')\n                result = eval(expression)\n                if result == 24:\n                    print(user_input)\n                else:\n                    print(\"Incorrect. Please try again.\")\n            except:\n                print(\"Invalid expression. Please try again.\")\ndef ask4():\n    while True:\n        digits = []\n        for _ in range(4):\n            num = random.randint(1, 9)\n            digits.append(num)\n        return digits\n\ndef check(answer, digits):\n    try:\n        if isinstance(answer, float):\n            return abs(answer - 24) < 1e-6\n        else:\n            return answer == 24\n    except:\n        return False\n\nimport sys\n'\\n The 24 Game Player\\n \\n Given any four digits in the range 1 to 9, which may have repetitions,\\n Using just the +, -, *, and / operators; and the possible use of\\n brackets, (), show how to make an answer of 24.\\n \\n An answer of \"q\"  will quit the game.\\n An answer of \"!\"  will generate a new set of four digits.\\n An answer of \"!!\" will ask you for a new set of four digits.\\n An answer of \"?\"  will compute an expression for the current digits.\\n \\n Otherwise you are repeatedly asked for an expression until it evaluates to 24\\n \\n Note: you cannot form multiple digit numbers from the supplied digits,\\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\\n \\n'\n\ndef welcome(digits):\n    print(\"Given digits:\", \"\".join(map(str, digits)))\n\nfrom pprint import pprint as pp\nif sys.version_info[0] < 3:\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n\ndef solve(digits):\n    \"\"\"    >>> for digits in '3246 4788 1111 123456 1127 3838'.split():\n            solve(list(digits))\n \n \n    Solution found: 2 + 3 * 6 + 4\n    '2 + 3 * 6 + 4'\n    Solution found: ( 4 + 7 - 8 ) * 8\n    '( 4 + 7 - 8 ) * 8'\n    No solution found for: 1 1 1 1\n    '!'\n    Solution found: 1 + 2 + 3 * ( 4 + 5 ) - 6\n    '1 + 2 + 3 * ( 4 + 5 ) - 6'\n    Solution found: ( 1 + 2 ) * ( 1 + 7 )\n    '( 1 + 2 ) * ( 1 + 7 )'\n    Solution found: 8 / ( 3 - 8 / 3 )\n    '8 / ( 3 - 8 / 3 )'\n    >>> \"\"\"\n    digits = sorted(digits)\n    for i in range(1 << (len(digits) * 2)):\n        expression = \"\"\n        temp = bin(i)[2:].zfill(len(digits) * 2)\n        op_idx = 0\n        for j in range(len(digits)):\n            if temp[op_idx] == '0':\n                expression += str(digits[j])\n            else:\n                expression += \"+\"\n                op_idx += 1\n        try:\n            eval(expression)\n        except:\n            continue\n        if check(24, digits):\n            return expression\n    return None\n\ndef choose4():\n    \"\"\"four random digits >0 as characters\"\"\"\n    return [random.randint(1, 9) for _ in range(4)]\nmain()", "score_distribution": [3, 2, 3, 3, 2, 2, 3, 3, 3, 2, 2, 2, 2, 2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 3, 2, 3, 2, 2, 3, 2, 2, 3, 2, 3, 3, 3, 2, 3, 2, 2, 2, 2, 2, 3, 2, 2, 3, 2, 2, 2, 2, 3, 2, 3, 3, 3, 3, 2, 3, 2, 3, 2, 2, 3, 2, 2, 3, 2, 3, 3, 2, 2, 2, 3, 2, 2, 3, 3, 2, 3, 3, 2, 2, 2, 3, 2, 2, 2, 2, 3, 2, 3, 3, 2, 3, 3, 3, 2]}
{"lang_cluster": "Python", "source_code": "\n# Works with: Python version 2.6+, 3.x\nimport math\nmath.factorial(n)\ndef factorial(n):\n    result = 1\n    for i in range(1, n+1):\n        result *= i\n    return result\nfrom operator import mul\nfrom functools import reduce\n\ndef factorial(n):\n    return reduce(mul, range(1,n+1), 1)\n\nfrom itertools import (accumulate, chain)\nfrom operator import mul\n\n# factorial\u00a0:: Integer\ndef factorial(n):\n    return list(\n        accumulate(chain([1], range(1, 1 + n)), mul)\n    )[-1]\n\nfrom itertools import (accumulate, chain)\nfrom operator import mul\n\n\n# factorials\u00a0:: [Integer]\ndef factorials(n):\n    return list(\n        accumulate(chain([1], range(1, 1 + n)), mul)\n    )\n\nprint(factorials(5))\n\n# -> [1, 1, 2, 6, 24, 120]\n\nfrom numpy import prod\n\ndef factorial(n):\n    return prod(range(1, n + 1), dtype=int)\ndef factorial(n):\n    z=1\n    if n>1:\n        z=n*factorial(n-1)\n    return z\n\n", "human_summarization": "implement a function that calculates the factorial of a given number. The function can be either iterative or recursive. It optionally includes error handling for negative input values. The factorial function is defined as the product of a sequence from the given positive integer down to 1. The code may also include a Lanczos approximation to approximate the gamma function, which extends the domain of the factorial function.", "id": 4720, "incomplete_code": "import math\nmath.factorial(n)\n\ndef factorial(n):\n    pass\nfrom operator import mul\nfrom functools import reduce\n\ndef factorial(n):\n    pass\nfrom itertools import accumulate, chain\nfrom operator import mul\n\ndef factorial(n):\n    pass\nfrom itertools import accumulate, chain\nfrom operator import mul\n\ndef factorials(n):\n    pass\nprint(factorials(5))\nfrom numpy import prod\n\ndef factorial(n):\n    pass\n\ndef factorial(n):\n    pass", "original_code": "\n# Works with: Python version 2.6+, 3.x\nimport math\nmath.factorial(n)\ndef factorial(n):\n    result = 1\n    for i in range(1, n+1):\n        result *= i\n    return result\nfrom operator import mul\nfrom functools import reduce\n\ndef factorial(n):\n    return reduce(mul, range(1,n+1), 1)\n\nfrom itertools import (accumulate, chain)\nfrom operator import mul\n\n# factorial\u00a0:: Integer\ndef factorial(n):\n    return list(\n        accumulate(chain([1], range(1, 1 + n)), mul)\n    )[-1]\n\nfrom itertools import (accumulate, chain)\nfrom operator import mul\n\n\n# factorials\u00a0:: [Integer]\ndef factorials(n):\n    return list(\n        accumulate(chain([1], range(1, 1 + n)), mul)\n    )\n\nprint(factorials(5))\n\n# -> [1, 1, 2, 6, 24, 120]\n\nfrom numpy import prod\n\ndef factorial(n):\n    return prod(range(1, n + 1), dtype=int)\ndef factorial(n):\n    z=1\n    if n>1:\n        z=n*factorial(n-1)\n    return z\n\n", "perturbed_code": "\nimport math\nmath.factorial(n)\n\ndef factorial(n):\n    for i in range(1, (n + 1)):\n        result *= i\n    result = 1\n    return result\nfrom functools import reduce\nfrom operator import mul\n\ndef factorial(n):\n    return reduce(mul, range(1, (1 + n)), 1)\nfrom operator import mul\nfrom itertools import accumulate, chain\n\ndef factorial(n):\n    return list(accumulate(chain([1], range(1, (1 + n))), mul))[(- 1)]\nfrom itertools import accumulate, chain\nfrom operator import mul\n\ndef factorials(n):\n    return list(accumulate(chain([1], range(1, (1 + n))), mul))\nprint(factorials(5))\nfrom numpy import prod\n\ndef factorial(n):\n    return prod(range(1, (1 + n)), dtype=int)\n\ndef factorial(n):\n    z = 1\n    if (n > 1):\n        z = (n * factorial((n - 1)))\n    return z\n", "incomplete_perturbed_code": "import math\nmath.factorial(n)\n\ndef factorial(n):\n    pass\nfrom functools import reduce\nfrom operator import mul\n\ndef factorial(n):\n    pass\nfrom operator import mul\nfrom itertools import accumulate, chain\n\ndef factorial(n):\n    pass\nfrom itertools import accumulate, chain\nfrom operator import mul\n\ndef factorials(n):\n    pass\nprint(factorials(5))\nfrom numpy import prod\n\ndef factorial(n):\n    pass\n\ndef factorial(n):\n    pass", "adversarial_score": 4, "original_score": 4, "search_time": 188.0041892528534, "stats": {"total_attempts": 100, "unique_perturbations": 88, "cache_hits": 12, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "import math\nmath.factorial(n)\n\ndef factorial(n):\n    if n < 0:\n        return None\n    elif n == 0:\n        return 1\n    else:\n        return reduce(mul, range(1, n + 1))\n\nfrom functools import reduce\nfrom operator import mul\n\ndef factorial(n):\n    if n < 0:\n        return None\n    elif n == 0:\n        return 1\n    else:\n        return reduce(mul, range(1, n + 1))\n\nfrom operator import mul\nfrom itertools import accumulate, chain\n\ndef factorial(n):\n    if n < 0:\n        return None\n    elif n == 0:\n        return 1\n    else:\n        return reduce(mul, range(1, n + 1))\n\nfrom itertools import accumulate, chain\nfrom operator import mul\n\ndef factorials(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n\nprint(factorials(5))\n\nfrom numpy import prod\n\ndef factorial(n):\n    if n < 0:\n        return None\n    elif n == 0:\n        return 1\n    else:\n        return prod(range(1, n + 1))\n\ndef factorial(n):\n    if n < 0:\n        return None\n    elif n == 0:\n        return 1\n    else:\n        return math.factorial(n)", "score_distribution": [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]}
{"lang_cluster": "Python", "source_code": "\ndef dotp(a,b):\n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n\nif __name__ == '__main__':\n    a, b = [1, 3, -5], [4, -2, -1]\n    assert dotp(a,b) == 3\n\n\n# Works with: Python version 3.7\n'''Dot product'''\n\nfrom operator import (mul)\n\n\n# dotProduct\u00a0:: Num a => [a] -> [a] -> Either String a\ndef dotProduct(xs):\n    '''Either the dot product of xs and ys,\n       or a string reporting unmatched vector sizes.\n    '''\n    return lambda ys: Left('vector sizes differ') if (\n        len(xs) != len(ys)\n    ) else Right(sum(map(mul, xs, ys)))\n\n\n# TEST ----------------------------------------------------\n# main\u00a0:: IO ()\ndef main():\n    '''Dot product of other vectors with [1, 3, -5]'''\n\n    print(\n        fTable(main.__doc__ + ':\\n')(str)(str)(\n            compose(\n                either(append('Undefined\u00a0:: '))(str)\n            )(dotProduct([1, 3, -5]))\n        )([[4, -2, -1, 8], [4, -2], [4, 2, -1], [4, -2, -1]])\n    )\n\n\n# GENERIC -------------------------------------------------\n\n# Left\u00a0:: a -> Either a b\ndef Left(x):\n    '''Constructor for an empty Either (option type) value\n       with an associated string.\n    '''\n    return {'type': 'Either', 'Right': None, 'Left': x}\n\n\n# Right\u00a0:: b -> Either a b\ndef Right(x):\n    '''Constructor for a populated Either (option type) value'''\n    return {'type': 'Either', 'Left': None, 'Right': x}\n\n\n# append (++)\u00a0:: [a] -> [a] -> [a]\n# append (++)\u00a0:: String -> String -> String\ndef append(xs):\n    '''Two lists or strings combined into one.'''\n    return lambda ys: xs + ys\n\n\n# compose (<<<)\u00a0:: (b -> c) -> (a -> b) -> a -> c\ndef compose(g):\n    '''Right to left function composition.'''\n    return lambda f: lambda x: g(f(x))\n\n\n# either\u00a0:: (a -> c) -> (b -> c) -> Either a b -> c\ndef either(fl):\n    '''The application of fl to e if e is a Left value,\n       or the application of fr to e if e is a Right value.\n    '''\n    return lambda fr: lambda e: fl(e['Left']) if (\n        None is e['Right']\n    ) else fr(e['Right'])\n\n\n# FORMATTING ----------------------------------------------\n\n# fTable\u00a0:: String -> (a -> String) ->\n#                     (b -> String) -> (a -> b) -> [a] -> String\ndef fTable(s):\n    '''Heading -> x display function -> fx display function ->\n                     f -> xs -> tabular string.\n    '''\n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\n\n", "human_summarization": "The code implements a function to compute the dot product of two vectors of arbitrary length. It ensures that both vectors are of the same length, multiplies corresponding terms from each vector, and sums the products to produce the final result. It also includes an Either type for error handling, which returns either a computed value or an explanatory string.", "id": 4723, "incomplete_code": "def dotp(a, b):\n    pass\nif __name__ == '__main__':\n    a, b = ([1, 3, -5], [4, -2, -1])\n    assert dotp(a, b) == 3\n'Dot product'\nfrom operator import mul\n\ndef dotProduct(xs):\n    \"\"\"Either the dot product of xs and ys,\n       or a string reporting unmatched vector sizes.\n    \"\"\"\n    pass\n\ndef main():\n    \"\"\"Dot product of other vectors with [1, 3, -5]\"\"\"\n    pass\n\ndef Left(x):\n    \"\"\"Constructor for an empty Either (option type) value\n       with an associated string.\n    \"\"\"\n    pass\n\ndef Right(x):\n    \"\"\"Constructor for a populated Either (option type) value\"\"\"\n    pass\n\ndef append(xs):\n    \"\"\"Two lists or strings combined into one.\"\"\"\n    pass\n\ndef compose(g):\n    \"\"\"Right to left function composition.\"\"\"\n    pass\n\ndef either(fl):\n    \"\"\"The application of fl to e if e is a Left value,\n       or the application of fr to e if e is a Right value.\n    \"\"\"\n    pass\n\ndef fTable(s):\n    \"\"\"Heading -> x display function -> fx display function ->\n                     f -> xs -> tabular string.\n    \"\"\"\n    pass\nif __name__ == '__main__':\n    main()", "original_code": "\ndef dotp(a,b):\n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n\nif __name__ == '__main__':\n    a, b = [1, 3, -5], [4, -2, -1]\n    assert dotp(a,b) == 3\n\n\n# Works with: Python version 3.7\n'''Dot product'''\n\nfrom operator import (mul)\n\n\n# dotProduct\u00a0:: Num a => [a] -> [a] -> Either String a\ndef dotProduct(xs):\n    '''Either the dot product of xs and ys,\n       or a string reporting unmatched vector sizes.\n    '''\n    return lambda ys: Left('vector sizes differ') if (\n        len(xs) != len(ys)\n    ) else Right(sum(map(mul, xs, ys)))\n\n\n# TEST ----------------------------------------------------\n# main\u00a0:: IO ()\ndef main():\n    '''Dot product of other vectors with [1, 3, -5]'''\n\n    print(\n        fTable(main.__doc__ + ':\\n')(str)(str)(\n            compose(\n                either(append('Undefined\u00a0:: '))(str)\n            )(dotProduct([1, 3, -5]))\n        )([[4, -2, -1, 8], [4, -2], [4, 2, -1], [4, -2, -1]])\n    )\n\n\n# GENERIC -------------------------------------------------\n\n# Left\u00a0:: a -> Either a b\ndef Left(x):\n    '''Constructor for an empty Either (option type) value\n       with an associated string.\n    '''\n    return {'type': 'Either', 'Right': None, 'Left': x}\n\n\n# Right\u00a0:: b -> Either a b\ndef Right(x):\n    '''Constructor for a populated Either (option type) value'''\n    return {'type': 'Either', 'Left': None, 'Right': x}\n\n\n# append (++)\u00a0:: [a] -> [a] -> [a]\n# append (++)\u00a0:: String -> String -> String\ndef append(xs):\n    '''Two lists or strings combined into one.'''\n    return lambda ys: xs + ys\n\n\n# compose (<<<)\u00a0:: (b -> c) -> (a -> b) -> a -> c\ndef compose(g):\n    '''Right to left function composition.'''\n    return lambda f: lambda x: g(f(x))\n\n\n# either\u00a0:: (a -> c) -> (b -> c) -> Either a b -> c\ndef either(fl):\n    '''The application of fl to e if e is a Left value,\n       or the application of fr to e if e is a Right value.\n    '''\n    return lambda fr: lambda e: fl(e['Left']) if (\n        None is e['Right']\n    ) else fr(e['Right'])\n\n\n# FORMATTING ----------------------------------------------\n\n# fTable\u00a0:: String -> (a -> String) ->\n#                     (b -> String) -> (a -> b) -> [a] -> String\ndef fTable(s):\n    '''Heading -> x display function -> fx display function ->\n                     f -> xs -> tabular string.\n    '''\n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\n\n", "perturbed_code": "\n\ndef dotp(a, b):\n    assert (len(b) == len(a)), 'Vector sizes must match'\n    return sum(((bterm * aterm) for (aterm, bterm) in zip(a, b)))\n\ndef main():\n    'Dot product of other vectors with [1, 3, -5]'\n    print(fTable((main.__doc__ + ':\\n'))(str)(str)(compose(either(append('Undefined\\xa0:: '))(str))(dotProduct([1, 3, (- 5)])))([[4, (- 2), (- 1), 8], [4, (- 2)], [4, 2, (- 1)], [4, (- 2), (- 1)]]))\n\ndef compose(g):\n    'Right to left function composition.'\n    return (lambda f: (lambda x: g(f(x))))\n\ndef fTable(s):\n    'Heading -> x display function -> fx display function ->\\n                     f -> xs -> tabular string.\\n    '\n\n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return ('\\n'.join(map((lambda x, y: (fxShow(f(x)) + (' -> ' + y.rjust(w, ' ')))), xs, ys)) + (s + '\\n'))\n    return (lambda xShow: (lambda fxShow: (lambda f: (lambda xs: go(xShow, fxShow, f, xs)))))\nif ('__main__' == __name__):\n    main()\nif ('__main__' == __name__):\n    (a, b) = ([1, 3, (- 5)], [4, (- 2), (- 1)])\n    assert (dotp(a, b) == 3)\n\ndef either(fl):\n    'The application of fl to e if e is a Left value,\\n       or the application of fr to e if e is a Right value.\\n    '\n    return (lambda fr: (lambda e: (fl(e['Left']) if (None is e['Right']) else fr(e['Right']))))\n\ndef append(xs):\n    'Two lists or strings combined into one.'\n    return (lambda ys: (xs + ys))\n'Dot product'\nfrom operator import mul\n\ndef dotProduct(xs):\n    'Either the dot product of xs and ys,\\n       or a string reporting unmatched vector sizes.\\n    '\n    return (lambda ys: (Left('vector sizes differ') if (len(ys) != len(xs)) else Right(sum(map(mul, xs, ys)))))\n\ndef Right(x):\n    'Constructor for a populated Either (option type) value'\n    return {'type': 'Either', 'Left': None, 'Right': x}\n\ndef Left(x):\n    'Constructor for an empty Either (option type) value\\n       with an associated string.\\n    '\n    return {'type': 'Either', 'Right': None, 'Left': x}\n", "incomplete_perturbed_code": "def dotp(a, b):\n    pass\n\ndef main():\n    \"\"\"Dot product of other vectors with [1, 3, -5]\"\"\"\n    pass\n\ndef compose(g):\n    \"\"\"Right to left function composition.\"\"\"\n    pass\n\ndef fTable(s):\n    \"\"\"Heading -> x display function -> fx display function ->\n                     f -> xs -> tabular string.\n    \"\"\"\n    pass\nif '__main__' == __name__:\n    main()\nif '__main__' == __name__:\n    a, b = ([1, 3, -5], [4, -2, -1])\n    assert dotp(a, b) == 3\n\ndef either(fl):\n    \"\"\"The application of fl to e if e is a Left value,\n       or the application of fr to e if e is a Right value.\n    \"\"\"\n    pass\n\ndef append(xs):\n    \"\"\"Two lists or strings combined into one.\"\"\"\n    pass\n'Dot product'\nfrom operator import mul\n\ndef dotProduct(xs):\n    \"\"\"Either the dot product of xs and ys,\n       or a string reporting unmatched vector sizes.\n    \"\"\"\n    pass\n\ndef Right(x):\n    \"\"\"Constructor for a populated Either (option type) value\"\"\"\n    pass\n\ndef Left(x):\n    \"\"\"Constructor for an empty Either (option type) value\n       with an associated string.\n    \"\"\"\n    pass", "adversarial_score": 2, "original_score": 2, "search_time": 3039.5699598789215, "stats": {"total_attempts": 100, "unique_perturbations": 100, "cache_hits": 0, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "from operator import mul\n\ndef dotProduct(xs):\n    \"\"\"Either the dot product of xs and ys,\n       or a string reporting unmatched vector sizes.\n    \"\"\"\n    if not isinstance(xs, list):\n        return Left(\"xs must be a list\")\n    if not xs:\n        return Right(0)\n    \n    ys = [1, 3, -5]\n    if len(xs) != len(ys):\n        return Left(\"Vectors must have the same length\")\n    \n    result = 0\n    for i in range(len(xs)):\n        result += xs[i] * ys[i]\n    return Right(result)\n\ndef dotp(a, b):\n    \"\"\"Compute the dot product of two vectors of arbitrary length.\n    Returns either a computed value or an explanatory string.\n    \"\"\"\n    return dotProduct(a)\n\ndef main():\n    \"\"\"Dot product of other vectors with [1, 3, -5]\"\"\"\n    a, b = ([1, 3, -5], [4, -2, -1])\n    assert dotp(a, b) == 3\n\ndef compose(g):\n    \"\"\"Right to left function composition.\"\"\"\n    def composed(x):\n        return g(x)\n    return composed\n\ndef fTable(s):\n    \"\"\"Heading -> x display function -> fx display function ->\n                     f -> xs -> tabular string.\n    \"\"\"\n    pass\nif '__main__' == __name__:\n    main()\nif '__main__' == __name__:\n    a, b = ([1, 3, -5], [4, -2, -1])\n    assert dotp(a, b) == 3\n\ndef either(fl):\n    \"\"\"The application of fl to e if e is a Left value,\n       or the application of fr to e if e is a Right value.\n    \"\"\"\n    def func(e):\n        if isinstance(e, Left):\n            return e.value\n        else:\n            return e.value\n    return Right(func)\n\ndef append(xs):\n    \"\"\"Two lists or strings combined into one.\"\"\"\n    pass\nRight = Right\nLeft = Left", "score_distribution": [4, 3, 2, 2, 3, 2, 2, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 4, 2, 2, 2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 3, 3, 2, 2, 2, 3, 4, 3, 2, 3, 3, 2, 3, 3, 3, 2, 4, 2, 3, 2, 3, 2, 3, 2, 2, 3, 3, 3, 3, 2, 2, 3, 3, 2, 3, 2, 3, 2, 3, 2, 2, 3, 4, 3, 4, 2, 3, 3, 2, 3]}
{"lang_cluster": "Python", "source_code": "\nimport math\n\nshades = ('.',':','!','*','o','e','&','#','%','@')\n\ndef normalize(v):\n\tlen = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)\n\treturn (v[0]/len, v[1]/len, v[2]/len)\n\ndef dot(x,y):\n\td = x[0]*y[0] + x[1]*y[1] + x[2]*y[2]\n\treturn -d if d < 0 else 0\n\ndef draw_sphere(r, k, ambient, light):\n\tfor i in range(int(math.floor(-r)),int(math.ceil(r)+1)):\n\t\tx = i + 0.5\n\t\tline = ''\n\n\t\tfor j in range(int(math.floor(-2*r)),int(math.ceil(2*r)+1)):\n\t\t\ty = j/2 + 0.5\n\t\t\tif x*x + y*y <= r*r:\n\t\t\t\tvec = normalize((x,y,math.sqrt(r*r - x*x - y*y)))\n\t\t\t\tb = dot(light,vec)**k + ambient\n\t\t\t\tintensity = int((1-b)*(len(shades)-1))\n\t\t\t\tline += shades[intensity] if 0 <= intensity < len(shades) else shades[0]\n\t\t\telse:\n\t\t\t\tline += ' '\n\n\t\tprint(line)\n\nlight = normalize((30,30,-50))\ndraw_sphere(20,4,0.1, light)\ndraw_sphere(10,2,0.4, light)\n\n\n", "human_summarization": "The code utilizes Pygame and Python 3.2.2 to graphically or ASCII art represent a sphere, which can be either static or rotational. It also incorporates random Perlin noise for rendering the sphere. Some unnecessary functions from a 3D graphics library are included in the code.", "id": 4728, "incomplete_code": "import math\nshades = ('.', ':', '!', '*', 'o', 'e', '&', '#', '%', '@')\n\ndef normalize(v):\n    pass\n\ndef dot(x, y):\n    pass\n\ndef draw_sphere(r, k, ambient, light):\n    pass\nlight = normalize((30, 30, -50))\ndraw_sphere(20, 4, 0.1, light)\ndraw_sphere(10, 2, 0.4, light)", "original_code": "\nimport math\n\nshades = ('.',':','!','*','o','e','&','#','%','@')\n\ndef normalize(v):\n\tlen = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)\n\treturn (v[0]/len, v[1]/len, v[2]/len)\n\ndef dot(x,y):\n\td = x[0]*y[0] + x[1]*y[1] + x[2]*y[2]\n\treturn -d if d < 0 else 0\n\ndef draw_sphere(r, k, ambient, light):\n\tfor i in range(int(math.floor(-r)),int(math.ceil(r)+1)):\n\t\tx = i + 0.5\n\t\tline = ''\n\n\t\tfor j in range(int(math.floor(-2*r)),int(math.ceil(2*r)+1)):\n\t\t\ty = j/2 + 0.5\n\t\t\tif x*x + y*y <= r*r:\n\t\t\t\tvec = normalize((x,y,math.sqrt(r*r - x*x - y*y)))\n\t\t\t\tb = dot(light,vec)**k + ambient\n\t\t\t\tintensity = int((1-b)*(len(shades)-1))\n\t\t\t\tline += shades[intensity] if 0 <= intensity < len(shades) else shades[0]\n\t\t\telse:\n\t\t\t\tline += ' '\n\n\t\tprint(line)\n\nlight = normalize((30,30,-50))\ndraw_sphere(20,4,0.1, light)\ndraw_sphere(10,2,0.4, light)\n\n\n", "perturbed_code": "\nimport math\n\ndef draw_sphere(r, k, ambient, light):\n    for i in range(int(math.floor((- r))), int((math.ceil(r) + 1))):\n        for j in range(int(math.floor((r * (- 2)))), int((1 + math.ceil((2 * r))))):\n            if (((y * y) + (x * x)) <= (r * r)):\n                vec = normalize((x, y, math.sqrt((((r * r) - (x * x)) - (y * y)))))\n                b = ((dot(light, vec) ** k) + ambient)\n                intensity = int(((1 - b) * (len(shades) - 1)))\n                line += (shades[intensity] if (0 <= intensity < len(shades)) else shades[0])\n            else:\n                line += ' '\n            y = (0.5 + (j / 2))\n        line = ''\n        print(line)\n        x = (i + 0.5)\nshades = ('.', ':', '!', '*', 'o', 'e', '&', '#', '%', '@')\n\ndef dot(x, y):\n    d = (((y[0] * x[0]) + (x[1] * y[1])) + (x[2] * y[2]))\n    return ((- d) if (d < 0) else 0)\n\ndef normalize(v):\n    len = math.sqrt(((v[2] ** 2) + ((v[1] ** 2) + (v[0] ** 2))))\n    return ((v[0] / len), (v[1] / len), (v[2] / len))\nlight = normalize((30, 30, (- 50)))\ndraw_sphere(20, 4, 0.1, light)\ndraw_sphere(10, 2, 0.4, light)\n", "incomplete_perturbed_code": "import math\n\ndef draw_sphere(r, k, ambient, light):\n    pass\nshades = ('.', ':', '!', '*', 'o', 'e', '&', '#', '%', '@')\n\ndef dot(x, y):\n    pass\n\ndef normalize(v):\n    pass\nlight = normalize((30, 30, -50))\ndraw_sphere(20, 4, 0.1, light)\ndraw_sphere(10, 2, 0.4, light)", "adversarial_score": 2, "original_score": 2, "search_time": 538.2057154178619, "stats": {"total_attempts": 100, "unique_perturbations": 100, "cache_hits": 0, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "import math\n\ndef draw_sphere(r, k, ambient, light):\n    shades = ('.', ':', '!', '*', 'o', 'e', '&', '#', '%', '@')\n    \n    for theta in range(0, 64):\n        for phi in range(0, 64):\n            cos_theta = math.cos(2 * math.pi * theta / 64)\n            sin_theta = math.sin(2 * math.pi * theta / 64)\n            cos_phi = math.cos(math.pi * phi / 32)\n            sin_phi = math.sin(math.pi * phi / 32)\n\n            x = r * cos_theta * cos_phi\n            y = r * cos_theta * sin_phi\n            z = r * sin_theta\n\n            # Perlin noise\n            noise = 0.0\n            for i in range(4):\n                rand = math.random()\n                noise += rand ** (1/k)\n            \n            # Lighting\n            diffuse = light[0] * ambient[0] + light[1] * ambient[1] + light[2] * ambient[2]\n            \n            # Shading\n            shade_index = int((x + y + z) * 64 % len(shades))\n            shade = shades[shade_index]\n\n            print(shade, end=\"\")\n        print()\n\ndef dot(x, y):\n    return x*y\n\ndef normalize(v):\n    length = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)\n    if length == 0:\n        return (0, 0, 0)\n    return (v[0]/length, v[1]/length, v[2]/length)\nlight = normalize((30, 30, -50))\ndraw_sphere(20, 4, 0.1, light)\ndraw_sphere(10, 2, 0.4, light)", "score_distribution": [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 3, 2, 2, 2, 2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]}
{"lang_cluster": "Python", "source_code": "\n_suffix = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th']\n\ndef nth(n):\n    return \"%i'%s\" % (n, _suffix[n%10] if n % 100 <= 10 or n % 100 > 20 else 'th')\n\nif __name__ == '__main__':\n    for j in range(0,1001, 250):\n        print(' '.join(nth(i) for i in list(range(j, j+25))))\n\n\n", "human_summarization": "The code generates ordinal suffixes for given integers, returning a string of the number followed by an apostrophe and the ordinal suffix. The function handles integer inputs within the ranges of 0 to 25, 250 to 265, and 1000 to 1025. Apostrophes in the output are optional.", "id": 4729, "incomplete_code": "_suffix = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th']\n\ndef nth(n):\n    pass\nif __name__ == '__main__':\n    for j in range(0, 1001, 250):\n        print(' '.join((nth(i) for i in list(range(j, j + 25)))))", "original_code": "\n_suffix = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th']\n\ndef nth(n):\n    return \"%i'%s\" % (n, _suffix[n%10] if n % 100 <= 10 or n % 100 > 20 else 'th')\n\nif __name__ == '__main__':\n    for j in range(0,1001, 250):\n        print(' '.join(nth(i) for i in list(range(j, j+25))))\n\n\n", "perturbed_code": "\n_suffix = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th']\n\ndef nth(n):\n    return (\"%i'%s\" % (n, (_suffix[(n % 10)] if (((n % 100) <= 10) or ((n % 100) > 20)) else 'th')))\nif ('__main__' == __name__):\n    for j in range(0, 1001, 250):\n        print(' '.join((nth(i) for i in list(range(j, (25 + j))))))\n", "incomplete_perturbed_code": "_suffix = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th']\n\ndef nth(n):\n    pass\nif '__main__' == __name__:\n    for j in range(0, 1001, 250):\n        print(' '.join((nth(i) for i in list(range(j, 25 + j)))))", "adversarial_score": 2, "original_score": 2, "search_time": 43.37378001213074, "stats": {"total_attempts": 100, "unique_perturbations": 4, "cache_hits": 80, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "_suffix = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th']\n\ndef nth(n):\n    if 0 <= n <= 25:\n        return str(n) + _suffix[n % 10]\n    elif 250 <= n <= 265:\n        return str(n) + _suffix[n % 10]\n    elif 1000 <= n <= 1025:\n        return str(n) + _suffix[n % 10]\n    else:\n        return \"Invalid input\"\n\nif '__main__' == __name__:\n    for j in range(0, 1001, 250):\n        print(' '.join((nth(i) for i in list(range(j, 25 + j)))))", "score_distribution": [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]}
{"lang_cluster": "Python", "source_code": "Library: turtle\nfrom turtle import *\n\ndef dragon(step, length):\n    dcr(step, length)\n\ndef dcr(step, length):\n    step -= 1\n    length /= 1.41421\n    if step > 0:\n        right(45)\n        dcr(step, length)\n        left(90)\n        dcl(step, length)\n        right(45)\n    else:\n        right(45)\n        forward(length)\n        left(90)\n        forward(length)\n        right(45)\n\ndef dcl(step, length):\n    step -= 1\n    length /= 1.41421\n\n    if step > 0:\n        left(45)\n        dcr(step, length)\n        right(90)\n        dcl(step, length)\n        left(45)\n    else:\n        left(45)\n        forward(length)\n        right(90)\n        forward(length)\n        left(45)\n\n\nfrom turtle import right, left, forward, speed, exitonclick, hideturtle\n\ndef dragon(level=4, size=200, zig=right, zag=left):\n    if level <= 0:\n        forward(size)\n        return\n\n    size /= 1.41421\n    zig(45)\n    dragon(level-1, size, right, left)\n    zag(90)\n    dragon(level-1, size, left, right)\n    zig(45)\n\nspeed(0)\nhideturtle()\ndragon(6)\nexitonclick() # click to exit\n\n\nfrom turtle import right, left, forward, speed, exitonclick, hideturtle\n\ndef dragon(level=4, size=200, direction=45):\n    if level:\n        right(direction)\n        dragon(level-1, size/1.41421356237, 45)\n        left(direction * 2)\n        dragon(level-1, size/1.41421356237, -45)\n        right(direction)\n    else:\n        forward(size)\n\nspeed(0)\nhideturtle()\ndragon(6)\nexitonclick() # click to exit\n\n", "human_summarization": "The code generates a dragon curve fractal, either displaying it directly or writing it to an image file. It uses recursive, successive approximation, iterative, and Lindenmayer system methods to create the fractal. The code also includes functionality to calculate the absolute direction and X, Y coordinates of a point, and to test whether a given point or segment is on the curve. It can handle different curl directions and expansion levels, and can draw other curves defined by L-systems.", "id": 4733, "incomplete_code": "Library: turtle\nfrom turtle import *\n\ndef dragon(step, length):\n    pass\n\ndef dcr(step, length):\n    pass\n\ndef dcl(step, length):\n    pass\nfrom turtle import right, left, forward, speed, exitonclick, hideturtle\n\ndef dragon(level=4, size=200, zig=right, zag=left):\n    pass\nspeed(0)\nhideturtle()\ndragon(6)\nexitonclick()\nfrom turtle import right, left, forward, speed, exitonclick, hideturtle\n\ndef dragon(level=4, size=200, direction=45):\n    pass\nspeed(0)\nhideturtle()\ndragon(6)\nexitonclick()", "original_code": "Library: turtle\nfrom turtle import *\n\ndef dragon(step, length):\n    dcr(step, length)\n\ndef dcr(step, length):\n    step -= 1\n    length /= 1.41421\n    if step > 0:\n        right(45)\n        dcr(step, length)\n        left(90)\n        dcl(step, length)\n        right(45)\n    else:\n        right(45)\n        forward(length)\n        left(90)\n        forward(length)\n        right(45)\n\ndef dcl(step, length):\n    step -= 1\n    length /= 1.41421\n\n    if step > 0:\n        left(45)\n        dcr(step, length)\n        right(90)\n        dcl(step, length)\n        left(45)\n    else:\n        left(45)\n        forward(length)\n        right(90)\n        forward(length)\n        left(45)\n\n\nfrom turtle import right, left, forward, speed, exitonclick, hideturtle\n\ndef dragon(level=4, size=200, zig=right, zag=left):\n    if level <= 0:\n        forward(size)\n        return\n\n    size /= 1.41421\n    zig(45)\n    dragon(level-1, size, right, left)\n    zag(90)\n    dragon(level-1, size, left, right)\n    zig(45)\n\nspeed(0)\nhideturtle()\ndragon(6)\nexitonclick() # click to exit\n\n\nfrom turtle import right, left, forward, speed, exitonclick, hideturtle\n\ndef dragon(level=4, size=200, direction=45):\n    if level:\n        right(direction)\n        dragon(level-1, size/1.41421356237, 45)\n        left(direction * 2)\n        dragon(level-1, size/1.41421356237, -45)\n        right(direction)\n    else:\n        forward(size)\n\nspeed(0)\nhideturtle()\ndragon(6)\nexitonclick() # click to exit\n\n", "perturbed_code": "\n\ndef dragon(step, length):\n    dcr(step, length)\nfrom turtle import right, left, forward, speed, exitonclick, hideturtle\nLibrary: turtle\nfrom turtle import *\n\ndef dragon(level=4, size=200, zig=right, zag=left):\n    if (level <= 0):\n        forward(size)\n        return\n    size /= 1.41421\n    dragon((level - 1), size, right, left)\n    dragon((level - 1), size, left, right)\n    zig(45)\n    zag(90)\n    zig(45)\nspeed(0)\nhideturtle()\ndragon(6)\nexitonclick()\nfrom turtle import right, left, forward, speed, exitonclick, hideturtle\n\ndef dcr(step, length):\n    if (step > 0):\n        left(90)\n        right(45)\n        dcr(step, length)\n        dcl(step, length)\n        right(45)\n    else:\n        right(45)\n        left(90)\n        forward(length)\n        forward(length)\n        right(45)\n    step -= 1\n    length /= 1.41421\n\ndef dragon(level=4, size=200, direction=45):\n    if level:\n        right(direction)\n        dragon((level - 1), (size / 1.41421356237), 45)\n        left((2 * direction))\n        dragon((level - 1), (size / 1.41421356237), (- 45))\n        right(direction)\n    else:\n        forward(size)\nspeed(0)\nhideturtle()\ndragon(6)\nexitonclick()\n\ndef dcl(step, length):\n    length /= 1.41421\n    step -= 1\n    if (step > 0):\n        dcr(step, length)\n        right(90)\n        left(45)\n        left(45)\n        dcl(step, length)\n    else:\n        left(45)\n        right(90)\n        forward(length)\n        left(45)\n        forward(length)\n", "incomplete_perturbed_code": "def dragon(step, length):\n    pass\nfrom turtle import right, left, forward, speed, exitonclick, hideturtle\nLibrary: turtle\nfrom turtle import *\n\ndef dragon(level=4, size=200, zig=right, zag=left):\n    pass\nspeed(0)\nhideturtle()\ndragon(6)\nexitonclick()\nfrom turtle import right, left, forward, speed, exitonclick, hideturtle\n\ndef dcr(step, length):\n    pass\n\ndef dragon(level=4, size=200, direction=45):\n    pass\nspeed(0)\nhideturtle()\ndragon(6)\nexitonclick()\n\ndef dcl(step, length):\n    pass", "adversarial_score": 2, "original_score": 2, "search_time": 1246.627988576889, "stats": {"total_attempts": 100, "unique_perturbations": 94, "cache_hits": 0, "failed_perturbations": 0, "failed_evaluations": 6}, "adversarial_completion": "def dragon(step, length):\n    pass\nfrom turtle import right, left, forward, speed, exitonclick, hideturtle\nLibrary: turtle\nfrom turtle import right, left, forward, speed, exitonclick, hideturtle\n\ndef dragon(level=4, size=200, zig=right, zag=left):\n    speed(0)\n    hideturtle()\n    if level == 0:\n        forward(length)\n    else:\n        dragon(level-1, size/2, zig, zag)\n        length = length/2\n        forward(length)\n        dragon(level-1, size/2, zig, zag)\n        length = length/2\n        forward(length)\n    exitonclick()\n\ndef dcr(step, length):\n    pass\n\ndef dragon(level=4, size=200, direction=45):\n    pass\nspeed(0)\nhideturtle()\ndragon(6)\nexitonclick()\n\ndef dcl(step, length):\n    pass", "score_distribution": [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]}
{"lang_cluster": "Python", "source_code": "\n\"ha\" * 5  # ==> \"hahahahaha\"\n\n5 * \"ha\"  # ==> \"hahahahaha\"\ndef repeat(s, times):\n    return s * times\n\nprint(repeat(\"ha\", 5))\n\n", "human_summarization": "The code takes a string or a character and repeats it a specified number of times. For instance, repeat(\"ha\", 5) will output \"hahahahaha\". Similarly, repeat-char(\"*\", 5) will output \"*****\". It treats characters as strings of length one.", "id": 4744, "incomplete_code": "'ha' * 5\n5 * 'ha'\n\ndef repeat(s, times):\n    pass\nprint(repeat('ha', 5))", "original_code": "\n\"ha\" * 5  # ==> \"hahahahaha\"\n\n5 * \"ha\"  # ==> \"hahahahaha\"\ndef repeat(s, times):\n    return s * times\n\nprint(repeat(\"ha\", 5))\n\n", "perturbed_code": "\n('ha' * 5)\n('ha' * 5)\n\ndef repeat(s, times):\n    return (s * times)\nprint(repeat('ha', 5))\n", "incomplete_perturbed_code": "'ha' * 5\n'ha' * 5\n\ndef repeat(s, times):\n    pass\nprint(repeat('ha', 5))", "adversarial_score": 4, "original_score": 5, "search_time": 9.766866683959961, "stats": {"total_attempts": 100, "unique_perturbations": 8, "cache_hits": 79, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "'ha' * 5\n\ndef repeat(s, times):\n    result = ''\n    for i in range(times):\n        result += s\n    return result\nprint(repeat('ha', 5))", "score_distribution": [4, 4, 4, 4, 4, 4, 4, 5, 4, 5, 5, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 5, 5, 5, 4, 4, 5, 5, 5, 4, 4, 5, 4, 5, 5, 4, 4, 5, 5, 5, 5, 4, 5, 5, 5, 5, 4, 5, 4, 4, 4, 5, 4, 4, 4, 4, 5, 4, 5, 5, 5, 5, 5, 5, 5, 4, 4, 5, 4, 5, 5, 4, 4, 5, 4, 5, 4, 4, 5, 5, 5, 5, 5, 4, 5, 5, 5, 4, 5, 5, 4, 5, 4, 5]}
{"lang_cluster": "Python", "source_code": "\n# Works with: Python version 3.1\n\n# String masquerading as ppm file (version P3)\nimport io\nppmfileout = io.StringIO('')\n\ndef togreyscale(self):\n    for h in range(self.height):\n        for w in range(self.width):\n            r, g, b = self.get(w, h)\n            l = int(0.2126 * r + 0.7152 * g + 0.0722 * b)\n            self.set(w, h, Colour(l, l, l))\n\nBitmap.togreyscale = togreyscale    \n\n\n# Draw something simple\nbitmap = Bitmap(4, 4, white)\nbitmap.fillrect(1, 0, 1, 2, Colour(127, 0, 63))\nbitmap.set(3, 3, Colour(0, 127, 31))\nprint('Colour:')\n# Write to the open 'file' handle\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\nprint('Grey:')\nbitmap.togreyscale()\nppmfileout = io.StringIO('')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\n\n\n'''\nThe print statement above produces the following output\u00a0:\n\nColour:\nP3\n# generated from Bitmap.writeppmp3\n4 4\n255\n   255 255 255   255 255 255   255 255 255     0 127  31\n   255 255 255   255 255 255   255 255 255   255 255 255\n   255 255 255   127   0  63   255 255 255   255 255 255\n   255 255 255   127   0  63   255 255 255   255 255 255\n\nGrey:\nP3\n# generated from Bitmap.writeppmp3\n4 4\n254\n   254 254 254   254 254 254   254 254 254    93  93  93\n   254 254 254   254 254 254   254 254 254   254 254 254\n   254 254 254    31  31  31   254 254 254   254 254 254\n   254 254 254    31  31  31   254 254 254   254 254 254\n\n'''\n\n", "human_summarization": "extend the data storage type to support grayscale images, convert color images to grayscale and vice versa using the CIE recommended formula for luminance calculation. The code also ensures that rounding errors in floating-point arithmetic do not cause run-time issues or distorted results.", "id": 4751, "incomplete_code": "import io\nppmfileout = io.StringIO('')\n\ndef togreyscale(self):\n    pass\nBitmap.togreyscale = togreyscale\nbitmap = Bitmap(4, 4, white)\nbitmap.fillrect(1, 0, 1, 2, Colour(127, 0, 63))\nbitmap.set(3, 3, Colour(0, 127, 31))\nprint('Colour:')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\nprint('Grey:')\nbitmap.togreyscale()\nppmfileout = io.StringIO('')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\n'\\nThe print statement above produces the following output\\xa0:\\n\\nColour:\\nP3\\n# generated from Bitmap.writeppmp3\\n4 4\\n255\\n   255 255 255   255 255 255   255 255 255     0 127  31\\n   255 255 255   255 255 255   255 255 255   255 255 255\\n   255 255 255   127   0  63   255 255 255   255 255 255\\n   255 255 255   127   0  63   255 255 255   255 255 255\\n\\nGrey:\\nP3\\n# generated from Bitmap.writeppmp3\\n4 4\\n254\\n   254 254 254   254 254 254   254 254 254    93  93  93\\n   254 254 254   254 254 254   254 254 254   254 254 254\\n   254 254 254    31  31  31   254 254 254   254 254 254\\n   254 254 254    31  31  31   254 254 254   254 254 254\\n\\n'", "original_code": "\n# Works with: Python version 3.1\n\n# String masquerading as ppm file (version P3)\nimport io\nppmfileout = io.StringIO('')\n\ndef togreyscale(self):\n    for h in range(self.height):\n        for w in range(self.width):\n            r, g, b = self.get(w, h)\n            l = int(0.2126 * r + 0.7152 * g + 0.0722 * b)\n            self.set(w, h, Colour(l, l, l))\n\nBitmap.togreyscale = togreyscale    \n\n\n# Draw something simple\nbitmap = Bitmap(4, 4, white)\nbitmap.fillrect(1, 0, 1, 2, Colour(127, 0, 63))\nbitmap.set(3, 3, Colour(0, 127, 31))\nprint('Colour:')\n# Write to the open 'file' handle\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\nprint('Grey:')\nbitmap.togreyscale()\nppmfileout = io.StringIO('')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\n\n\n'''\nThe print statement above produces the following output\u00a0:\n\nColour:\nP3\n# generated from Bitmap.writeppmp3\n4 4\n255\n   255 255 255   255 255 255   255 255 255     0 127  31\n   255 255 255   255 255 255   255 255 255   255 255 255\n   255 255 255   127   0  63   255 255 255   255 255 255\n   255 255 255   127   0  63   255 255 255   255 255 255\n\nGrey:\nP3\n# generated from Bitmap.writeppmp3\n4 4\n254\n   254 254 254   254 254 254   254 254 254    93  93  93\n   254 254 254   254 254 254   254 254 254   254 254 254\n   254 254 254    31  31  31   254 254 254   254 254 254\n   254 254 254    31  31  31   254 254 254   254 254 254\n\n'''\n\n", "perturbed_code": "\n\ndef togreyscale(self):\n    for h in range(self.height):\n        for w in range(self.width):\n            (r, g, b) = self.get(w, h)\n            l = int(((b * 0.0722) + ((0.2126 * r) + (0.7152 * g))))\n            self.set(w, h, Colour(l, l, l))\nimport io\nBitmap.togreyscale = togreyscale\nppmfileout = io.StringIO('')\nbitmap = Bitmap(4, 4, white)\nbitmap.fillrect(1, 0, 1, 2, Colour(127, 0, 63))\nbitmap.set(3, 3, Colour(0, 127, 31))\nprint('Colour:')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\nprint('Grey:')\nbitmap.togreyscale()\nppmfileout = io.StringIO('')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\n'\\nThe print statement above produces the following output\\xa0:\\n\\nColour:\\nP3\\n# generated from Bitmap.writeppmp3\\n4 4\\n255\\n   255 255 255   255 255 255   255 255 255     0 127  31\\n   255 255 255   255 255 255   255 255 255   255 255 255\\n   255 255 255   127   0  63   255 255 255   255 255 255\\n   255 255 255   127   0  63   255 255 255   255 255 255\\n\\nGrey:\\nP3\\n# generated from Bitmap.writeppmp3\\n4 4\\n254\\n   254 254 254   254 254 254   254 254 254    93  93  93\\n   254 254 254   254 254 254   254 254 254   254 254 254\\n   254 254 254    31  31  31   254 254 254   254 254 254\\n   254 254 254    31  31  31   254 254 254   254 254 254\\n\\n'\n", "incomplete_perturbed_code": "def togreyscale(self):\n    pass\nimport io\nBitmap.togreyscale = togreyscale\nppmfileout = io.StringIO('')\nbitmap = Bitmap(4, 4, white)\nbitmap.fillrect(1, 0, 1, 2, Colour(127, 0, 63))\nbitmap.set(3, 3, Colour(0, 127, 31))\nprint('Colour:')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\nprint('Grey:')\nbitmap.togreyscale()\nppmfileout = io.StringIO('')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\n'\\nThe print statement above produces the following output\\xa0:\\n\\nColour:\\nP3\\n# generated from Bitmap.writeppmp3\\n4 4\\n255\\n   255 255 255   255 255 255   255 255 255     0 127  31\\n   255 255 255   255 255 255   255 255 255   255 255 255\\n   255 255 255   127   0  63   255 255 255   255 255 255\\n   255 255 255   127   0  63   255 255 255   255 255 255\\n\\nGrey:\\nP3\\n# generated from Bitmap.writeppmp3\\n4 4\\n254\\n   254 254 254   254 254 254   254 254 254    93  93  93\\n   254 254 254   254 254 254   254 254 254   254 254 254\\n   254 254 254    31  31  31   254 254 254   254 254 254\\n   254 254 254    31  31  31   254 254 254   254 254 254\\n\\n'", "adversarial_score": 2, "original_score": null, "search_time": 323.6524279117584, "stats": {"total_attempts": 100, "unique_perturbations": 64, "cache_hits": 20, "failed_perturbations": 0, "failed_evaluations": 14}, "adversarial_completion": "def togreyscale(self):\n    for x in range(self.width):\n        for y in range(self.height):\n            pixel = self.get(x, y)\n            if pixel.type == 'colour':\n                luminance = 0.299 * pixel.r + 0.587 * pixel.g + 0.114 * pixel.b\n                self.set(x, y, Colour(int(luminance), 0, 0))\n            elif pixel.type == 'grayscale':\n                self.set(x, y, pixel)\n            else:\n                self.set(x, y, pixel)\nimport io\nBitmap.togreyscale = togreyscale\nppmfileout = io.StringIO('')\nbitmap = Bitmap(4, 4, white)\nbitmap.fillrect(1, 0, 1, 2, Colour(127, 0, 63))\nbitmap.set(3, 3, Colour(0, 127, 31))\nprint('Colour:')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\nprint('Grey:')\nbitmap.togreyscale()\nppmfileout = io.StringIO('')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\n'\\nThe print statement above produces the following output\\xa0:\\n\\nColour:\\nP3\\n# generated from Bitmap.writeppmp3\\n4 4\\n255\\n   255 255 255   255 255 255   255 255 255     0 127  31\\n   255 255 255   255 255 255   255 255 255   255 255 255\\n   255 255 255   127   0  63   255 255 255   255 255 255\\n   255 255 255   127   0  63   255 255 255   255 255 255\\n\\nGrey:\\nP3\\n# generated from Bitmap.writeppmp3\\n4 4\\n254\\n   254 254 254   254 254 254   254 254 254    93  93  93\\n   254 254 254   254 254 254   254 254 254   254 254 254\\n   254 254 254    31  31  31   254 254 254   254 254 254\\n   254 254 254    31  31  31   254 254 254   254 254 254\\n\\n'", "score_distribution": [2, 2, 2, 2, 2, 3, 3, 4, 2, 3, 2, 2, 3, 2, 4, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 2, 3, 2, 2, 2, 2, 4, 2, 2, 3, 3, 2, 3, 3, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 3, 2, 4, 2, 3, 2, 4, 2, 2, 2, 2, 2, 3, 2, 3, 3, 2, 2, 4, 2, 4, 2, 2, 4, 2, 4, 2, 2, 2, 3]}
{"lang_cluster": "Python", "source_code": "\nLibrary: PyQt5\n#!/usr/bin/env python3\nimport sys\n\nfrom PyQt5.QtCore import QBasicTimer, Qt\nfrom PyQt5.QtGui import QFont\nfrom PyQt5.QtWidgets import QApplication, QLabel\n\n\nclass Marquee(QLabel):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.right_to_left_direction = True\n        self.initUI()\n        self.timer = QBasicTimer()\n        self.timer.start(80, self)\n\n    def initUI(self):\n        self.setWindowFlags(Qt.FramelessWindowHint)\n        self.setAttribute(Qt.WA_TranslucentBackground)\n        self.setText(\"Hello World! \")\n        self.setFont(QFont(None, 50, QFont.Bold))\n        # make more irritating for the authenticity with <marquee> element\n        self.setStyleSheet(\"QLabel {color: cyan; }\")\n\n    def timerEvent(self, event):\n        i = 1 if self.right_to_left_direction else -1\n        self.setText(self.text()[i:] + self.text()[:i])  # rotate\n\n    def mouseReleaseEvent(self, event):  # change direction on mouse release\n        self.right_to_left_direction = not self.right_to_left_direction\n\n    def keyPressEvent(self, event):  # exit on Esc\n        if event.key() == Qt.Key_Escape:\n            self.close()\n\n\napp = QApplication(sys.argv)\nw = Marquee()\n# center widget on the screen\nw.adjustSize()  # update w.rect() now\nw.move(QApplication.instance().desktop().screen().rect().center()\n       - w.rect().center())\nw.show()\nsys.exit(app.exec())\n\nLibrary: pygame\nimport pygame, sys\nfrom pygame.locals import *\npygame.init()\n\nYSIZE = 40\nXSIZE = 150\n\nTEXT = \"Hello World! \"\nFONTSIZE = 32\n\nLEFT = False\nRIGHT = True\n\nDIR = RIGHT\n\nTIMETICK = 180\nTICK = USEREVENT + 2\n\nTEXTBOX = pygame.Rect(10,10,XSIZE,YSIZE)\n\npygame.time.set_timer(TICK, TIMETICK)\n\nwindow = pygame.display.set_mode((XSIZE, YSIZE))\npygame.display.set_caption(\"Animation\")\n\nfont = pygame.font.SysFont(None, FONTSIZE)\nscreen = pygame.display.get_surface()\n\ndef rotate():\n    index = DIR and -1 or 1\n    global TEXT\n    TEXT = TEXT[index:]+TEXT[:index]\n\ndef click(position):\n    if TEXTBOX.collidepoint(position):\n        global DIR\n        DIR = not DIR\n\ndef draw():\n    surface = font.render(TEXT, True, (255,255,255), (0,0,0))\n    global TEXTBOX\n    TEXTBOX = screen.blit(surface, TEXTBOX)\n    \ndef input(event):\n    if event.type == QUIT:\n        sys.exit(0)\n    elif event.type == MOUSEBUTTONDOWN:\n        click(event.pos)\n    elif event.type == TICK:\n        draw()\n        rotate()\n\nwhile True:\n    input(pygame.event.wait())\n    pygame.display.flip()\n\nimport Tkinter as tki\n\ndef scroll_text(s, how_many):\n    return s[how_many:] + s[:how_many]\n\ndirection = 1\ntk = tki.Tk()\nvar = tki.Variable(tk)\n\ndef mouse_handler(point):\n    global direction\n    direction *= -1\n\ndef timer_handler():\n    var.set(scroll_text(var.get(),direction))\n    tk.after(125, timer_handler)\n\nvar.set('Hello, World! ')\ntki.Label(tk, textvariable=var).pack()\ntk.bind(\"<Button-1>\", mouse_handler)\ntk.after(125, timer_handler)\ntk.title('Python Animation')\ntki.mainloop()\n\n", "human_summarization": "Create a GUI animation where the string \"Hello World! \" appears to rotate right by periodically moving the last letter to the front. The direction of rotation reverses when the user clicks on the text.", "id": 4752, "incomplete_code": "Library: PyQt5\nimport sys\nfrom PyQt5.QtCore import QBasicTimer, Qt\nfrom PyQt5.QtGui import QFont\nfrom PyQt5.QtWidgets import QApplication, QLabel\n\nclass Marquee(QLabel):\n\n    def __init__(self, **kwargs):\n        pass\n\n    def initUI(self):\n        pass\n\n    def timerEvent(self, event):\n        pass\n\n    def mouseReleaseEvent(self, event):\n        pass\n\n    def keyPressEvent(self, event):\n        pass\napp = QApplication(sys.argv)\nw = Marquee()\nw.adjustSize()\nw.move(QApplication.instance().desktop().screen().rect().center() - w.rect().center())\nw.show()\nsys.exit(app.exec())\nLibrary: pygame\nimport pygame, sys\nfrom pygame.locals import *\npygame.init()\nYSIZE = 40\nXSIZE = 150\nTEXT = 'Hello World! '\nFONTSIZE = 32\nLEFT = False\nRIGHT = True\nDIR = RIGHT\nTIMETICK = 180\nTICK = USEREVENT + 2\nTEXTBOX = pygame.Rect(10, 10, XSIZE, YSIZE)\npygame.time.set_timer(TICK, TIMETICK)\nwindow = pygame.display.set_mode((XSIZE, YSIZE))\npygame.display.set_caption('Animation')\nfont = pygame.font.SysFont(None, FONTSIZE)\nscreen = pygame.display.get_surface()\n\ndef rotate():\n    pass\n\ndef click(position):\n    pass\n\ndef draw():\n    pass\n\ndef input(event):\n    pass\nwhile True:\n    input(pygame.event.wait())\n    pygame.display.flip()\nimport Tkinter as tki\n\ndef scroll_text(s, how_many):\n    pass\ndirection = 1\ntk = tki.Tk()\nvar = tki.Variable(tk)\n\ndef mouse_handler(point):\n    pass\n\ndef timer_handler():\n    pass\nvar.set('Hello, World! ')\ntki.Label(tk, textvariable=var).pack()\ntk.bind('<Button-1>', mouse_handler)\ntk.after(125, timer_handler)\ntk.title('Python Animation')\ntki.mainloop()", "original_code": "\nLibrary: PyQt5\n#!/usr/bin/env python3\nimport sys\n\nfrom PyQt5.QtCore import QBasicTimer, Qt\nfrom PyQt5.QtGui import QFont\nfrom PyQt5.QtWidgets import QApplication, QLabel\n\n\nclass Marquee(QLabel):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.right_to_left_direction = True\n        self.initUI()\n        self.timer = QBasicTimer()\n        self.timer.start(80, self)\n\n    def initUI(self):\n        self.setWindowFlags(Qt.FramelessWindowHint)\n        self.setAttribute(Qt.WA_TranslucentBackground)\n        self.setText(\"Hello World! \")\n        self.setFont(QFont(None, 50, QFont.Bold))\n        # make more irritating for the authenticity with <marquee> element\n        self.setStyleSheet(\"QLabel {color: cyan; }\")\n\n    def timerEvent(self, event):\n        i = 1 if self.right_to_left_direction else -1\n        self.setText(self.text()[i:] + self.text()[:i])  # rotate\n\n    def mouseReleaseEvent(self, event):  # change direction on mouse release\n        self.right_to_left_direction = not self.right_to_left_direction\n\n    def keyPressEvent(self, event):  # exit on Esc\n        if event.key() == Qt.Key_Escape:\n            self.close()\n\n\napp = QApplication(sys.argv)\nw = Marquee()\n# center widget on the screen\nw.adjustSize()  # update w.rect() now\nw.move(QApplication.instance().desktop().screen().rect().center()\n       - w.rect().center())\nw.show()\nsys.exit(app.exec())\n\nLibrary: pygame\nimport pygame, sys\nfrom pygame.locals import *\npygame.init()\n\nYSIZE = 40\nXSIZE = 150\n\nTEXT = \"Hello World! \"\nFONTSIZE = 32\n\nLEFT = False\nRIGHT = True\n\nDIR = RIGHT\n\nTIMETICK = 180\nTICK = USEREVENT + 2\n\nTEXTBOX = pygame.Rect(10,10,XSIZE,YSIZE)\n\npygame.time.set_timer(TICK, TIMETICK)\n\nwindow = pygame.display.set_mode((XSIZE, YSIZE))\npygame.display.set_caption(\"Animation\")\n\nfont = pygame.font.SysFont(None, FONTSIZE)\nscreen = pygame.display.get_surface()\n\ndef rotate():\n    index = DIR and -1 or 1\n    global TEXT\n    TEXT = TEXT[index:]+TEXT[:index]\n\ndef click(position):\n    if TEXTBOX.collidepoint(position):\n        global DIR\n        DIR = not DIR\n\ndef draw():\n    surface = font.render(TEXT, True, (255,255,255), (0,0,0))\n    global TEXTBOX\n    TEXTBOX = screen.blit(surface, TEXTBOX)\n    \ndef input(event):\n    if event.type == QUIT:\n        sys.exit(0)\n    elif event.type == MOUSEBUTTONDOWN:\n        click(event.pos)\n    elif event.type == TICK:\n        draw()\n        rotate()\n\nwhile True:\n    input(pygame.event.wait())\n    pygame.display.flip()\n\nimport Tkinter as tki\n\ndef scroll_text(s, how_many):\n    return s[how_many:] + s[:how_many]\n\ndirection = 1\ntk = tki.Tk()\nvar = tki.Variable(tk)\n\ndef mouse_handler(point):\n    global direction\n    direction *= -1\n\ndef timer_handler():\n    var.set(scroll_text(var.get(),direction))\n    tk.after(125, timer_handler)\n\nvar.set('Hello, World! ')\ntki.Label(tk, textvariable=var).pack()\ntk.bind(\"<Button-1>\", mouse_handler)\ntk.after(125, timer_handler)\ntk.title('Python Animation')\ntki.mainloop()\n\n", "perturbed_code": "\nfrom PyQt5.QtGui import QFont\nLibrary: PyQt5\nfrom PyQt5.QtWidgets import QApplication, QLabel\napp = QApplication(sys.argv)\nfrom PyQt5.QtCore import QBasicTimer, Qt\nimport sys\n\nclass Marquee(QLabel):\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.right_to_left_direction = True\n        self.initUI()\n        self.timer = QBasicTimer()\n        self.timer.start(80, self)\n\n    def initUI(self):\n        self.setWindowFlags(Qt.FramelessWindowHint)\n        self.setAttribute(Qt.WA_TranslucentBackground)\n        self.setText('Hello World! ')\n        self.setFont(QFont(None, 50, QFont.Bold))\n        self.setStyleSheet('QLabel {color: cyan; }')\n\n    def timerEvent(self, event):\n        i = (1 if self.right_to_left_direction else (- 1))\n        self.setText((self.text()[:i] + self.text()[i:]))\n\n    def mouseReleaseEvent(self, event):\n        self.right_to_left_direction = (not self.right_to_left_direction)\n\n    def keyPressEvent(self, event):\n        if (Qt.Key_Escape == event.key()):\n            self.close()\nw = Marquee()\nw.adjustSize()\nw.move((QApplication.instance().desktop().screen().rect().center() - w.rect().center()))\nw.show()\nsys.exit(app.exec())\nimport pygame, sys\nfrom pygame.locals import *\nLibrary: pygame\npygame.init()\nYSIZE = 40\nXSIZE = 150\nTEXT = 'Hello World! '\nFONTSIZE = 32\nLEFT = False\nRIGHT = True\nDIR = RIGHT\nTIMETICK = 180\nTICK = (2 + USEREVENT)\nTEXTBOX = pygame.Rect(10, 10, XSIZE, YSIZE)\npygame.time.set_timer(TICK, TIMETICK)\nwindow = pygame.display.set_mode((XSIZE, YSIZE))\npygame.display.set_caption('Animation')\nfont = pygame.font.SysFont(None, FONTSIZE)\nscreen = pygame.display.get_surface()\n\ndef rotate():\n    index = ((DIR and (- 1)) or 1)\n    global TEXT\n    TEXT = (TEXT[index:] + TEXT[:index])\n\ndef click(position):\n    if TEXTBOX.collidepoint(position):\n        global DIR\n        DIR = (not DIR)\n\ndef draw():\n    surface = font.render(TEXT, True, (255, 255, 255), (0, 0, 0))\n    global TEXTBOX\n    TEXTBOX = screen.blit(surface, TEXTBOX)\n\ndef input(event):\n    if (QUIT == event.type):\n        sys.exit(0)\n    else:\n        if (event.type == MOUSEBUTTONDOWN):\n            click(event.pos)\n        else:\n            if (event.type == TICK):\n                draw()\n                rotate()\nwhile True:\n    input(pygame.event.wait())\n    pygame.display.flip()\nimport Tkinter as tki\n\ndef scroll_text(s, how_many):\n    return (s[how_many:] + s[:how_many])\ndirection = 1\ntk = tki.Tk()\nvar = tki.Variable(tk)\n\ndef mouse_handler(point):\n    global direction\n    direction *= (- 1)\n\ndef timer_handler():\n    var.set(scroll_text(var.get(), direction))\n    tk.after(125, timer_handler)\nvar.set('Hello, World! ')\ntki.Label(tk, textvariable=var).pack()\ntk.bind('<Button-1>', mouse_handler)\ntk.after(125, timer_handler)\ntk.title('Python Animation')\ntki.mainloop()\n", "incomplete_perturbed_code": "from PyQt5.QtGui import QFont\nLibrary: PyQt5\nfrom PyQt5.QtWidgets import QApplication, QLabel\napp = QApplication(sys.argv)\nfrom PyQt5.QtCore import QBasicTimer, Qt\nimport sys\n\nclass Marquee(QLabel):\n\n    def __init__(self, **kwargs):\n        pass\n\n    def initUI(self):\n        pass\n\n    def timerEvent(self, event):\n        pass\n\n    def mouseReleaseEvent(self, event):\n        pass\n\n    def keyPressEvent(self, event):\n        pass\nw = Marquee()\nw.adjustSize()\nw.move(QApplication.instance().desktop().screen().rect().center() - w.rect().center())\nw.show()\nsys.exit(app.exec())\nimport pygame, sys\nfrom pygame.locals import *\nLibrary: pygame\npygame.init()\nYSIZE = 40\nXSIZE = 150\nTEXT = 'Hello World! '\nFONTSIZE = 32\nLEFT = False\nRIGHT = True\nDIR = RIGHT\nTIMETICK = 180\nTICK = 2 + USEREVENT\nTEXTBOX = pygame.Rect(10, 10, XSIZE, YSIZE)\npygame.time.set_timer(TICK, TIMETICK)\nwindow = pygame.display.set_mode((XSIZE, YSIZE))\npygame.display.set_caption('Animation')\nfont = pygame.font.SysFont(None, FONTSIZE)\nscreen = pygame.display.get_surface()\n\ndef rotate():\n    pass\n\ndef click(position):\n    pass\n\ndef draw():\n    pass\n\ndef input(event):\n    pass\nwhile True:\n    input(pygame.event.wait())\n    pygame.display.flip()\nimport Tkinter as tki\n\ndef scroll_text(s, how_many):\n    pass\ndirection = 1\ntk = tki.Tk()\nvar = tki.Variable(tk)\n\ndef mouse_handler(point):\n    pass\n\ndef timer_handler():\n    pass\nvar.set('Hello, World! ')\ntki.Label(tk, textvariable=var).pack()\ntk.bind('<Button-1>', mouse_handler)\ntk.after(125, timer_handler)\ntk.title('Python Animation')\ntki.mainloop()", "adversarial_score": 2, "original_score": 3, "search_time": 5223.035205364227, "stats": {"total_attempts": 100, "unique_perturbations": 100, "cache_hits": 0, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "from PyQt5.QtGui import QFont\nLibrary: PyQt5\nfrom PyQt5.QtWidgets import QApplication, QLabel\napp = QApplication(sys.argv)\nfrom PyQt5.QtCore import QBasicTimer, Qt\nimport sys\n\nclass Marquee(QLabel):\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.text = \"Hello World! \"\n        self.font = QFont()\n        self.font.setPointSize(24)\n        self.setFont(self.font)\n        self.timer = QBasicTimer()\n        self.timer.start(180, self)\n        self.direction = RIGHT\n\n    def initUI(self):\n        pass\n\n    def timerEvent(self, event):\n        if event.timer().id() == self.timer.timerId():\n            self.movePosition()\n\n    def movePosition(self):\n        if self.direction == RIGHT:\n            self.moveLeft()\n        else:\n            self.moveRight()\n\n    def moveLeft(self):\n        pos = self.pos()\n        x = pos.x() - 1\n        self.setPos(x, pos.y())\n        if x <= -self.width():\n            self.moveRight()\n\n    def moveRight(self):\n        pos = self.pos()\n        x = pos.x() + 1\n        self.setPos(x, pos.y())\n        if x >= self.width():\n            self.moveLeft()\n\n    def mouseReleaseEvent(self, event):\n        if event.button() == 1:\n            self.direction = not self.direction\n\n    def keyPressEvent(self, event):\n        pass\nw = Marquee()\nw.adjustSize()\nw.move(QApplication.instance().desktop().screen().rect().center() - w.rect().center())\nw.show()\nsys.exit(app.exec())\nimport pygame, sys\nfrom pygame.locals import *\nLibrary: pygame\npygame.init()\nYSIZE = 40\nXSIZE = 150\nTEXT = 'Hello World! '\nFONTSIZE = 32\nLEFT = False\nRIGHT = True\nDIR = RIGHT\nTIMETICK = 180\nTICK = 2 + USEREVENT\nTEXTBOX = pygame.Rect(10, 10, XSIZE, YSIZE)\npygame.time.set_timer(TICK, TIMETICK)\nwindow = pygame.display.set_mode((XSIZE, YSIZE))\npygame.display.set_caption('Animation')\nfont = pygame.font.SysFont(None, FONTSIZE)\nscreen = pygame.display.get_surface()\n\ndef rotate():\n    pass\n\ndef click(position):\n    global DIR\n    if DIR == RIGHT:\n        DIR = LEFT\n    else:\n        DIR = RIGHT\n\ndef draw():\n    pass\n\ndef input(event):\n    pass\nwhile True:\n    input(pygame.event.wait())\n    pygame.display.flip()\nimport Tkinter as tki\n\ndef scroll_text(s, how_many):\n    pass\ndirection = 1\ntk = tki.Tk()\nvar = tki.Variable(tk)\n\ndef mouse_handler(point):\n    global direction\n    if direction == 1:\n        direction = -1\n    else:\n        direction = 1\n\ndef timer_handler():\n    global var\n    var.set(var.get() + 'Hello, World! ')\n    tk.after(125, timer_handler)\n\nvar.set('Hello, World! ')\ntk.bind('<Button-1>', mouse_handler)\ntk.after(125, timer_handler)\ntk.title('Python Animation')\ntki.mainloop()", "score_distribution": [3, 2, 3, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 3, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 2, 3, 2, 3, 3, 3, 2, 3, 3, 3, 2, 3, 3, 2, 2, 2, 3, 3, 3, 2, 2, 3, 3, 2, 3, 3, 3, 2, 2, 2, 3, 3, 2, 3, 3, 3, 3, 3, 2, 2, 3]}
{"lang_cluster": "Python", "source_code": "\n\nfrom random import randrange\n\ndef knuth_shuffle(x):\n    for i in range(len(x)-1, 0, -1):\n        j = randrange(i + 1)\n        x[i], x[j] = x[j], x[i]\n\nx = list(range(10))\nknuth_shuffle(x)\nprint(\"shuffled:\", x)\n\n", "human_summarization": "implement the Knuth shuffle algorithm, also known as the Fisher-Yates shuffle, which randomly shuffles the elements of an array. The algorithm modifies the input array in-place, but can be adjusted to return a new shuffled array if necessary. It can also be amended to iterate from left to right for convenience. The Python standard library function random.shuffle uses this algorithm.", "id": 4760, "incomplete_code": "from random import randrange\n\ndef knuth_shuffle(x):\n    pass\nx = list(range(10))\nknuth_shuffle(x)\nprint('shuffled:', x)", "original_code": "\n\nfrom random import randrange\n\ndef knuth_shuffle(x):\n    for i in range(len(x)-1, 0, -1):\n        j = randrange(i + 1)\n        x[i], x[j] = x[j], x[i]\n\nx = list(range(10))\nknuth_shuffle(x)\nprint(\"shuffled:\", x)\n\n", "perturbed_code": "\nfrom random import randrange\n\ndef knuth_shuffle(x):\n    for i in range((len(x) - 1), 0, (- 1)):\n        j = randrange((1 + i))\n        (x[i], x[j]) = (x[j], x[i])\nx = list(range(10))\nknuth_shuffle(x)\nprint('shuffled:', x)\n", "incomplete_perturbed_code": "from random import randrange\n\ndef knuth_shuffle(x):\n    pass\nx = list(range(10))\nknuth_shuffle(x)\nprint('shuffled:', x)", "adversarial_score": 5, "original_score": 5, "search_time": 0.16761088371276855, "stats": {"total_attempts": 100, "unique_perturbations": 2, "cache_hits": 80, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "from random import randrange\n\ndef knuth_shuffle(x):\n    n = len(x)\n    for i in range(n - 1, 0, -1):\n        j = randrange(i + 1)\n        x[i], x[j] = x[j], x[i]\nx = list(range(10))\nknuth_shuffle(x)\nprint('shuffled:', x)", "score_distribution": [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]}
{"lang_cluster": "Python", "source_code": "\ndef mc_rank(iterable, start=1):\n    \"\"\"Modified competition ranking\"\"\"\n    lastresult, fifo = None, []\n    for n, item in enumerate(iterable, start-1):\n        if item[0] == lastresult:\n            fifo += [item]\n        else:\n            while fifo:\n                yield n, fifo.pop(0)\n            lastresult, fifo = item[0], fifo + [item]\n    while fifo:\n        yield n+1, fifo.pop(0)\n\n\ndef sc_rank(iterable, start=1):\n    \"\"\"Standard competition ranking\"\"\"\n    lastresult, lastrank = None, None\n    for n, item in enumerate(iterable, start):\n        if item[0] == lastresult:\n            yield lastrank, item\n        else:\n            yield n, item\n            lastresult, lastrank = item[0], n\n\n\ndef d_rank(iterable, start=1):\n    \"\"\"Dense ranking\"\"\"\n    lastresult, lastrank = None, start - 1,\n    for item in iterable:\n        if item[0] == lastresult:\n            yield lastrank, item\n        else:\n            lastresult, lastrank = item[0], lastrank + 1\n            yield lastrank, item\n\n\ndef o_rank(iterable, start=1):\n    \"\"\"Ordinal  ranking\"\"\"\n    yield from enumerate(iterable, start)\n\n\ndef f_rank(iterable, start=1):\n    \"\"\"Fractional ranking\"\"\"\n    last, fifo = None, []\n    for n, item in enumerate(iterable, start):\n        if item[0] != last:\n            if fifo:\n                mean = sum(f[0] for f in fifo) / len(fifo)\n                while fifo:\n                    yield mean, fifo.pop(0)[1]\n        last = item[0]\n        fifo.append((n, item))\n    if fifo:\n        mean = sum(f[0] for f in fifo) / len(fifo)\n        while fifo:\n            yield mean, fifo.pop(0)[1]\n\n\nif __name__ == '__main__':\n    scores = [(44, 'Solomon'),\n              (42, 'Jason'),\n              (42, 'Errol'),\n              (41, 'Garry'),\n              (41, 'Bernard'),\n              (41, 'Barry'),\n              (39, 'Stephen')]\n\n    print('\\nScores to be ranked (best first):')\n    for s in scores:\n        print('        %2i %s' % (s ))\n    for ranker in [sc_rank, mc_rank, d_rank, o_rank, f_rank]:\n        print('\\n%s:' % ranker.__doc__)\n        for rank, score in ranker(scores):\n            print('  %3g, %r' % (rank, score))\n\n\n", "human_summarization": "\"Implement functions for five different ranking methods: Standard, Modified, Dense, Ordinal, and Fractional. Each function takes an ordered list of competition scores and applies the respective ranking method. The Standard method shares the first ordinal number for ties, the Modified method shares the last ordinal number for ties, the Dense method shares the next available integer for ties, the Ordinal method assigns the next available integer without special treatment for ties, and the Fractional method shares the mean of the ordinal numbers for ties.\"", "id": 4776, "incomplete_code": "def mc_rank(iterable, start=1):\n    \"\"\"Modified competition ranking\"\"\"\n    pass\n\ndef sc_rank(iterable, start=1):\n    \"\"\"Standard competition ranking\"\"\"\n    pass\n\ndef d_rank(iterable, start=1):\n    \"\"\"Dense ranking\"\"\"\n    pass\n\ndef o_rank(iterable, start=1):\n    \"\"\"Ordinal  ranking\"\"\"\n    pass\n\ndef f_rank(iterable, start=1):\n    \"\"\"Fractional ranking\"\"\"\n    pass\nif __name__ == '__main__':\n    scores = [(44, 'Solomon'), (42, 'Jason'), (42, 'Errol'), (41, 'Garry'), (41, 'Bernard'), (41, 'Barry'), (39, 'Stephen')]\n    print('\\nScores to be ranked (best first):')\n    for s in scores:\n        print('        %2i %s' % s)\n    for ranker in [sc_rank, mc_rank, d_rank, o_rank, f_rank]:\n        print('\\n%s:' % ranker.__doc__)\n        for rank, score in ranker(scores):\n            print('  %3g, %r' % (rank, score))", "original_code": "\ndef mc_rank(iterable, start=1):\n    \"\"\"Modified competition ranking\"\"\"\n    lastresult, fifo = None, []\n    for n, item in enumerate(iterable, start-1):\n        if item[0] == lastresult:\n            fifo += [item]\n        else:\n            while fifo:\n                yield n, fifo.pop(0)\n            lastresult, fifo = item[0], fifo + [item]\n    while fifo:\n        yield n+1, fifo.pop(0)\n\n\ndef sc_rank(iterable, start=1):\n    \"\"\"Standard competition ranking\"\"\"\n    lastresult, lastrank = None, None\n    for n, item in enumerate(iterable, start):\n        if item[0] == lastresult:\n            yield lastrank, item\n        else:\n            yield n, item\n            lastresult, lastrank = item[0], n\n\n\ndef d_rank(iterable, start=1):\n    \"\"\"Dense ranking\"\"\"\n    lastresult, lastrank = None, start - 1,\n    for item in iterable:\n        if item[0] == lastresult:\n            yield lastrank, item\n        else:\n            lastresult, lastrank = item[0], lastrank + 1\n            yield lastrank, item\n\n\ndef o_rank(iterable, start=1):\n    \"\"\"Ordinal  ranking\"\"\"\n    yield from enumerate(iterable, start)\n\n\ndef f_rank(iterable, start=1):\n    \"\"\"Fractional ranking\"\"\"\n    last, fifo = None, []\n    for n, item in enumerate(iterable, start):\n        if item[0] != last:\n            if fifo:\n                mean = sum(f[0] for f in fifo) / len(fifo)\n                while fifo:\n                    yield mean, fifo.pop(0)[1]\n        last = item[0]\n        fifo.append((n, item))\n    if fifo:\n        mean = sum(f[0] for f in fifo) / len(fifo)\n        while fifo:\n            yield mean, fifo.pop(0)[1]\n\n\nif __name__ == '__main__':\n    scores = [(44, 'Solomon'),\n              (42, 'Jason'),\n              (42, 'Errol'),\n              (41, 'Garry'),\n              (41, 'Bernard'),\n              (41, 'Barry'),\n              (39, 'Stephen')]\n\n    print('\\nScores to be ranked (best first):')\n    for s in scores:\n        print('        %2i %s' % (s ))\n    for ranker in [sc_rank, mc_rank, d_rank, o_rank, f_rank]:\n        print('\\n%s:' % ranker.__doc__)\n        for rank, score in ranker(scores):\n            print('  %3g, %r' % (rank, score))\n\n\n", "perturbed_code": "\n\ndef o_rank(iterable, start=1):\n    'Ordinal  ranking'\n    (yield from enumerate(iterable, start))\n\ndef d_rank(iterable, start=1):\n    'Dense ranking'\n    (lastresult, lastrank) = (None, (start - 1))\n    for item in iterable:\n        if (item[0] == lastresult):\n            (yield (lastrank, item))\n        else:\n            (lastresult, lastrank) = (item[0], (1 + lastrank))\n            (yield (lastrank, item))\n\ndef mc_rank(iterable, start=1):\n    'Modified competition ranking'\n    while fifo:\n        (yield ((1 + n), fifo.pop(0)))\n    for (n, item) in enumerate(iterable, (start - 1)):\n        if (lastresult == item[0]):\n            fifo += [item]\n        else:\n            while fifo:\n                (yield (n, fifo.pop(0)))\n            (lastresult, fifo) = (item[0], ([item] + fifo))\n    (lastresult, fifo) = (None, [])\n\ndef sc_rank(iterable, start=1):\n    (lastresult, lastrank) = (None, None)\n    'Standard competition ranking'\n    for (n, item) in enumerate(iterable, start):\n        if (lastresult == item[0]):\n            (yield (lastrank, item))\n        else:\n            (yield (n, item))\n            (lastresult, lastrank) = (item[0], n)\n\ndef f_rank(iterable, start=1):\n    'Fractional ranking'\n    if fifo:\n        while fifo:\n            (yield (mean, fifo.pop(0)[1]))\n        mean = (sum((f[0] for f in fifo)) / len(fifo))\n    for (n, item) in enumerate(iterable, start):\n        if (item[0] != last):\n            if fifo:\n                while fifo:\n                    (yield (mean, fifo.pop(0)[1]))\n                mean = (sum((f[0] for f in fifo)) / len(fifo))\n        last = item[0]\n        fifo.append((n, item))\n    (last, fifo) = (None, [])\nif ('__main__' == __name__):\n    print('\\nScores to be ranked (best first):')\n    for ranker in [sc_rank, mc_rank, d_rank, o_rank, f_rank]:\n        for (rank, score) in ranker(scores):\n            print(('  %3g, %r' % (rank, score)))\n        print(('\\n%s:' % ranker.__doc__))\n    for s in scores:\n        print(('        %2i %s' % s))\n    scores = [(44, 'Solomon'), (42, 'Jason'), (42, 'Errol'), (41, 'Garry'), (41, 'Bernard'), (41, 'Barry'), (39, 'Stephen')]\n", "incomplete_perturbed_code": "def o_rank(iterable, start=1):\n    \"\"\"Ordinal  ranking\"\"\"\n    pass\n\ndef d_rank(iterable, start=1):\n    \"\"\"Dense ranking\"\"\"\n    pass\n\ndef mc_rank(iterable, start=1):\n    \"\"\"Modified competition ranking\"\"\"\n    pass\n\ndef sc_rank(iterable, start=1):\n    pass\n\ndef f_rank(iterable, start=1):\n    \"\"\"Fractional ranking\"\"\"\n    pass\nif '__main__' == __name__:\n    print('\\nScores to be ranked (best first):')\n    for ranker in [sc_rank, mc_rank, d_rank, o_rank, f_rank]:\n        for rank, score in ranker(scores):\n            print('  %3g, %r' % (rank, score))\n        print('\\n%s:' % ranker.__doc__)\n    for s in scores:\n        print('        %2i %s' % s)\n    scores = [(44, 'Solomon'), (42, 'Jason'), (42, 'Errol'), (41, 'Garry'), (41, 'Bernard'), (41, 'Barry'), (39, 'Stephen')]", "adversarial_score": 1, "original_score": 2, "search_time": 4102.198185443878, "stats": {"total_attempts": 100, "unique_perturbations": 100, "cache_hits": 0, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "def o_rank(iterable, start=1):\n    \"\"\"Ordinal  ranking\"\"\"\n    it = iter(iterable)\n    ranks = []\n    i = 0\n    for elem in it:\n        i += 1\n        ranks.append(i)\n    return ranks\n\ndef d_rank(iterable, start=1):\n    \"\"\"Dense ranking\"\"\"\n    it = iter(iterable)\n    ranks = []\n    i = 0\n    for elem in it:\n        i += 1\n        ranks.append(i)\n    return ranks\n\ndef mc_rank(iterable, start=1):\n    \"\"\"Modified competition ranking\"\"\"\n    it = iter(iterable)\n    ranks = []\n    i = 0\n    vals = []\n    for elem in it:\n        vals.append(elem)\n        i += 1\n        if len(vals) > 1:\n            ranks.append(i)\n        else:\n            ranks.append(i)\n    return ranks\n\ndef sc_rank(iterable, start=1):\n    \"\"\"Standard competition ranking\"\"\"\n    it = iter(iterable)\n    ranks = []\n    i = 0\n    for elem in it:\n        i += 1\n        ranks.append(i)\n    return ranks\n\ndef f_rank(iterable, start=1):\n    \"\"\"Fractional ranking\"\"\"\n    it = iter(iterable)\n    ranks = []\n    i = 0\n    for elem in it:\n        i += 1\n        ranks.append(i)\n    return ranks\n\nif '__main__' == __name__:\n    print('\\nScores to be ranked (best first):')\n    for ranker in [sc_rank, mc_rank, d_rank, o_rank, f_rank]:\n        for rank, score in ranker(scores):\n            print('  %3g, %r' % (rank, score))\n        print('\\n%s:' % ranker.__doc__)\n    for s in scores:\n        print('        %2i %s' % s)\n    scores = [(44, 'Solomon'), (42, 'Jason'), (42, 'Errol'), (41, 'Garry'), (41, 'Bernard'), (41, 'Barry'), (39, 'Stephen')]", "score_distribution": [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 1, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1]}
{"lang_cluster": "Python", "source_code": "\n\nfrom itertools import groupby\nfrom collections import namedtuple\n\ndef anyvalidcomb(items, maxwt, val=0, wt=0):\n    ' All combinations below the maxwt '\n    if not items:\n        yield [], val, wt\n    else:\n        this, *items = items            # car, cdr\n        for n in range(this.number + 1):\n            w = wt  + n * this.weight\n            if w > maxwt:\n                break\n            v = val + n * this.value\n            this_comb = [this] * n\n            for comb, value, weight in anyvalidcomb(items, maxwt, v, w):\n                yield this_comb + comb, value, weight\n\nmaxwt = 400\nCOMB, VAL, WT = range(3)\nItem  = namedtuple('Items', 'name weight value number')\nitems = [ Item(*x) for x in\n          (\n            (\"map\", 9, 150, 1),\n            (\"compass\", 13, 35, 1),\n            (\"water\", 153, 200, 3),\n            (\"sandwich\", 50, 60, 2),\n            (\"glucose\", 15, 60, 2),\n            (\"tin\", 68, 45, 3),\n            (\"banana\", 27, 60, 3),\n            (\"apple\", 39, 40, 3),\n            (\"cheese\", 23, 30, 1),\n            (\"beer\", 52, 10, 3),\n            (\"suntan cream\", 11, 70, 1),\n            (\"camera\", 32, 30, 1),\n            (\"t-shirt\", 24, 15, 2),\n            (\"trousers\", 48, 10, 2),\n            (\"umbrella\", 73, 40, 1),\n            (\"waterproof trousers\", 42, 70, 1),\n            (\"waterproof overclothes\", 43, 75, 1),\n            (\"note-case\", 22, 80, 1),\n            (\"sunglasses\", 7, 20, 1),\n            (\"towel\", 18, 12, 2),\n            (\"socks\", 4, 50, 1),\n            (\"book\", 30, 10, 2),\n           ) ]  \n\nbagged = max( anyvalidcomb(items, maxwt), key=lambda c: (c[VAL], -c[WT])) # max val or min wt if values equal\nprint(\"Bagged the following %i items\" % len(bagged[COMB]))\nprint('\\n\\t'.join('%i off: %s' % (len(list(grp)), item.name) for item, grp in groupby(sorted(bagged[COMB]))))\nprint(\"for a total value of %i and a total weight of %i\" % bagged[1:])\n\n\n", "human_summarization": "The code determines the optimal combination of items that a tourist can carry in his knapsack, given a maximum weight limit of 4 kg. It takes into account the weight, value, and quantity of each item. The code uses a dynamic programming approach to solve the zero-one knapsack problem, ensuring the total weight does not exceed the limit and the total value is maximized.", "id": 4778, "incomplete_code": "from itertools import groupby\nfrom collections import namedtuple\n\ndef anyvalidcomb(items, maxwt, val=0, wt=0):\n    \"\"\" All combinations below the maxwt \"\"\"\n    pass\nmaxwt = 400\nCOMB, VAL, WT = range(3)\nItem = namedtuple('Items', 'name weight value number')\nitems = [Item(*x) for x in (('map', 9, 150, 1), ('compass', 13, 35, 1), ('water', 153, 200, 3), ('sandwich', 50, 60, 2), ('glucose', 15, 60, 2), ('tin', 68, 45, 3), ('banana', 27, 60, 3), ('apple', 39, 40, 3), ('cheese', 23, 30, 1), ('beer', 52, 10, 3), ('suntan cream', 11, 70, 1), ('camera', 32, 30, 1), ('t-shirt', 24, 15, 2), ('trousers', 48, 10, 2), ('umbrella', 73, 40, 1), ('waterproof trousers', 42, 70, 1), ('waterproof overclothes', 43, 75, 1), ('note-case', 22, 80, 1), ('sunglasses', 7, 20, 1), ('towel', 18, 12, 2), ('socks', 4, 50, 1), ('book', 30, 10, 2))]\nbagged = max(anyvalidcomb(items, maxwt), key=lambda c: (c[VAL], -c[WT]))\nprint('Bagged the following %i items' % len(bagged[COMB]))\nprint('\\n\\t'.join(('%i off: %s' % (len(list(grp)), item.name) for item, grp in groupby(sorted(bagged[COMB])))))\nprint('for a total value of %i and a total weight of %i' % bagged[1:])", "original_code": "\n\nfrom itertools import groupby\nfrom collections import namedtuple\n\ndef anyvalidcomb(items, maxwt, val=0, wt=0):\n    ' All combinations below the maxwt '\n    if not items:\n        yield [], val, wt\n    else:\n        this, *items = items            # car, cdr\n        for n in range(this.number + 1):\n            w = wt  + n * this.weight\n            if w > maxwt:\n                break\n            v = val + n * this.value\n            this_comb = [this] * n\n            for comb, value, weight in anyvalidcomb(items, maxwt, v, w):\n                yield this_comb + comb, value, weight\n\nmaxwt = 400\nCOMB, VAL, WT = range(3)\nItem  = namedtuple('Items', 'name weight value number')\nitems = [ Item(*x) for x in\n          (\n            (\"map\", 9, 150, 1),\n            (\"compass\", 13, 35, 1),\n            (\"water\", 153, 200, 3),\n            (\"sandwich\", 50, 60, 2),\n            (\"glucose\", 15, 60, 2),\n            (\"tin\", 68, 45, 3),\n            (\"banana\", 27, 60, 3),\n            (\"apple\", 39, 40, 3),\n            (\"cheese\", 23, 30, 1),\n            (\"beer\", 52, 10, 3),\n            (\"suntan cream\", 11, 70, 1),\n            (\"camera\", 32, 30, 1),\n            (\"t-shirt\", 24, 15, 2),\n            (\"trousers\", 48, 10, 2),\n            (\"umbrella\", 73, 40, 1),\n            (\"waterproof trousers\", 42, 70, 1),\n            (\"waterproof overclothes\", 43, 75, 1),\n            (\"note-case\", 22, 80, 1),\n            (\"sunglasses\", 7, 20, 1),\n            (\"towel\", 18, 12, 2),\n            (\"socks\", 4, 50, 1),\n            (\"book\", 30, 10, 2),\n           ) ]  \n\nbagged = max( anyvalidcomb(items, maxwt), key=lambda c: (c[VAL], -c[WT])) # max val or min wt if values equal\nprint(\"Bagged the following %i items\" % len(bagged[COMB]))\nprint('\\n\\t'.join('%i off: %s' % (len(list(grp)), item.name) for item, grp in groupby(sorted(bagged[COMB]))))\nprint(\"for a total value of %i and a total weight of %i\" % bagged[1:])\n\n\n", "perturbed_code": "\n\ndef anyvalidcomb(items, maxwt, val=0, wt=0):\n    ' All combinations below the maxwt '\n    if (not items):\n        (yield ([], val, wt))\n    else:\n        for n in range((1 + this.number)):\n            for (comb, value, weight) in anyvalidcomb(items, maxwt, v, w):\n                (yield ((comb + this_comb), value, weight))\n            if (w > maxwt):\n                break\n            w = (wt + (n * this.weight))\n            this_comb = (n * [this])\n            v = (val + (n * this.value))\n        (this, *items) = items\nfrom collections import namedtuple\n(COMB, VAL, WT) = range(3)\nfrom itertools import groupby\nmaxwt = 400\nItem = namedtuple('Items', 'name weight value number')\nitems = [Item(*x) for x in (('map', 9, 150, 1), ('compass', 13, 35, 1), ('water', 153, 200, 3), ('sandwich', 50, 60, 2), ('glucose', 15, 60, 2), ('tin', 68, 45, 3), ('banana', 27, 60, 3), ('apple', 39, 40, 3), ('cheese', 23, 30, 1), ('beer', 52, 10, 3), ('suntan cream', 11, 70, 1), ('camera', 32, 30, 1), ('t-shirt', 24, 15, 2), ('trousers', 48, 10, 2), ('umbrella', 73, 40, 1), ('waterproof trousers', 42, 70, 1), ('waterproof overclothes', 43, 75, 1), ('note-case', 22, 80, 1), ('sunglasses', 7, 20, 1), ('towel', 18, 12, 2), ('socks', 4, 50, 1), ('book', 30, 10, 2))]\nbagged = max(anyvalidcomb(items, maxwt), key=(lambda c: (c[VAL], (- c[WT]))))\nprint(('Bagged the following %i items' % len(bagged[COMB])))\nprint('\\n\\t'.join((('%i off: %s' % (len(list(grp)), item.name)) for (item, grp) in groupby(sorted(bagged[COMB])))))\nprint(('for a total value of %i and a total weight of %i' % bagged[1:]))\n", "incomplete_perturbed_code": "def anyvalidcomb(items, maxwt, val=0, wt=0):\n    \"\"\" All combinations below the maxwt \"\"\"\n    pass\nfrom collections import namedtuple\nCOMB, VAL, WT = range(3)\nfrom itertools import groupby\nmaxwt = 400\nItem = namedtuple('Items', 'name weight value number')\nitems = [Item(*x) for x in (('map', 9, 150, 1), ('compass', 13, 35, 1), ('water', 153, 200, 3), ('sandwich', 50, 60, 2), ('glucose', 15, 60, 2), ('tin', 68, 45, 3), ('banana', 27, 60, 3), ('apple', 39, 40, 3), ('cheese', 23, 30, 1), ('beer', 52, 10, 3), ('suntan cream', 11, 70, 1), ('camera', 32, 30, 1), ('t-shirt', 24, 15, 2), ('trousers', 48, 10, 2), ('umbrella', 73, 40, 1), ('waterproof trousers', 42, 70, 1), ('waterproof overclothes', 43, 75, 1), ('note-case', 22, 80, 1), ('sunglasses', 7, 20, 1), ('towel', 18, 12, 2), ('socks', 4, 50, 1), ('book', 30, 10, 2))]\nbagged = max(anyvalidcomb(items, maxwt), key=lambda c: (c[VAL], -c[WT]))\nprint('Bagged the following %i items' % len(bagged[COMB]))\nprint('\\n\\t'.join(('%i off: %s' % (len(list(grp)), item.name) for item, grp in groupby(sorted(bagged[COMB])))))\nprint('for a total value of %i and a total weight of %i' % bagged[1:])", "adversarial_score": 2, "original_score": 2, "search_time": 711.610589504242, "stats": {"total_attempts": 100, "unique_perturbations": 94, "cache_hits": 6, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "def anyvalidcomb(items, maxwt, val=0, wt=0):\n    \"\"\" All combinations below the maxwt \"\"\"\n    result = []\n    for item in items:\n        if wt + item.weight <= maxwt:\n            result.append((val + item.value, wt + item.weight, [item]))\n    result.sort(key=lambda x: (x[0], -x[1]), reverse=True)\n    return result\nfrom collections import namedtuple\nCOMB, VAL, WT = range(3)\nfrom itertools import groupby\nmaxwt = 400\nItem = namedtuple('Items', 'name weight value number')\nitems = [Item(*x) for x in (('map', 9, 150, 1), ('compass', 13, 35, 1), ('water', 153, 200, 3), ('sandwich', 50, 60, 2), ('glucose', 15, 60, 2), ('tin', 68, 45, 3), ('banana', 27, 60, 3), ('apple', 39, 40, 3), ('cheese', 23, 30, 1), ('beer', 52, 10, 3), ('suntan cream', 11, 70, 1), ('camera', 32, 30, 1), ('t-shirt', 24, 15, 2), ('trousers', 48, 10, 2), ('umbrella', 73, 40, 1), ('waterproof trousers', 42, 70, 1), ('waterproof overclothes', 43, 75, 1), ('note-case', 22, 80, 1), ('sunglasses', 7, 20, 1), ('towel', 18, 12, 2), ('socks', 4, 50, 1), ('book', 30, 10, 2))]\nbagged = max(anyvalidcomb(items, maxwt), key=lambda c: (c[VAL], -c[WT]))\nprint('Bagged the following %i items' % len(bagged[COMB]))\nprint('\\n\\t'.join(('%i off: %s' % (len(list(grp)), item.name) for item, grp in groupby(sorted(bagged[COMB])))))\nprint('for a total value of %i and a total weight of %i' % bagged[1:])", "score_distribution": [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]}
{"lang_cluster": "Python", "source_code": "\n# Works with: Python version 2.3 through 3.4\nnext = str(int('123') + 1)\n\n# Dropping or keeping any non-numerics in the string\n\n\n# succString\u00a0:: Bool -> String -> String\ndef succString(blnPruned):\n    def go(x):\n        try:\n            return [str(1 + (float(x) if '.' in x else int(x)))]\n        except ValueError:\n            return [] if blnPruned else [x]\n    return lambda s: ' '.join(concatMap(go)(s.split()))\n\n\n# TEST ----------------------------------------------------\ndef main():\n    print(\n        '\\n'.join(\n            [succString(bln)(\n                '41.0 pine martens in 1491 -1.5 mushrooms \u2260 136'\n            ) for bln in [False, True]]\n        )\n    )\n\n\n# GENERIC ---------------------------------------------------\n\n# concatMap\u00a0:: (a -> [b]) -> [a] -> [b]\ndef concatMap(f):\n    return lambda xs: (\n        [ys[0] for ys in [f(x) for x in xs] if ys]\n    )\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\n", "human_summarization": "\"Increment a numerical string, with options to handle both integer and floating point values, manage noisy or multi-number strings, and retain or remove non-numeric parts.\"", "id": 4780, "incomplete_code": "next = str(int('123') + 1)\n\ndef succString(blnPruned):\n    pass\n\ndef main():\n    pass\n\ndef concatMap(f):\n    pass\nif __name__ == '__main__':\n    main()", "original_code": "\n# Works with: Python version 2.3 through 3.4\nnext = str(int('123') + 1)\n\n# Dropping or keeping any non-numerics in the string\n\n\n# succString\u00a0:: Bool -> String -> String\ndef succString(blnPruned):\n    def go(x):\n        try:\n            return [str(1 + (float(x) if '.' in x else int(x)))]\n        except ValueError:\n            return [] if blnPruned else [x]\n    return lambda s: ' '.join(concatMap(go)(s.split()))\n\n\n# TEST ----------------------------------------------------\ndef main():\n    print(\n        '\\n'.join(\n            [succString(bln)(\n                '41.0 pine martens in 1491 -1.5 mushrooms \u2260 136'\n            ) for bln in [False, True]]\n        )\n    )\n\n\n# GENERIC ---------------------------------------------------\n\n# concatMap\u00a0:: (a -> [b]) -> [a] -> [b]\ndef concatMap(f):\n    return lambda xs: (\n        [ys[0] for ys in [f(x) for x in xs] if ys]\n    )\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\n", "perturbed_code": "\nnext = str((int('123') + 1))\n\ndef succString(blnPruned):\n\n    def go(x):\n        try:\n            return [str(((float(x) if ('.' in x) else int(x)) + 1))]\n        except ValueError:\n            return ([] if blnPruned else [x])\n    return (lambda s: ' '.join(concatMap(go)(s.split())))\n\ndef main():\n    print('\\n'.join([succString(bln)('41.0 pine martens in 1491 -1.5 mushrooms \u2260 136') for bln in [False, True]]))\n\ndef concatMap(f):\n    return (lambda xs: [ys[0] for ys in [f(x) for x in xs] if ys])\nif (__name__ == '__main__'):\n    main()\n", "incomplete_perturbed_code": "next = str(int('123') + 1)\n\ndef succString(blnPruned):\n    pass\n\ndef main():\n    pass\n\ndef concatMap(f):\n    pass\nif __name__ == '__main__':\n    main()", "adversarial_score": 2, "original_score": 2, "search_time": 71.15869736671448, "stats": {"total_attempts": 100, "unique_perturbations": 8, "cache_hits": 80, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "next = str(int('123') + 1)\n\ndef succString(blnPruned):\n    \"\"\"\n    Increments a numerical string, with options to handle both integer and floating point values,\n    manage noisy or multi-number strings, and retain or remove non-numeric parts.\n\n    Args:\n        blnPruned: A boolean indicating whether to prune non-numeric parts of the string.\n\n    Returns:\n        A string representing the incremented numerical value.\n    \"\"\"\n    try:\n        num = float(next)\n        increment = 1\n    except ValueError:\n        return next\n\n    new_num = num + increment\n\n    if blnPruned:\n        new_str = str(int(new_num))\n        return new_str\n    else:\n        return str(new_num)\n\n\ndef main():\n    \"\"\"\n    Main function to demonstrate the succString function.\n    \"\"\"\n    print(succString(False))  # Output: 124.0\n    print(succString(True))   # Output: 124\n    print(succString(\"123+4.5\")) # Output: 127.5\n    print(succString(True))   # Output: 127.5\n    print(succString(\"abc123\")) # Output: abc124\n    print(succString(True)) # Output: 124\n    print(succString(\"123.456\")) #Output: 124.456\n    print(succString(True)) # Output: 124.456\n\ndef concatMap(f):\n    \"\"\"\n    A placeholder function.  Not used in the example.\n    \"\"\"\n    pass\nif __name__ == '__main__':\n    main()", "score_distribution": [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]}
{"lang_cluster": "Python", "source_code": "\n\"\"\"One-time pad using an XOR cipher. Requires Python >=3.6.\"\"\"\n\nimport argparse\nimport itertools\nimport pathlib\nimport re\nimport secrets\nimport sys\n\n\n# One-time pad file signature.\nMAGIC = \"#one-time pad\"\n\n\ndef make_keys(n, size):\n    \"\"\"Generate ``n`` secure, random keys of ``size`` bytes.\"\"\"\n    # We're generating and storing keys in their hexadecimal form to make\n    # one-time pad files a little more human readable and to ensure a key\n    # can not start with a hyphen.\n    return (secrets.token_hex(size) for _ in range(n))\n\n\ndef make_pad(name, pad_size, key_size):\n    \"\"\"Create a new one-time pad identified by the given name.\n\n    Args:\n        name (str): Unique one-time pad identifier.\n        pad_size (int): The number of keys (or pages) in the pad.\n        key_size (int): The number of bytes per key.\n    Returns:\n        The new one-time pad as a string.\n    \"\"\"\n    pad = [\n        MAGIC,\n        f\"#name={name}\",\n        f\"#size={pad_size}\",\n        *make_keys(pad_size, key_size),\n    ]\n\n    return \"\\n\".join(pad)\n\n\ndef xor(message, key):\n    \"\"\"Return ``message`` XOR-ed with ``key``.\n\n    Args:\n        message (bytes): Plaintext or cyphertext to be encrypted or decrypted.\n        key (bytes): Encryption and decryption key.\n    Returns:\n        Plaintext or cyphertext as a byte string.\n    \"\"\"\n    return bytes(mc ^ kc for mc, kc in zip(message, itertools.cycle(key)))\n\n\ndef use_key(pad):\n    \"\"\"Use the next available key from the given one-time pad.\n\n    Args:\n        pad (str): A one-time pad.\n    Returns:\n        (str, str) A two-tuple of updated pad and key.\n    \"\"\"\n    match = re.search(r\"^[a-f0-9]+$\", pad, re.MULTILINE)\n    if not match:\n        error(\"pad is all used up\")\n\n    key = match.group()\n    pos = match.start()\n\n    return (f\"{pad[:pos]}-{pad[pos:]}\", key)\n\n\ndef log(msg):\n    \"\"\"Log a message.\"\"\"\n    sys.stderr.write(msg)\n    sys.stderr.write(\"\\n\")\n\n\ndef error(msg):\n    \"\"\"Exit with an error message.\"\"\"\n    sys.stderr.write(msg)\n    sys.stderr.write(\"\\n\")\n    sys.exit(1)\n\n\ndef write_pad(path, pad_size, key_size):\n    \"\"\"Write a new one-time pad to the given path.\n\n    Args:\n        path (pathlib.Path): Path to write one-time pad to.\n        length (int): Number of keys in the pad.\n    \"\"\"\n    if path.exists():\n        error(f\"pad '{path}' already exists\")\n\n    with path.open(\"w\") as fd:\n        fd.write(make_pad(path.name, pad_size, key_size))\n\n    log(f\"New one-time pad written to {path}\")\n\n\ndef main(pad, message, outfile):\n    \"\"\"Encrypt or decrypt ``message`` using the given pad.\n\n    Args:\n        pad (pathlib.Path): Path to one-time pad.\n        message (bytes): Plaintext or ciphertext message to encrypt or decrypt.\n        outfile: File-like object to write to.\n    \"\"\"\n    if not pad.exists():\n        error(f\"no such pad '{pad}'\")\n\n    with pad.open(\"r\") as fd:\n        if fd.readline().strip() != MAGIC:\n            error(f\"file '{pad}' does not look like a one-time pad\")\n\n    # Rewrites the entire one-time pad every time\n    with pad.open(\"r+\") as fd:\n        updated, key = use_key(fd.read())\n\n        fd.seek(0)\n        fd.write(updated)\n\n    outfile.write(xor(message, bytes.fromhex(key)))\n\n\nif __name__ == \"__main__\":\n    # Command line interface\n    parser = argparse.ArgumentParser(description=\"One-time pad.\")\n\n    parser.add_argument(\n        \"pad\",\n        help=(\n            \"Path to one-time pad. If neither --encrypt or --decrypt \"\n            \"are given, will create a new pad.\"\n        ),\n    )\n\n    parser.add_argument(\n        \"--length\",\n        type=int,\n        default=10,\n        help=\"Pad size. Ignored if --encrypt or --decrypt are given. Defaults to 10.\",\n    )\n\n    parser.add_argument(\n        \"--key-size\",\n        type=int,\n        default=64,\n        help=\"Key size in bytes. Ignored if --encrypt or --decrypt are given. Defaults to 64.\",\n    )\n\n    parser.add_argument(\n        \"-o\",\n        \"--outfile\",\n        type=argparse.FileType(\"wb\"),\n        default=sys.stdout.buffer,\n        help=(\n            \"Write encoded/decoded message to a file. Ignored if --encrypt or \"\n            \"--decrypt is not given. Defaults to stdout.\"\n        ),\n    )\n\n    group = parser.add_mutually_exclusive_group()\n\n    group.add_argument(\n        \"--encrypt\",\n        metavar=\"FILE\",\n        type=argparse.FileType(\"rb\"),\n        help=\"Encrypt FILE using the next available key from pad.\",\n    )\n    group.add_argument(\n        \"--decrypt\",\n        metavar=\"FILE\",\n        type=argparse.FileType(\"rb\"),\n        help=\"Decrypt FILE using the next available key from pad.\",\n    )\n\n    args = parser.parse_args()\n\n    if args.encrypt:\n        message = args.encrypt.read()\n    elif args.decrypt:\n        message = args.decrypt.read()\n    else:\n        message = None\n\n    # Sometimes necessary if message came from stdin\n    if isinstance(message, str):\n        message = message.encode()\n\n    pad = pathlib.Path(args.pad).with_suffix(\".1tp\")\n\n    if message:\n        main(pad, message, args.outfile)\n    else:\n        write_pad(pad, args.length, args.key_size)\n\n\n", "human_summarization": "The code implements a One-time pad for encrypting and decrypting messages using only letters. It generates a One-time pad data based on user-specified filename and length, using true random numbers. The encryption/decryption operation is similar to Rot-13 and reuses much of the Vigen\u00e8re cipher. The code also optionally manages One-time pads, including listing, marking as used, and deleting. It supports the management of pad-files with a \".1tp\" extension, and handles metadata and used status. The code also provides a command-line interface for creating a new one-time pad, distributing it, encrypting a message, and decrypting a message using the shared one-time pad.", "id": 4789, "incomplete_code": "\"\"\"One-time pad using an XOR cipher. Requires Python >=3.6.\"\"\"\nimport argparse\nimport itertools\nimport pathlib\nimport re\nimport secrets\nimport sys\nMAGIC = '#one-time pad'\n\ndef make_keys(n, size):\n    \"\"\"Generate ``n`` secure, random keys of ``size`` bytes.\"\"\"\n    pass\n\ndef make_pad(name, pad_size, key_size):\n    \"\"\"Create a new one-time pad identified by the given name.\n\n    Args:\n        name (str): Unique one-time pad identifier.\n        pad_size (int): The number of keys (or pages) in the pad.\n        key_size (int): The number of bytes per key.\n    Returns:\n        The new one-time pad as a string.\n    \"\"\"\n    pass\n\ndef xor(message, key):\n    \"\"\"Return ``message`` XOR-ed with ``key``.\n\n    Args:\n        message (bytes): Plaintext or cyphertext to be encrypted or decrypted.\n        key (bytes): Encryption and decryption key.\n    Returns:\n        Plaintext or cyphertext as a byte string.\n    \"\"\"\n    pass\n\ndef use_key(pad):\n    \"\"\"Use the next available key from the given one-time pad.\n\n    Args:\n        pad (str): A one-time pad.\n    Returns:\n        (str, str) A two-tuple of updated pad and key.\n    \"\"\"\n    pass\n\ndef log(msg):\n    \"\"\"Log a message.\"\"\"\n    pass\n\ndef error(msg):\n    \"\"\"Exit with an error message.\"\"\"\n    pass\n\ndef write_pad(path, pad_size, key_size):\n    \"\"\"Write a new one-time pad to the given path.\n\n    Args:\n        path (pathlib.Path): Path to write one-time pad to.\n        length (int): Number of keys in the pad.\n    \"\"\"\n    pass\n\ndef main(pad, message, outfile):\n    \"\"\"Encrypt or decrypt ``message`` using the given pad.\n\n    Args:\n        pad (pathlib.Path): Path to one-time pad.\n        message (bytes): Plaintext or ciphertext message to encrypt or decrypt.\n        outfile: File-like object to write to.\n    \"\"\"\n    pass\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='One-time pad.')\n    parser.add_argument('pad', help='Path to one-time pad. If neither --encrypt or --decrypt are given, will create a new pad.')\n    parser.add_argument('--length', type=int, default=10, help='Pad size. Ignored if --encrypt or --decrypt are given. Defaults to 10.')\n    parser.add_argument('--key-size', type=int, default=64, help='Key size in bytes. Ignored if --encrypt or --decrypt are given. Defaults to 64.')\n    parser.add_argument('-o', '--outfile', type=argparse.FileType('wb'), default=sys.stdout.buffer, help='Write encoded/decoded message to a file. Ignored if --encrypt or --decrypt is not given. Defaults to stdout.')\n    group = parser.add_mutually_exclusive_group()\n    group.add_argument('--encrypt', metavar='FILE', type=argparse.FileType('rb'), help='Encrypt FILE using the next available key from pad.')\n    group.add_argument('--decrypt', metavar='FILE', type=argparse.FileType('rb'), help='Decrypt FILE using the next available key from pad.')\n    args = parser.parse_args()\n    if args.encrypt:\n        message = args.encrypt.read()\n    elif args.decrypt:\n        message = args.decrypt.read()\n    else:\n        message = None\n    if isinstance(message, str):\n        message = message.encode()\n    pad = pathlib.Path(args.pad).with_suffix('.1tp')\n    if message:\n        main(pad, message, args.outfile)\n    else:\n        write_pad(pad, args.length, args.key_size)", "original_code": "\n\"\"\"One-time pad using an XOR cipher. Requires Python >=3.6.\"\"\"\n\nimport argparse\nimport itertools\nimport pathlib\nimport re\nimport secrets\nimport sys\n\n\n# One-time pad file signature.\nMAGIC = \"#one-time pad\"\n\n\ndef make_keys(n, size):\n    \"\"\"Generate ``n`` secure, random keys of ``size`` bytes.\"\"\"\n    # We're generating and storing keys in their hexadecimal form to make\n    # one-time pad files a little more human readable and to ensure a key\n    # can not start with a hyphen.\n    return (secrets.token_hex(size) for _ in range(n))\n\n\ndef make_pad(name, pad_size, key_size):\n    \"\"\"Create a new one-time pad identified by the given name.\n\n    Args:\n        name (str): Unique one-time pad identifier.\n        pad_size (int): The number of keys (or pages) in the pad.\n        key_size (int): The number of bytes per key.\n    Returns:\n        The new one-time pad as a string.\n    \"\"\"\n    pad = [\n        MAGIC,\n        f\"#name={name}\",\n        f\"#size={pad_size}\",\n        *make_keys(pad_size, key_size),\n    ]\n\n    return \"\\n\".join(pad)\n\n\ndef xor(message, key):\n    \"\"\"Return ``message`` XOR-ed with ``key``.\n\n    Args:\n        message (bytes): Plaintext or cyphertext to be encrypted or decrypted.\n        key (bytes): Encryption and decryption key.\n    Returns:\n        Plaintext or cyphertext as a byte string.\n    \"\"\"\n    return bytes(mc ^ kc for mc, kc in zip(message, itertools.cycle(key)))\n\n\ndef use_key(pad):\n    \"\"\"Use the next available key from the given one-time pad.\n\n    Args:\n        pad (str): A one-time pad.\n    Returns:\n        (str, str) A two-tuple of updated pad and key.\n    \"\"\"\n    match = re.search(r\"^[a-f0-9]+$\", pad, re.MULTILINE)\n    if not match:\n        error(\"pad is all used up\")\n\n    key = match.group()\n    pos = match.start()\n\n    return (f\"{pad[:pos]}-{pad[pos:]}\", key)\n\n\ndef log(msg):\n    \"\"\"Log a message.\"\"\"\n    sys.stderr.write(msg)\n    sys.stderr.write(\"\\n\")\n\n\ndef error(msg):\n    \"\"\"Exit with an error message.\"\"\"\n    sys.stderr.write(msg)\n    sys.stderr.write(\"\\n\")\n    sys.exit(1)\n\n\ndef write_pad(path, pad_size, key_size):\n    \"\"\"Write a new one-time pad to the given path.\n\n    Args:\n        path (pathlib.Path): Path to write one-time pad to.\n        length (int): Number of keys in the pad.\n    \"\"\"\n    if path.exists():\n        error(f\"pad '{path}' already exists\")\n\n    with path.open(\"w\") as fd:\n        fd.write(make_pad(path.name, pad_size, key_size))\n\n    log(f\"New one-time pad written to {path}\")\n\n\ndef main(pad, message, outfile):\n    \"\"\"Encrypt or decrypt ``message`` using the given pad.\n\n    Args:\n        pad (pathlib.Path): Path to one-time pad.\n        message (bytes): Plaintext or ciphertext message to encrypt or decrypt.\n        outfile: File-like object to write to.\n    \"\"\"\n    if not pad.exists():\n        error(f\"no such pad '{pad}'\")\n\n    with pad.open(\"r\") as fd:\n        if fd.readline().strip() != MAGIC:\n            error(f\"file '{pad}' does not look like a one-time pad\")\n\n    # Rewrites the entire one-time pad every time\n    with pad.open(\"r+\") as fd:\n        updated, key = use_key(fd.read())\n\n        fd.seek(0)\n        fd.write(updated)\n\n    outfile.write(xor(message, bytes.fromhex(key)))\n\n\nif __name__ == \"__main__\":\n    # Command line interface\n    parser = argparse.ArgumentParser(description=\"One-time pad.\")\n\n    parser.add_argument(\n        \"pad\",\n        help=(\n            \"Path to one-time pad. If neither --encrypt or --decrypt \"\n            \"are given, will create a new pad.\"\n        ),\n    )\n\n    parser.add_argument(\n        \"--length\",\n        type=int,\n        default=10,\n        help=\"Pad size. Ignored if --encrypt or --decrypt are given. Defaults to 10.\",\n    )\n\n    parser.add_argument(\n        \"--key-size\",\n        type=int,\n        default=64,\n        help=\"Key size in bytes. Ignored if --encrypt or --decrypt are given. Defaults to 64.\",\n    )\n\n    parser.add_argument(\n        \"-o\",\n        \"--outfile\",\n        type=argparse.FileType(\"wb\"),\n        default=sys.stdout.buffer,\n        help=(\n            \"Write encoded/decoded message to a file. Ignored if --encrypt or \"\n            \"--decrypt is not given. Defaults to stdout.\"\n        ),\n    )\n\n    group = parser.add_mutually_exclusive_group()\n\n    group.add_argument(\n        \"--encrypt\",\n        metavar=\"FILE\",\n        type=argparse.FileType(\"rb\"),\n        help=\"Encrypt FILE using the next available key from pad.\",\n    )\n    group.add_argument(\n        \"--decrypt\",\n        metavar=\"FILE\",\n        type=argparse.FileType(\"rb\"),\n        help=\"Decrypt FILE using the next available key from pad.\",\n    )\n\n    args = parser.parse_args()\n\n    if args.encrypt:\n        message = args.encrypt.read()\n    elif args.decrypt:\n        message = args.decrypt.read()\n    else:\n        message = None\n\n    # Sometimes necessary if message came from stdin\n    if isinstance(message, str):\n        message = message.encode()\n\n    pad = pathlib.Path(args.pad).with_suffix(\".1tp\")\n\n    if message:\n        main(pad, message, args.outfile)\n    else:\n        write_pad(pad, args.length, args.key_size)\n\n\n", "perturbed_code": "\nimport re\nimport secrets\nimport pathlib\nMAGIC = '#one-time pad'\n\ndef main(pad, message, outfile):\n    'Encrypt or decrypt ``message`` using the given pad.\\n\\n    Args:\\n        pad (pathlib.Path): Path to one-time pad.\\n        message (bytes): Plaintext or ciphertext message to encrypt or decrypt.\\n        outfile: File-like object to write to.\\n    '\n    with pad.open('r+') as fd:\n        (updated, key) = use_key(fd.read())\n        fd.seek(0)\n        fd.write(updated)\n    with pad.open('r') as fd:\n        if (fd.readline().strip() != MAGIC):\n            error(f\"file '{pad}' does not look like a one-time pad\")\n    if (not pad.exists()):\n        error(f\"no such pad '{pad}'\")\n    outfile.write(xor(message, bytes.fromhex(key)))\n\ndef use_key(pad):\n    match = re.search('^[a-f0-9]+$', pad, re.MULTILINE)\n    'Use the next available key from the given one-time pad.\\n\\n    Args:\\n        pad (str): A one-time pad.\\n    Returns:\\n        (str, str) A two-tuple of updated pad and key.\\n    '\n    if (not match):\n        error('pad is all used up')\n    key = match.group()\n    pos = match.start()\n    return (f'{pad[:pos]}-{pad[pos:]}', key)\nimport itertools\nimport argparse\n'One-time pad using an XOR cipher. Requires Python >=3.6.'\nimport sys\n\ndef write_pad(path, pad_size, key_size):\n    'Write a new one-time pad to the given path.\\n\\n    Args:\\n        path (pathlib.Path): Path to write one-time pad to.\\n        length (int): Number of keys in the pad.\\n    '\n    with path.open('w') as fd:\n        fd.write(make_pad(path.name, pad_size, key_size))\n    if path.exists():\n        error(f\"pad '{path}' already exists\")\n    log(f'New one-time pad written to {path}')\n\ndef make_keys(n, size):\n    'Generate ``n`` secure, random keys of ``size`` bytes.'\n    return (secrets.token_hex(size) for _ in range(n))\n\ndef xor(message, key):\n    'Return ``message`` XOR-ed with ``key``.\\n\\n    Args:\\n        message (bytes): Plaintext or cyphertext to be encrypted or decrypted.\\n        key (bytes): Encryption and decryption key.\\n    Returns:\\n        Plaintext or cyphertext as a byte string.\\n    '\n    return bytes(((kc ^ mc) for (mc, kc) in zip(message, itertools.cycle(key))))\n\ndef make_pad(name, pad_size, key_size):\n    'Create a new one-time pad identified by the given name.\\n\\n    Args:\\n        name (str): Unique one-time pad identifier.\\n        pad_size (int): The number of keys (or pages) in the pad.\\n        key_size (int): The number of bytes per key.\\n    Returns:\\n        The new one-time pad as a string.\\n    '\n    pad = [MAGIC, f'#name={name}', f'#size={pad_size}', *make_keys(pad_size, key_size)]\n    return '\\n'.join(pad)\n\ndef log(msg):\n    sys.stderr.write(msg)\n    sys.stderr.write('\\n')\n    'Log a message.'\n\ndef error(msg):\n    'Exit with an error message.'\n    sys.stderr.write(msg)\n    sys.stderr.write('\\n')\n    sys.exit(1)\nif (__name__ == '__main__'):\n    parser = argparse.ArgumentParser(description='One-time pad.')\n    parser.add_argument('pad', help='Path to one-time pad. If neither --encrypt or --decrypt are given, will create a new pad.')\n    parser.add_argument('--length', type=int, default=10, help='Pad size. Ignored if --encrypt or --decrypt are given. Defaults to 10.')\n    parser.add_argument('--key-size', type=int, default=64, help='Key size in bytes. Ignored if --encrypt or --decrypt are given. Defaults to 64.')\n    parser.add_argument('-o', '--outfile', type=argparse.FileType('wb'), default=sys.stdout.buffer, help='Write encoded/decoded message to a file. Ignored if --encrypt or --decrypt is not given. Defaults to stdout.')\n    group = parser.add_mutually_exclusive_group()\n    group.add_argument('--encrypt', metavar='FILE', type=argparse.FileType('rb'), help='Encrypt FILE using the next available key from pad.')\n    args = parser.parse_args()\n    group.add_argument('--decrypt', metavar='FILE', type=argparse.FileType('rb'), help='Decrypt FILE using the next available key from pad.')\n    if message:\n        main(pad, message, args.outfile)\n    else:\n        write_pad(pad, args.length, args.key_size)\n    if isinstance(message, str):\n        message = message.encode()\n    if args.encrypt:\n        message = args.encrypt.read()\n    else:\n        if args.decrypt:\n            message = args.decrypt.read()\n        else:\n            message = None\n    pad = pathlib.Path(args.pad).with_suffix('.1tp')\n", "incomplete_perturbed_code": "import re\nimport secrets\nimport pathlib\nMAGIC = '#one-time pad'\n\ndef main(pad, message, outfile):\n    \"\"\"Encrypt or decrypt ``message`` using the given pad.\n\n    Args:\n        pad (pathlib.Path): Path to one-time pad.\n        message (bytes): Plaintext or ciphertext message to encrypt or decrypt.\n        outfile: File-like object to write to.\n    \"\"\"\n    pass\n\ndef use_key(pad):\n    pass\nimport itertools\nimport argparse\n'One-time pad using an XOR cipher. Requires Python >=3.6.'\nimport sys\n\ndef write_pad(path, pad_size, key_size):\n    \"\"\"Write a new one-time pad to the given path.\n\n    Args:\n        path (pathlib.Path): Path to write one-time pad to.\n        length (int): Number of keys in the pad.\n    \"\"\"\n    pass\n\ndef make_keys(n, size):\n    \"\"\"Generate ``n`` secure, random keys of ``size`` bytes.\"\"\"\n    pass\n\ndef xor(message, key):\n    \"\"\"Return ``message`` XOR-ed with ``key``.\n\n    Args:\n        message (bytes): Plaintext or cyphertext to be encrypted or decrypted.\n        key (bytes): Encryption and decryption key.\n    Returns:\n        Plaintext or cyphertext as a byte string.\n    \"\"\"\n    pass\n\ndef make_pad(name, pad_size, key_size):\n    \"\"\"Create a new one-time pad identified by the given name.\n\n    Args:\n        name (str): Unique one-time pad identifier.\n        pad_size (int): The number of keys (or pages) in the pad.\n        key_size (int): The number of bytes per key.\n    Returns:\n        The new one-time pad as a string.\n    \"\"\"\n    pass\n\ndef log(msg):\n    pass\n\ndef error(msg):\n    \"\"\"Exit with an error message.\"\"\"\n    pass\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='One-time pad.')\n    parser.add_argument('pad', help='Path to one-time pad. If neither --encrypt or --decrypt are given, will create a new pad.')\n    parser.add_argument('--length', type=int, default=10, help='Pad size. Ignored if --encrypt or --decrypt are given. Defaults to 10.')\n    parser.add_argument('--key-size', type=int, default=64, help='Key size in bytes. Ignored if --encrypt or --decrypt are given. Defaults to 64.')\n    parser.add_argument('-o', '--outfile', type=argparse.FileType('wb'), default=sys.stdout.buffer, help='Write encoded/decoded message to a file. Ignored if --encrypt or --decrypt is not given. Defaults to stdout.')\n    group = parser.add_mutually_exclusive_group()\n    group.add_argument('--encrypt', metavar='FILE', type=argparse.FileType('rb'), help='Encrypt FILE using the next available key from pad.')\n    args = parser.parse_args()\n    group.add_argument('--decrypt', metavar='FILE', type=argparse.FileType('rb'), help='Decrypt FILE using the next available key from pad.')\n    if message:\n        main(pad, message, args.outfile)\n    else:\n        write_pad(pad, args.length, args.key_size)\n    if isinstance(message, str):\n        message = message.encode()\n    if args.encrypt:\n        message = args.encrypt.read()\n    elif args.decrypt:\n        message = args.decrypt.read()\n    else:\n        message = None\n    pad = pathlib.Path(args.pad).with_suffix('.1tp')", "adversarial_score": 2, "original_score": 3, "search_time": 8415.897071838379, "stats": {"total_attempts": 100, "unique_perturbations": 100, "cache_hits": 0, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "import re\nimport secrets\nimport pathlib\nMAGIC = '#one-time pad'\n\ndef main(pad, message, outfile):\n    \"\"\"Encrypt or decrypt ``message`` using the given pad.\n\n    Args:\n        pad (pathlib.Path): Path to one-time pad.\n        message (bytes): Plaintext or ciphertext message to encrypt or decrypt.\n        outfile: File-like object to write to.\n    \"\"\"\n    try:\n        with open(pad, 'rb') as f:\n            pad_data = f.read()\n    except FileNotFoundError:\n        error(f\"Pad file not found: {pad}\")\n        return\n\n    key_size = pad_data[0]\n    pad_size = len(pad_data) // key_size\n\n    key = pad_data[key_size:key_size + pad_size]\n    decrypted = xor(message, key)\n    outfile.write(decrypted)\n\ndef use_key(pad):\n    \"\"\"Mark a key as used.\"\"\"\n    try:\n        with open(pad, 'a') as f:\n            f.write(f'\\n{pad}:USED\\n')\n    except Exception as e:\n        error(f\"Error marking key as used: {e}\")\n\nimport itertools\nimport argparse\n'One-time pad using an XOR cipher. Requires Python >=3.6.'\nimport sys\n\ndef write_pad(path, pad_size, key_size):\n    \"\"\"Write a new one-time pad to the given path.\n\n    Args:\n        path (pathlib.Path): Path to write one-time pad to.\n        length (int): Number of keys in the pad.\n    \"\"\"\n    pad_data = bytes([key_size]) + bytes([pad_size])\n    with open(path, 'wb') as f:\n        f.write(pad_data)\n    log(f\"Created new one-time pad: {path}\")\n\ndef make_keys(n, size):\n    \"\"\"Generate ``n`` secure, random keys of ``size`` bytes.\"\"\"\n    return bytes([secrets.randbelow(256) for _ in range(n * size)])\n\ndef xor(message, key):\n    \"\"\"Return ``message`` XOR-ed with ``key``.\n\n    Args:\n        message (bytes): Plaintext or cyphertext to be encrypted or decrypted.\n        key (bytes): Encryption and decryption key.\n    Returns:\n        Plaintext or cyphertext as a byte string.\n    \"\"\"\n    return bytes(a ^ b for a, b in zip(message, key))\n\ndef make_pad(name, pad_size, key_size):\n    \"\"\"Create a new one-time pad identified by the given name.\n\n    Args:\n        name (str): Unique one-time pad identifier.\n        pad_size (int): The number of keys (or pages) in the pad.\n        key_size (int): The number of bytes per key.\n    Returns:\n        The new one-time pad as a string.\n    \"\"\"\n    key = make_keys(pad_size, key_size)\n    pad_data = bytes([key_size]) + bytes([pad_size]) + key\n    pad_path = pathlib.Path(f\"{name}.1tp\")\n    with open(pad_path, 'wb') as f:\n        f.write(pad_data)\n    log(f\"Created new one-time pad: {pad_path}\")\n    return str(pad_path)\n\ndef log(msg):\n    \"\"\"Log a message.\"\"\"\n    print(msg)\n\ndef error(msg):\n    \"\"\"Exit with an error message.\"\"\"\n    print(msg)\n    sys.exit(1)\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='One-time pad.')\n    parser.add_argument('pad', help='Path to one-time pad. If neither --encrypt or --decrypt are given, will create a new pad.')\n    parser.add_argument('--length', type=int, default=10, help='Pad size. Ignored if --encrypt or --decrypt are given. Defaults to 10.')\n    parser.add_argument('--key-size', type=int, default=64, help='Key size in bytes. Ignored if --encrypt or --decrypt are given. Defaults to 64.')\n    parser.add_argument('-o', '--outfile', type=argparse.FileType('wb'), default=sys.stdout.buffer, help='Write encoded/decoded message to a file. Ignored if --encrypt or --decrypt is not given. Defaults to stdout.')\n    group = parser.add_mutually_exclusive_group()\n    group.add_argument('--encrypt', metavar='FILE', type=argparse.FileType('rb'), help='Encrypt FILE using the next available key from pad.')\n    args = parser.parse_args()\n    if args.encrypt:\n        message = args.encrypt.read()\n    elif args.decrypt:\n        message = args.decrypt.read()\n    else:\n        message = None\n    pad = pathlib.Path(args.pad).with_suffix('.1tp')\n    if not pad.exists():\n        write_pad(pad, args.length, args.key_size)\n        pad = pad\n    else:\n        with open(pad, 'rb') as f:\n            pad_data = f.read()\n        key_size = pad_data[0]\n        pad_size = len(pad_data) // key_size\n        key = pad_data[key_size:key_size + pad_size]\n    if message:\n        main(pad, message, args.outfile)\n    else:\n        if isinstance(message, str):\n            message = message.encode()\n        if args.encrypt:\n            message = args.encrypt.read()\n        elif args.decrypt:\n            message = args.decrypt.read()\n        else:\n            message = None\n    pad = pathlib.Path(args.pad).with_suffix('.1tp')\n    if args.encrypt:\n        pass\n    elif args.decrypt:\n        main(pad, message, args.outfile)\n    else:\n        pass", "score_distribution": [3, 3, 2, 3, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 2, 2, 3, 2, 3, 3, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 3, 3, 2, 3, 2, 2, 2, 3, 2, 2, 3, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 3, 2, 3, 2, 3, 3, 2, 2, 2, 2, 3, 2, 2, 3, 2, 3, 2, 2, 2]}
{"lang_cluster": "Python", "source_code": "\nfrom itertools import permutations\n \ndef solve():\n    c, p, f, s = \"\\\\,Police,Fire,Sanitation\".split(',')\n    print(f\"{c:>3}  {p:^6} {f:^4} {s:^10}\")\n    c = 1\n    for p, f, s in permutations(range(1, 8), r=3):\n        if p + s + f == 12 and p % 2 == 0:\n            print(f\"{c:>3}: {p:^6} {f:^4} {s:^10}\")\n            c += 1\n \nif __name__ == '__main__':\n    solve()\n\n\n", "human_summarization": "all possible combinations of department numbers for the police, sanitation, and fire departments where each department has a unique number between 1 and 7, the total sum of the numbers is 12, and the police department's number is even. The combinations are generated using a constraint solver.", "id": 4791, "incomplete_code": "from itertools import permutations\n\ndef solve():\n    pass\nif __name__ == '__main__':\n    solve()", "original_code": "\nfrom itertools import permutations\n \ndef solve():\n    c, p, f, s = \"\\\\,Police,Fire,Sanitation\".split(',')\n    print(f\"{c:>3}  {p:^6} {f:^4} {s:^10}\")\n    c = 1\n    for p, f, s in permutations(range(1, 8), r=3):\n        if p + s + f == 12 and p % 2 == 0:\n            print(f\"{c:>3}: {p:^6} {f:^4} {s:^10}\")\n            c += 1\n \nif __name__ == '__main__':\n    solve()\n\n\n", "perturbed_code": "\nfrom itertools import permutations\n\ndef solve():\n    (c, p, f, s) = '\\\\,Police,Fire,Sanitation'.split(',')\n    print(f'{c:>3}  {p:^6} {f:^4} {s:^10}')\n    c = 1\n    for (p, f, s) in permutations(range(1, 8), r=3):\n        if ((((s + p) + f) == 12) and (0 == (p % 2))):\n            print(f'{c:>3}: {p:^6} {f:^4} {s:^10}')\n            c += 1\nif (__name__ == '__main__'):\n    solve()\n", "incomplete_perturbed_code": "from itertools import permutations\n\ndef solve():\n    pass\nif __name__ == '__main__':\n    solve()", "adversarial_score": 3, "original_score": 3, "search_time": 8.699715375900269, "stats": {"total_attempts": 100, "unique_perturbations": 31, "cache_hits": 65, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "from itertools import permutations\n\ndef solve():\n    departments = [1, 2, 3, 4, 5, 6, 7]\n    valid_combinations = []\n\n    for perm in permutations(departments):\n        police, sanitation, fire = perm\n        if police % 2 == 0 and police + sanitation + fire == 12:\n            valid_combinations.append(perm)\n\n    print(valid_combinations)\nif __name__ == '__main__':\n    solve()", "score_distribution": [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]}
{"lang_cluster": "Python", "source_code": "\n# Works with: Python version 3.0.# Works with: Python version 2.6\ndef F(n): return 1 if n == 0 else n - M(F(n-1))\ndef M(n): return 0 if n == 0 else n - F(M(n-1))\n\nprint ([ F(n) for n in range(20) ])\nprint ([ M(n) for n in range(20) ])\n\n\n", "human_summarization": "implement two mutually recursive functions to compute the Hofstadter Female and Male sequences. The functions use each other in their definitions and computations. The Female sequence starts with 1 and the Male sequence starts with 0. For any number n greater than 0, the Female sequence is computed as n minus the Male sequence at the index of the previous Female sequence, and the Male sequence is computed as n minus the Female sequence at the index of the previous Male sequence. The functions are defined in such a way that they can be used in languages that do not require pre-declaration of functions.", "id": 4793, "incomplete_code": "def F(n):\n    pass\n\ndef M(n):\n    pass\nprint([F(n) for n in range(20)])\nprint([M(n) for n in range(20)])", "original_code": "\n# Works with: Python version 3.0.# Works with: Python version 2.6\ndef F(n): return 1 if n == 0 else n - M(F(n-1))\ndef M(n): return 0 if n == 0 else n - F(M(n-1))\n\nprint ([ F(n) for n in range(20) ])\nprint ([ M(n) for n in range(20) ])\n\n\n", "perturbed_code": "\n\ndef F(n):\n    return (1 if (n == 0) else (n - M(F((n - 1)))))\n\ndef M(n):\n    return (0 if (0 == n) else (n - F(M((n - 1)))))\nprint([F(n) for n in range(20)])\nprint([M(n) for n in range(20)])\n", "incomplete_perturbed_code": "def F(n):\n    pass\n\ndef M(n):\n    pass\nprint([F(n) for n in range(20)])\nprint([M(n) for n in range(20)])", "adversarial_score": 2, "original_score": 2, "search_time": 0.16449999809265137, "stats": {"total_attempts": 100, "unique_perturbations": 4, "cache_hits": 80, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "def F(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 1\n    return F(n-1) - M(n-2)\n\ndef M(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return F(n-1) - F(n-2)\n\nprint([F(n) for n in range(20)])\nprint([M(n) for n in range(20)])", "score_distribution": [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]}
{"lang_cluster": "Python", "source_code": "import pygame, sys\nfrom pygame.locals import *\nfrom math import sin, cos, radians\n\npygame.init()\n\nWINDOWSIZE = 250\nTIMETICK = 100\nBOBSIZE = 15\n\nwindow = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))\npygame.display.set_caption(\"Pendulum\")\n\nscreen = pygame.display.get_surface()\nscreen.fill((255,255,255))\n\nPIVOT = (WINDOWSIZE/2, WINDOWSIZE/10)\nSWINGLENGTH = PIVOT[1]*4\n\nclass BobMass(pygame.sprite.Sprite):\n    def __init__(self):\n        pygame.sprite.Sprite.__init__(self)\n        self.theta = 45\n        self.dtheta = 0\n        self.rect = pygame.Rect(PIVOT[0]-SWINGLENGTH*cos(radians(self.theta)),\n                                PIVOT[1]+SWINGLENGTH*sin(radians(self.theta)),\n                                1,1)\n        self.draw()\n\n    def recomputeAngle(self):\n        scaling = 3000.0/(SWINGLENGTH**2)\n\n        firstDDtheta = -sin(radians(self.theta))*scaling\n        midDtheta = self.dtheta + firstDDtheta\n        midtheta = self.theta + (self.dtheta + midDtheta)/2.0\n\n        midDDtheta = -sin(radians(midtheta))*scaling\n        midDtheta = self.dtheta + (firstDDtheta + midDDtheta)/2\n        midtheta = self.theta + (self.dtheta + midDtheta)/2\n\n        midDDtheta = -sin(radians(midtheta)) * scaling\n        lastDtheta = midDtheta + midDDtheta\n        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0\n        \n        lastDDtheta = -sin(radians(lasttheta)) * scaling\n        lastDtheta = midDtheta + (midDDtheta + lastDDtheta)/2.0\n        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0\n\n        self.dtheta = lastDtheta\n        self.theta = lasttheta\n        self.rect = pygame.Rect(PIVOT[0]-\n                                SWINGLENGTH*sin(radians(self.theta)), \n                                PIVOT[1]+\n                                SWINGLENGTH*cos(radians(self.theta)),1,1)\n\n\n    def draw(self):\n        pygame.draw.circle(screen, (0,0,0), PIVOT, 5, 0)\n        pygame.draw.circle(screen, (0,0,0), self.rect.center, BOBSIZE, 0)\n        pygame.draw.aaline(screen, (0,0,0), PIVOT, self.rect.center)\n        pygame.draw.line(screen, (0,0,0), (0, PIVOT[1]), (WINDOWSIZE, PIVOT[1]))\n\n    def update(self):\n        self.recomputeAngle()\n        screen.fill((255,255,255))\n        self.draw()\n\nbob = BobMass()\n\nTICK = USEREVENT + 2\npygame.time.set_timer(TICK, TIMETICK)\n\ndef input(events):\n    for event in events:\n        if event.type == QUIT:\n            sys.exit(0)\n        elif event.type == TICK:\n            bob.update()\n\nwhile True:\n    input(pygame.event.get())\n    pygame.display.flip()\n\n''' Python 3.6.5 code using Tkinter graphical user interface.''' \n\nfrom tkinter import *\nimport math\n\nclass Animation:\n    def __init__(self, gw):\n        self.window = gw\n        self.xoff, self.yoff = 300, 100\n        self.angle = 0\n        self.sina = math.sin(self.angle)\n        self.cosa = math.cos(self.angle)\n        self.rodhyp = 170\n        self.bobr = 30\n        self.bobhyp = self.rodhyp + self.bobr\n        self.rodx0, self.rody0 = self.xoff, self.yoff\n        self.ra = self.rodx0\n        self.rb = self.rody0\n        self.rc = self.xoff + self.rodhyp*self.sina\n        self.rd = self.yoff + self.rodhyp*self.cosa\n        self.ba = self.xoff - self.bobr + self.bobhyp*self.sina\n        self.bb = self.yoff - self.bobr + self.bobhyp*self.cosa\n        self.bc = self.xoff + self.bobr + self.bobhyp*self.sina\n        self.bd = self.yoff + self.bobr + self.bobhyp*self.cosa\n        self.da = math.pi / 360\n\n        # create / fill canvas:\n        self.cnv = Canvas(gw, bg='lemon chiffon')\n        self.cnv.pack(fill=BOTH, expand=True)\n\n        self.cnv.create_line(0, 100, 600, 100,\n                             fill='dodger blue',\n                             width=3)\n        radius = 8\n        self.cnv.create_oval(300-radius, 100-radius,\n                             300+radius, 100+radius,\n                             fill='navy')    \n\n        self.bob = self.cnv.create_oval(self.ba,\n                                        self.bb,\n                                        self.bc,\n                                        self.bd,\n                                        fill='red',\n                                        width=2)\n\n        self.rod = self.cnv.create_line(self.ra,\n                                        self.rb,\n                                        self.rc,\n                                        self.rd,\n                                        fill='dodger blue',\n                                        width=6)\n\n        self.animate()\n\n    def animate(self):\n        if abs(self.angle) > math.pi / 2:\n            self.da = - self.da\n        self.angle += self.da\n        self.sina = math.sin(self.angle)\n        self.cosa = math.cos(self.angle)\n        self.ra = self.rodx0\n        self.rb = self.rody0\n        self.rc = self.xoff + self.rodhyp*self.sina\n        self.rd = self.yoff + self.rodhyp*self.cosa\n        self.ba = self.xoff - self.bobr + self.bobhyp*self.sina\n        self.bb = self.yoff - self.bobr + self.bobhyp*self.cosa\n        self.bc = self.xoff + self.bobr + self.bobhyp*self.sina\n        self.bd = self.yoff + self.bobr + self.bobhyp*self.cosa\n        \n        self.cnv.coords(self.rod,\n                        self.ra,\n                        self.rb,\n                        self.rc,\n                        self.rd)\n        self.cnv.coords(self.bob,\n                        self.ba,\n                        self.bb,\n                        self.bc,\n                        self.bd)\n        self.window.update()\n        self.cnv.after(5, self.animate)\n         \nroot = Tk()\nroot.title('Pendulum')\nroot.geometry('600x400+100+50')\nroot.resizable(False, False)\na = Animation(root)\nroot.mainloop()\n\n", "human_summarization": "create and animate a simple physical model of a gravity pendulum.", "id": 4798, "incomplete_code": "import pygame, sys\nfrom pygame.locals import *\nfrom math import sin, cos, radians\npygame.init()\nWINDOWSIZE = 250\nTIMETICK = 100\nBOBSIZE = 15\nwindow = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))\npygame.display.set_caption('Pendulum')\nscreen = pygame.display.get_surface()\nscreen.fill((255, 255, 255))\nPIVOT = (WINDOWSIZE / 2, WINDOWSIZE / 10)\nSWINGLENGTH = PIVOT[1] * 4\n\nclass BobMass(pygame.sprite.Sprite):\n\n    def __init__(self):\n        pass\n\n    def recomputeAngle(self):\n        pass\n\n    def draw(self):\n        pass\n\n    def update(self):\n        pass\nbob = BobMass()\nTICK = USEREVENT + 2\npygame.time.set_timer(TICK, TIMETICK)\n\ndef input(events):\n    pass\nwhile True:\n    input(pygame.event.get())\n    pygame.display.flip()\n' Python 3.6.5 code using Tkinter graphical user interface.'\nfrom tkinter import *\nimport math\n\nclass Animation:\n\n    def __init__(self, gw):\n        pass\n\n    def animate(self):\n        pass\nroot = Tk()\nroot.title('Pendulum')\nroot.geometry('600x400+100+50')\nroot.resizable(False, False)\na = Animation(root)\nroot.mainloop()", "original_code": "import pygame, sys\nfrom pygame.locals import *\nfrom math import sin, cos, radians\n\npygame.init()\n\nWINDOWSIZE = 250\nTIMETICK = 100\nBOBSIZE = 15\n\nwindow = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))\npygame.display.set_caption(\"Pendulum\")\n\nscreen = pygame.display.get_surface()\nscreen.fill((255,255,255))\n\nPIVOT = (WINDOWSIZE/2, WINDOWSIZE/10)\nSWINGLENGTH = PIVOT[1]*4\n\nclass BobMass(pygame.sprite.Sprite):\n    def __init__(self):\n        pygame.sprite.Sprite.__init__(self)\n        self.theta = 45\n        self.dtheta = 0\n        self.rect = pygame.Rect(PIVOT[0]-SWINGLENGTH*cos(radians(self.theta)),\n                                PIVOT[1]+SWINGLENGTH*sin(radians(self.theta)),\n                                1,1)\n        self.draw()\n\n    def recomputeAngle(self):\n        scaling = 3000.0/(SWINGLENGTH**2)\n\n        firstDDtheta = -sin(radians(self.theta))*scaling\n        midDtheta = self.dtheta + firstDDtheta\n        midtheta = self.theta + (self.dtheta + midDtheta)/2.0\n\n        midDDtheta = -sin(radians(midtheta))*scaling\n        midDtheta = self.dtheta + (firstDDtheta + midDDtheta)/2\n        midtheta = self.theta + (self.dtheta + midDtheta)/2\n\n        midDDtheta = -sin(radians(midtheta)) * scaling\n        lastDtheta = midDtheta + midDDtheta\n        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0\n        \n        lastDDtheta = -sin(radians(lasttheta)) * scaling\n        lastDtheta = midDtheta + (midDDtheta + lastDDtheta)/2.0\n        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0\n\n        self.dtheta = lastDtheta\n        self.theta = lasttheta\n        self.rect = pygame.Rect(PIVOT[0]-\n                                SWINGLENGTH*sin(radians(self.theta)), \n                                PIVOT[1]+\n                                SWINGLENGTH*cos(radians(self.theta)),1,1)\n\n\n    def draw(self):\n        pygame.draw.circle(screen, (0,0,0), PIVOT, 5, 0)\n        pygame.draw.circle(screen, (0,0,0), self.rect.center, BOBSIZE, 0)\n        pygame.draw.aaline(screen, (0,0,0), PIVOT, self.rect.center)\n        pygame.draw.line(screen, (0,0,0), (0, PIVOT[1]), (WINDOWSIZE, PIVOT[1]))\n\n    def update(self):\n        self.recomputeAngle()\n        screen.fill((255,255,255))\n        self.draw()\n\nbob = BobMass()\n\nTICK = USEREVENT + 2\npygame.time.set_timer(TICK, TIMETICK)\n\ndef input(events):\n    for event in events:\n        if event.type == QUIT:\n            sys.exit(0)\n        elif event.type == TICK:\n            bob.update()\n\nwhile True:\n    input(pygame.event.get())\n    pygame.display.flip()\n\n''' Python 3.6.5 code using Tkinter graphical user interface.''' \n\nfrom tkinter import *\nimport math\n\nclass Animation:\n    def __init__(self, gw):\n        self.window = gw\n        self.xoff, self.yoff = 300, 100\n        self.angle = 0\n        self.sina = math.sin(self.angle)\n        self.cosa = math.cos(self.angle)\n        self.rodhyp = 170\n        self.bobr = 30\n        self.bobhyp = self.rodhyp + self.bobr\n        self.rodx0, self.rody0 = self.xoff, self.yoff\n        self.ra = self.rodx0\n        self.rb = self.rody0\n        self.rc = self.xoff + self.rodhyp*self.sina\n        self.rd = self.yoff + self.rodhyp*self.cosa\n        self.ba = self.xoff - self.bobr + self.bobhyp*self.sina\n        self.bb = self.yoff - self.bobr + self.bobhyp*self.cosa\n        self.bc = self.xoff + self.bobr + self.bobhyp*self.sina\n        self.bd = self.yoff + self.bobr + self.bobhyp*self.cosa\n        self.da = math.pi / 360\n\n        # create / fill canvas:\n        self.cnv = Canvas(gw, bg='lemon chiffon')\n        self.cnv.pack(fill=BOTH, expand=True)\n\n        self.cnv.create_line(0, 100, 600, 100,\n                             fill='dodger blue',\n                             width=3)\n        radius = 8\n        self.cnv.create_oval(300-radius, 100-radius,\n                             300+radius, 100+radius,\n                             fill='navy')    \n\n        self.bob = self.cnv.create_oval(self.ba,\n                                        self.bb,\n                                        self.bc,\n                                        self.bd,\n                                        fill='red',\n                                        width=2)\n\n        self.rod = self.cnv.create_line(self.ra,\n                                        self.rb,\n                                        self.rc,\n                                        self.rd,\n                                        fill='dodger blue',\n                                        width=6)\n\n        self.animate()\n\n    def animate(self):\n        if abs(self.angle) > math.pi / 2:\n            self.da = - self.da\n        self.angle += self.da\n        self.sina = math.sin(self.angle)\n        self.cosa = math.cos(self.angle)\n        self.ra = self.rodx0\n        self.rb = self.rody0\n        self.rc = self.xoff + self.rodhyp*self.sina\n        self.rd = self.yoff + self.rodhyp*self.cosa\n        self.ba = self.xoff - self.bobr + self.bobhyp*self.sina\n        self.bb = self.yoff - self.bobr + self.bobhyp*self.cosa\n        self.bc = self.xoff + self.bobr + self.bobhyp*self.sina\n        self.bd = self.yoff + self.bobr + self.bobhyp*self.cosa\n        \n        self.cnv.coords(self.rod,\n                        self.ra,\n                        self.rb,\n                        self.rc,\n                        self.rd)\n        self.cnv.coords(self.bob,\n                        self.ba,\n                        self.bb,\n                        self.bc,\n                        self.bd)\n        self.window.update()\n        self.cnv.after(5, self.animate)\n         \nroot = Tk()\nroot.title('Pendulum')\nroot.geometry('600x400+100+50')\nroot.resizable(False, False)\na = Animation(root)\nroot.mainloop()\n\n", "perturbed_code": "\nfrom pygame.locals import *\nBOBSIZE = 15\nWINDOWSIZE = 250\nTIMETICK = 100\nimport pygame, sys\npygame.init()\nfrom math import sin, cos, radians\n\nclass BobMass(pygame.sprite.Sprite):\n\n    def __init__(self):\n        pygame.sprite.Sprite.__init__(self)\n        self.dtheta = 0\n        self.theta = 45\n        self.rect = pygame.Rect((PIVOT[0] - (cos(radians(self.theta)) * SWINGLENGTH)), (PIVOT[1] + (SWINGLENGTH * sin(radians(self.theta)))), 1, 1)\n        self.draw()\n\n    def recomputeAngle(self):\n        scaling = (3000.0 / (SWINGLENGTH ** 2))\n        firstDDtheta = (scaling * (- sin(radians(self.theta))))\n        midDtheta = (self.dtheta + firstDDtheta)\n        midtheta = (self.theta + ((self.dtheta + midDtheta) / 2.0))\n        midDDtheta = ((- sin(radians(midtheta))) * scaling)\n        midDtheta = (self.dtheta + ((midDDtheta + firstDDtheta) / 2))\n        midtheta = (((self.dtheta + midDtheta) / 2) + self.theta)\n        midDDtheta = (scaling * (- sin(radians(midtheta))))\n        lastDtheta = (midDtheta + midDDtheta)\n        lasttheta = (midtheta + ((lastDtheta + midDtheta) / 2.0))\n        lastDDtheta = ((- sin(radians(lasttheta))) * scaling)\n        lastDtheta = (((midDDtheta + lastDDtheta) / 2.0) + midDtheta)\n        lasttheta = (((lastDtheta + midDtheta) / 2.0) + midtheta)\n        self.dtheta = lastDtheta\n        self.theta = lasttheta\n        self.rect = pygame.Rect((PIVOT[0] - (SWINGLENGTH * sin(radians(self.theta)))), (PIVOT[1] + (cos(radians(self.theta)) * SWINGLENGTH)), 1, 1)\n\n    def draw(self):\n        pygame.draw.circle(screen, (0, 0, 0), PIVOT, 5, 0)\n        pygame.draw.circle(screen, (0, 0, 0), self.rect.center, BOBSIZE, 0)\n        pygame.draw.aaline(screen, (0, 0, 0), PIVOT, self.rect.center)\n        pygame.draw.line(screen, (0, 0, 0), (0, PIVOT[1]), (WINDOWSIZE, PIVOT[1]))\n\n    def update(self):\n        self.recomputeAngle()\n        screen.fill((255, 255, 255))\n        self.draw()\nwindow = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))\npygame.display.set_caption('Pendulum')\nbob = BobMass()\nTICK = (USEREVENT + 2)\nPIVOT = ((WINDOWSIZE / 2), (WINDOWSIZE / 10))\nscreen = pygame.display.get_surface()\nscreen.fill((255, 255, 255))\npygame.time.set_timer(TICK, TIMETICK)\n\ndef input(events):\n    for event in events:\n        if (QUIT == event.type):\n            sys.exit(0)\n        else:\n            if (TICK == event.type):\n                bob.update()\nSWINGLENGTH = (PIVOT[1] * 4)\nwhile True:\n    input(pygame.event.get())\n    pygame.display.flip()\n' Python 3.6.5 code using Tkinter graphical user interface.'\nfrom tkinter import *\nimport math\n\nclass Animation():\n\n    def __init__(self, gw):\n        self.window = gw\n        (self.xoff, self.yoff) = (300, 100)\n        self.angle = 0\n        self.sina = math.sin(self.angle)\n        self.cosa = math.cos(self.angle)\n        self.rodhyp = 170\n        self.bobr = 30\n        self.bobhyp = (self.rodhyp + self.bobr)\n        (self.rodx0, self.rody0) = (self.xoff, self.yoff)\n        self.ra = self.rodx0\n        self.rb = self.rody0\n        self.rc = (self.xoff + (self.rodhyp * self.sina))\n        self.rd = ((self.cosa * self.rodhyp) + self.yoff)\n        self.ba = ((self.xoff - self.bobr) + (self.sina * self.bobhyp))\n        self.bb = ((self.yoff - self.bobr) + (self.cosa * self.bobhyp))\n        self.bc = ((self.bobhyp * self.sina) + (self.bobr + self.xoff))\n        self.bd = ((self.bobr + self.yoff) + (self.bobhyp * self.cosa))\n        self.da = (math.pi / 360)\n        self.cnv = Canvas(gw, bg='lemon chiffon')\n        self.cnv.pack(fill=BOTH, expand=True)\n        self.cnv.create_line(0, 100, 600, 100, fill='dodger blue', width=3)\n        radius = 8\n        self.cnv.create_oval((300 - radius), (100 - radius), (300 + radius), (radius + 100), fill='navy')\n        self.bob = self.cnv.create_oval(self.ba, self.bb, self.bc, self.bd, fill='red', width=2)\n        self.rod = self.cnv.create_line(self.ra, self.rb, self.rc, self.rd, fill='dodger blue', width=6)\n        self.animate()\n\n    def animate(self):\n        if (abs(self.angle) > (math.pi / 2)):\n            self.da = (- self.da)\n        self.angle += self.da\n        self.sina = math.sin(self.angle)\n        self.cosa = math.cos(self.angle)\n        self.ra = self.rodx0\n        self.rb = self.rody0\n        self.rc = ((self.rodhyp * self.sina) + self.xoff)\n        self.rd = (self.yoff + (self.cosa * self.rodhyp))\n        self.ba = ((self.xoff - self.bobr) + (self.bobhyp * self.sina))\n        self.bb = ((self.bobhyp * self.cosa) + (self.yoff - self.bobr))\n        self.bc = ((self.bobr + self.xoff) + (self.sina * self.bobhyp))\n        self.bd = ((self.bobhyp * self.cosa) + (self.yoff + self.bobr))\n        self.cnv.coords(self.rod, self.ra, self.rb, self.rc, self.rd)\n        self.cnv.coords(self.bob, self.ba, self.bb, self.bc, self.bd)\n        self.window.update()\n        self.cnv.after(5, self.animate)\nroot = Tk()\nroot.title('Pendulum')\nroot.geometry('600x400+100+50')\nroot.resizable(False, False)\na = Animation(root)\nroot.mainloop()\n", "incomplete_perturbed_code": "from pygame.locals import *\nBOBSIZE = 15\nWINDOWSIZE = 250\nTIMETICK = 100\nimport pygame, sys\npygame.init()\nfrom math import sin, cos, radians\n\nclass BobMass(pygame.sprite.Sprite):\n\n    def __init__(self):\n        pass\n\n    def recomputeAngle(self):\n        pass\n\n    def draw(self):\n        pass\n\n    def update(self):\n        pass\nwindow = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))\npygame.display.set_caption('Pendulum')\nbob = BobMass()\nTICK = USEREVENT + 2\nPIVOT = (WINDOWSIZE / 2, WINDOWSIZE / 10)\nscreen = pygame.display.get_surface()\nscreen.fill((255, 255, 255))\npygame.time.set_timer(TICK, TIMETICK)\n\ndef input(events):\n    pass\nSWINGLENGTH = PIVOT[1] * 4\nwhile True:\n    input(pygame.event.get())\n    pygame.display.flip()\n' Python 3.6.5 code using Tkinter graphical user interface.'\nfrom tkinter import *\nimport math\n\nclass Animation:\n\n    def __init__(self, gw):\n        pass\n\n    def animate(self):\n        pass\nroot = Tk()\nroot.title('Pendulum')\nroot.geometry('600x400+100+50')\nroot.resizable(False, False)\na = Animation(root)\nroot.mainloop()", "adversarial_score": 2, "original_score": 3, "search_time": 4462.054520845413, "stats": {"total_attempts": 100, "unique_perturbations": 100, "cache_hits": 0, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "from pygame.locals import *\nBOBSIZE = 15\nWINDOWSIZE = 250\nTIMETICK = 100\nimport pygame, sys\npygame.init()\nfrom math import sin, cos, radians\n\nclass BobMass(pygame.sprite.Sprite):\n\n    def __init__(self):\n        super().__init__()\n        self.image = pygame.Surface((BOBSIZE, BOBSIZE))\n        self.image.fill((0, 0, 255))\n        self.rect = self.image.get_rect()\n        self.rect.center = (WINDOWSIZE / 2, WINDOWSIZE / 2)\n        self.angle = 0\n        self.gravity = 0.5\n        self.swinglength = 100\n\n    def recomputeAngle(self):\n        self.angle = (math.pi / 180) * (self.gravity * self.swinglength * 0.98)\n\n    def draw(self):\n        x = WINDOWSIZE / 2 + self.swinglength * cos(self.angle)\n        y = WINDOWSIZE / 2 - self.swinglength * sin(self.angle)\n        self.rect.center = (x, y)\n\n    def update(self):\n        self.recomputeAngle()\n        self.angle += 0.01\n\n\nwindow = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))\npygame.display.set_caption('Pendulum')\nbob = BobMass()\nTICK = USEREVENT + 2\nPIVOT = (WINDOWSIZE / 2, WINDOWSIZE / 10)\nscreen = pygame.display.get_surface()\nscreen.fill((255, 255, 255))\npygame.time.set_timer(TICK, TIMETICK)\n\ndef input(events):\n    pass\nSWINGLENGTH = PIVOT[1] * 4\nwhile True:\n    input(pygame.event.get())\n    pygame.display.flip()\n\n' Python 3.6.5 code using Tkinter graphical user interface.'\nfrom tkinter import *\nimport math\n\nclass Animation:\n\n    def __init__(self, gw):\n        self.gw = gw\n\n    def animate(self):\n        pass\nroot = Tk()\nroot.title('Pendulum')\nroot.geometry('600x400+100+50')\nroot.resizable(False, False)\na = Animation(root)\nroot.mainloop()", "score_distribution": [2, 3, 2, 2, 3, 2, 3, 3, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 2, 3, 2, 2, 2, 3, 2, 2, 3, 3, 2, 2, 3, 2, 2, 3, 2, 2, 2, 3, 3, 3, 3, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 3, 2, 2, 3, 2, 2, 3, 2, 2, 3, 2, 2, 2, 2, 3, 2]}
{"lang_cluster": "Python", "source_code": "\n\n'''\n The 24 Game\n\n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and / operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n\n An answer of \"q\" will quit the game.\n An answer of \"!\" will generate a new set of four digits.\n Otherwise you are repeatedly asked for an expression until it evaluates to 24\n\n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n\n'''\n\nfrom __future__ import division, print_function\nimport random, ast, re\nimport sys\n\nif sys.version_info[0] < 3: input = raw_input\n\ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n\ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n\ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n\ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            print (\"New digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n\nif __name__ == '__main__': main()\n\n\n", "human_summarization": "generate and display four random digits from 1 to 9, prompt the player to form an arithmetic expression using these digits exactly once, and check if the expression evaluates to 24. The allowed operations are addition, subtraction, multiplication, and division with floating point or rational arithmetic. The program does not generate or test the validity of the expression.", "id": 4803, "incomplete_code": "\"\"\"\n The 24 Game\n\n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and / operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n\n An answer of \"q\" will quit the game.\n An answer of \"!\" will generate a new set of four digits.\n Otherwise you are repeatedly asked for an expression until it evaluates to 24\n\n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n\n\"\"\"\nfrom __future__ import division, print_function\nimport random, ast, re\nimport sys\nif sys.version_info[0] < 3:\n    input = raw_input\n\ndef choose4():\n    \"\"\"four random digits >0 as characters\"\"\"\n    pass\n\ndef welcome(digits):\n    pass\n\ndef check(answer, digits):\n    pass\n\ndef main():\n    pass\nif __name__ == '__main__':\n    main()", "original_code": "\n\n'''\n The 24 Game\n\n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and / operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n\n An answer of \"q\" will quit the game.\n An answer of \"!\" will generate a new set of four digits.\n Otherwise you are repeatedly asked for an expression until it evaluates to 24\n\n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n\n'''\n\nfrom __future__ import division, print_function\nimport random, ast, re\nimport sys\n\nif sys.version_info[0] < 3: input = raw_input\n\ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n\ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n\ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n\ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            print (\"New digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n\nif __name__ == '__main__': main()\n\n\n", "perturbed_code": "\nfrom __future__ import division, print_function\nimport random, ast, re\nimport sys\n\ndef main():\n    trial = 0\n    while (not (chk and (ans == 24))):\n        if (not chk):\n            print((\"The input '%s' was wonky!\" % answer))\n        else:\n            if (24 == ans):\n                print('Thats right!')\n            ans = eval(answer)\n            print(' = ', ans)\n        if (answer == '!'):\n            continue\n            digits = choose4()\n            print('New digits:', ' '.join(digits))\n        if ('q' == answer.lower()):\n            break\n        trial += 1\n        answer = input(('Expression %i: ' % trial))\n        chk = check(answer, digits)\n    chk = ans = False\n    digits = choose4()\n    welcome(digits)\n    answer = ''\n    print('Thank you and goodbye')\n\ndef check(answer, digits):\n    allowed = set((''.join(digits) + '() +-*/\\t'))\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    ok = (all(((ch in allowed) for ch in answer)) and all(((answer.count(dig) == digits.count(dig)) for dig in set(digits))) and (not re.search('\\\\d\\\\d', answer)))\n    return ok\n'\\n The 24 Game\\n\\n Given any four digits in the range 1 to 9, which may have repetitions,\\n Using just the +, -, *, and / operators; and the possible use of\\n brackets, (), show how to make an answer of 24.\\n\\n An answer of \"q\" will quit the game.\\n An answer of \"!\" will generate a new set of four digits.\\n Otherwise you are repeatedly asked for an expression until it evaluates to 24\\n\\n Note: you cannot form multiple digit numbers from the supplied digits,\\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\\n\\n'\n\ndef welcome(digits):\n    print(__doc__)\n    print((' '.join(digits) + 'Your four digits: '))\nif (sys.version_info[0] < 3):\n    input = raw_input\n\ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1, 9)) for i in range(4)]\nif ('__main__' == __name__):\n    main()\n", "incomplete_perturbed_code": "from __future__ import division, print_function\nimport random, ast, re\nimport sys\n\ndef main():\n    pass\n\ndef check(answer, digits):\n    pass\n'\\n The 24 Game\\n\\n Given any four digits in the range 1 to 9, which may have repetitions,\\n Using just the +, -, *, and / operators; and the possible use of\\n brackets, (), show how to make an answer of 24.\\n\\n An answer of \"q\" will quit the game.\\n An answer of \"!\" will generate a new set of four digits.\\n Otherwise you are repeatedly asked for an expression until it evaluates to 24\\n\\n Note: you cannot form multiple digit numbers from the supplied digits,\\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\\n\\n'\n\ndef welcome(digits):\n    pass\nif sys.version_info[0] < 3:\n    input = raw_input\n\ndef choose4():\n    \"\"\"four random digits >0 as characters\"\"\"\n    pass\nif '__main__' == __name__:\n    main()", "adversarial_score": 2, "original_score": 2, "search_time": 2842.538442850113, "stats": {"total_attempts": 100, "unique_perturbations": 100, "cache_hits": 0, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "from __future__ import division, print_function\nimport random, ast, re\nimport sys\n\ndef main():\n    digits = choose4()\n    welcome(digits)\n    while True:\n        expression = input(\"Enter an expression: \")\n        if expression == 'q':\n            break\n        if expression == '!':\n            digits = choose4()\n            welcome(digits)\n            continue\n        try:\n            answer = eval(expression, {'__builtins__': None}, {'digits': digits})\n            if check(answer, digits):\n                print(\"Congratulations! You got 24.\")\n                break\n        except (SyntaxError, NameError, TypeError, ZeroDivisionError):\n            print(\"Invalid expression.\")\n\ndef check(answer, digits):\n    return abs(answer - 24) < 1e-6\n\ndef welcome(digits):\n    print(\"Given any four digits in the range 1 to 9, which may have repetitions,\")\n    print(\"Using just the +, -, *, and / operators; and the possible use of\")\n    print(\"brackets, (), show how to make an answer of 24.\")\n    print(\"\\nAn answer of \\\"q\\\" will quit the game.\")\n    print(\"An answer of \\\"!\\\" will generate a new set of four digits.\")\n    print(\"Otherwise you are repeatedly asked for an expression until it evaluates to 24\")\n    print(\"\\nNote: you cannot form multiple digit numbers from the supplied digits,\")\n    print(\"so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\\n\")\n    print(f\"Digits: {digits}\")\n\ndef choose4():\n    \"\"\"four random digits >0 as characters\"\"\"\n    return [random.randint(1, 9) for _ in range(4)]\n\nif sys.version_info[0] < 3:\n    input = raw_input\n\nif '__main__' == __name__:\n    main()", "score_distribution": [2, 2, 3, 3, 2, 3, 3, 3, 2, 3, 3, 3, 3, 3, 2, 3, 2, 3, 3, 3, 2, 3, 3, 2, 2, 3, 3, 3, 2, 2, 3, 3, 2, 2, 3, 3, 3, 2, 3, 3, 2, 2, 3, 2, 3, 3, 2, 3, 3, 2, 2, 2, 3, 3, 2, 3, 3, 2, 3, 3, 2, 2, 3, 2, 2, 2, 3, 3, 2, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3]}
{"lang_cluster": "Python", "source_code": "\n'''Common sorted list'''\n\nfrom itertools import chain\n\n\n# ------------------------- TEST -------------------------\n# main\u00a0:: IO ()\ndef main():\n    '''Sorted union of lists'''\n\n    print(\n        sorted(nub(concat([\n            [5, 1, 3, 8, 9, 4, 8, 7],\n            [3, 5, 9, 8, 4],\n            [1, 3, 7, 9]\n        ])))\n    )\n\n\n# ----------------------- GENERIC ------------------------\n\n# concat\u00a0:: [[a]] -> [a]\n# concat\u00a0:: [String] -> String\ndef concat(xs):\n    '''The concatenation of all the elements in a list.\n    '''\n    return list(chain(*xs))\n\n\n# nub\u00a0:: [a] -> [a]\ndef nub(xs):\n    '''A list containing the same elements as xs,\n       without duplicates, in the order of their\n       first occurrence.\n    '''\n    return list(dict.fromkeys(xs))\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\n\n", "human_summarization": "generates a common sorted list with unique elements from multiple integer arrays.", "id": 4807, "incomplete_code": "\"\"\"Common sorted list\"\"\"\nfrom itertools import chain\n\ndef main():\n    \"\"\"Sorted union of lists\"\"\"\n    pass\n\ndef concat(xs):\n    \"\"\"The concatenation of all the elements in a list.\n    \"\"\"\n    pass\n\ndef nub(xs):\n    \"\"\"A list containing the same elements as xs,\n       without duplicates, in the order of their\n       first occurrence.\n    \"\"\"\n    pass\nif __name__ == '__main__':\n    main()", "original_code": "\n'''Common sorted list'''\n\nfrom itertools import chain\n\n\n# ------------------------- TEST -------------------------\n# main\u00a0:: IO ()\ndef main():\n    '''Sorted union of lists'''\n\n    print(\n        sorted(nub(concat([\n            [5, 1, 3, 8, 9, 4, 8, 7],\n            [3, 5, 9, 8, 4],\n            [1, 3, 7, 9]\n        ])))\n    )\n\n\n# ----------------------- GENERIC ------------------------\n\n# concat\u00a0:: [[a]] -> [a]\n# concat\u00a0:: [String] -> String\ndef concat(xs):\n    '''The concatenation of all the elements in a list.\n    '''\n    return list(chain(*xs))\n\n\n# nub\u00a0:: [a] -> [a]\ndef nub(xs):\n    '''A list containing the same elements as xs,\n       without duplicates, in the order of their\n       first occurrence.\n    '''\n    return list(dict.fromkeys(xs))\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\n\n", "perturbed_code": "\n'Common sorted list'\n\ndef main():\n    'Sorted union of lists'\n    print(sorted(nub(concat([[5, 1, 3, 8, 9, 4, 8, 7], [3, 5, 9, 8, 4], [1, 3, 7, 9]]))))\nfrom itertools import chain\n\ndef nub(xs):\n    'A list containing the same elements as xs,\\n       without duplicates, in the order of their\\n       first occurrence.\\n    '\n    return list(dict.fromkeys(xs))\n\ndef concat(xs):\n    'The concatenation of all the elements in a list.\\n    '\n    return list(chain(*xs))\nif ('__main__' == __name__):\n    main()\n", "incomplete_perturbed_code": "\"\"\"Common sorted list\"\"\"\n\ndef main():\n    \"\"\"Sorted union of lists\"\"\"\n    pass\nfrom itertools import chain\n\ndef nub(xs):\n    \"\"\"A list containing the same elements as xs,\n       without duplicates, in the order of their\n       first occurrence.\n    \"\"\"\n    pass\n\ndef concat(xs):\n    \"\"\"The concatenation of all the elements in a list.\n    \"\"\"\n    pass\nif '__main__' == __name__:\n    main()", "adversarial_score": 2, "original_score": 3, "search_time": 502.8278284072876, "stats": {"total_attempts": 100, "unique_perturbations": 47, "cache_hits": 51, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "\"\"\"Common sorted list\"\"\"\n\ndef main():\n    \"\"\"Sorted union of lists\"\"\"\n    arr1 = [1, 2, 3, 4, 5]\n    arr2 = [3, 4, 5, 6, 7]\n    arr3 = [1, 3, 5, 7, 9]\n    combined = list(chain(arr1, arr2, arr3))\n    unique_sorted = sorted(nub(combined))\n    print(unique_sorted)\npass\nfrom itertools import chain\n\ndef nub(xs):\n    \"\"\"A list containing the same elements as xs,\n       without duplicates, in the order of their\n       first occurrence.\n    \"\"\"\n    seen = set()\n    result = []\n    for x in xs:\n        if x not in seen:\n            seen.add(x)\n            result.append(x)\n    return result\npass\n\ndef concat(xs):\n    \"\"\"The concatenation of all the elements in a list.\n    \"\"\"\n    return sum(xs, [])\npass\nif '__main__' == __name__:\n    main()\npass", "score_distribution": [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 2, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3]}
{"lang_cluster": "Python", "source_code": "\n# Works with: Python version 3.7\nfrom functools import partial\nimport tkinter as tk\n\ndef on_click(label: tk.Label,\n             counter: tk.IntVar) -> None:\n    counter.set(counter.get() + 1)\n    label[\"text\"] = f\"Number of clicks: {counter.get()}\"\n\ndef main():\n    window = tk.Tk()\n    window.geometry(\"200x50+100+100\")\n    label = tk.Label(master=window,\n                     text=\"There have been no clicks yet\")\n    label.pack()\n    counter = tk.IntVar()\n    update_counter = partial(on_click,\n                             label=label,\n                             counter=counter)\n    button = tk.Button(master=window,\n                       text=\"click me\",\n                       command=update_counter)\n    button.pack()\n    window.mainloop()\n\nif __name__ == '__main__':\n    main()\n\n\nimport tkinter as tk\n\nclass ClickCounter(tk.Frame):\n    def __init__(self, master=None):\n        super().__init__(master)\n        tk.Pack.config(self)\n        self.label = tk.Label(self, text='There have been no clicks yet')\n        self.label.pack()\n        self.button = tk.Button(self,\n                                text='click me',\n                                command=self.click)\n        self.button.pack()\n        self.count = 0\n\n    def click(self):\n        self.count += 1\n        self.label['text'] = f'Number of clicks: {self.count}'\n\n\nif __name__ == \"__main__\":\n    ClickCounter().mainloop()\n\nfrom functools import partial\nfrom itertools import count\n\nfrom PyQt5.QtWidgets import (QApplication,\n                             QLabel,\n                             QPushButton,\n                             QWidget)\nfrom PyQt5.QtCore import QRect\n\nLABEL_GEOMETRY = QRect(0, 15, 200, 25)\nBUTTON_GEOMETRY = QRect(50, 50, 100, 25)\n\n\ndef on_click(_, label, counter=count(1)):\n    label.setText(f\"Number of clicks: {next(counter)}\")\n\n\ndef main():\n    application = QApplication([])\n    window = QWidget()\n    label = QLabel(text=\"There have been no clicks yet\",\n                   parent=window)\n    label.setGeometry(LABEL_GEOMETRY)\n    button = QPushButton(text=\"click me\",\n                         parent=window)\n    button.setGeometry(BUTTON_GEOMETRY)\n    update_counter = partial(on_click,\n                             label=label)\n    button.clicked.connect(update_counter)\n    window.show()\n    application.lastWindowClosed.connect(window.close)\n    application.exec_()\n\n\nif __name__ == '__main__':\n    main()\n\nimport wx\n\n\nclass ClickCounter(wx.Frame):\n    def __init__(self):\n        super().__init__(parent=None)\n        self.count = 0\n        self.button = wx.Button(parent=self,\n                                label=\"Click me!\")\n        self.label = wx.StaticText(parent=self,\n                                   label=\"There have been no clicks yet\")\n        self.Bind(event=wx.EVT_BUTTON,\n                  handler=self.click,\n                  source=self.button)\n\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(window=self.button,\n                       proportion=1,\n                       flag=wx.EXPAND)\n        self.sizer.Add(window=self.label,\n                       proportion=1,\n                       flag=wx.EXPAND)\n        self.SetSizer(self.sizer)\n        self.sizer.Fit(self)\n\n    def click(self, _):\n        self.count += 1\n        self.label.SetLabel(f\"Count: {self.count}\")\n\n\nif __name__ == '__main__':\n    app = wx.App()\n    frame = ClickCounter()\n    frame.Show()\n    app.MainLoop()\n\n", "human_summarization": "implement a windowed application with a label and a button. The label initially displays \"There have been no clicks yet\". When the button labeled \"click me\" is clicked, the label updates to show the number of times the button has been clicked.", "id": 4812, "incomplete_code": "from functools import partial\nimport tkinter as tk\n\ndef on_click(label: tk.Label, counter: tk.IntVar) -> None:\n    pass\n\ndef main():\n    pass\nif __name__ == '__main__':\n    main()\nimport tkinter as tk\n\nclass ClickCounter(tk.Frame):\n\n    def __init__(self, master=None):\n        pass\n\n    def click(self):\n        pass\nif __name__ == '__main__':\n    ClickCounter().mainloop()\nfrom functools import partial\nfrom itertools import count\nfrom PyQt5.QtWidgets import QApplication, QLabel, QPushButton, QWidget\nfrom PyQt5.QtCore import QRect\nLABEL_GEOMETRY = QRect(0, 15, 200, 25)\nBUTTON_GEOMETRY = QRect(50, 50, 100, 25)\n\ndef on_click(_, label, counter=count(1)):\n    pass\n\ndef main():\n    pass\nif __name__ == '__main__':\n    main()\nimport wx\n\nclass ClickCounter(wx.Frame):\n\n    def __init__(self):\n        pass\n\n    def click(self, _):\n        pass\nif __name__ == '__main__':\n    app = wx.App()\n    frame = ClickCounter()\n    frame.Show()\n    app.MainLoop()", "original_code": "\n# Works with: Python version 3.7\nfrom functools import partial\nimport tkinter as tk\n\ndef on_click(label: tk.Label,\n             counter: tk.IntVar) -> None:\n    counter.set(counter.get() + 1)\n    label[\"text\"] = f\"Number of clicks: {counter.get()}\"\n\ndef main():\n    window = tk.Tk()\n    window.geometry(\"200x50+100+100\")\n    label = tk.Label(master=window,\n                     text=\"There have been no clicks yet\")\n    label.pack()\n    counter = tk.IntVar()\n    update_counter = partial(on_click,\n                             label=label,\n                             counter=counter)\n    button = tk.Button(master=window,\n                       text=\"click me\",\n                       command=update_counter)\n    button.pack()\n    window.mainloop()\n\nif __name__ == '__main__':\n    main()\n\n\nimport tkinter as tk\n\nclass ClickCounter(tk.Frame):\n    def __init__(self, master=None):\n        super().__init__(master)\n        tk.Pack.config(self)\n        self.label = tk.Label(self, text='There have been no clicks yet')\n        self.label.pack()\n        self.button = tk.Button(self,\n                                text='click me',\n                                command=self.click)\n        self.button.pack()\n        self.count = 0\n\n    def click(self):\n        self.count += 1\n        self.label['text'] = f'Number of clicks: {self.count}'\n\n\nif __name__ == \"__main__\":\n    ClickCounter().mainloop()\n\nfrom functools import partial\nfrom itertools import count\n\nfrom PyQt5.QtWidgets import (QApplication,\n                             QLabel,\n                             QPushButton,\n                             QWidget)\nfrom PyQt5.QtCore import QRect\n\nLABEL_GEOMETRY = QRect(0, 15, 200, 25)\nBUTTON_GEOMETRY = QRect(50, 50, 100, 25)\n\n\ndef on_click(_, label, counter=count(1)):\n    label.setText(f\"Number of clicks: {next(counter)}\")\n\n\ndef main():\n    application = QApplication([])\n    window = QWidget()\n    label = QLabel(text=\"There have been no clicks yet\",\n                   parent=window)\n    label.setGeometry(LABEL_GEOMETRY)\n    button = QPushButton(text=\"click me\",\n                         parent=window)\n    button.setGeometry(BUTTON_GEOMETRY)\n    update_counter = partial(on_click,\n                             label=label)\n    button.clicked.connect(update_counter)\n    window.show()\n    application.lastWindowClosed.connect(window.close)\n    application.exec_()\n\n\nif __name__ == '__main__':\n    main()\n\nimport wx\n\n\nclass ClickCounter(wx.Frame):\n    def __init__(self):\n        super().__init__(parent=None)\n        self.count = 0\n        self.button = wx.Button(parent=self,\n                                label=\"Click me!\")\n        self.label = wx.StaticText(parent=self,\n                                   label=\"There have been no clicks yet\")\n        self.Bind(event=wx.EVT_BUTTON,\n                  handler=self.click,\n                  source=self.button)\n\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(window=self.button,\n                       proportion=1,\n                       flag=wx.EXPAND)\n        self.sizer.Add(window=self.label,\n                       proportion=1,\n                       flag=wx.EXPAND)\n        self.SetSizer(self.sizer)\n        self.sizer.Fit(self)\n\n    def click(self, _):\n        self.count += 1\n        self.label.SetLabel(f\"Count: {self.count}\")\n\n\nif __name__ == '__main__':\n    app = wx.App()\n    frame = ClickCounter()\n    frame.Show()\n    app.MainLoop()\n\n", "perturbed_code": "\nfrom functools import partial\n\nclass ClickCounter(tk.Frame):\n\n    def __init__(self, master=None):\n        super().__init__(master)\n        tk.Pack.config(self)\n        self.label = tk.Label(self, text='There have been no clicks yet')\n        self.label.pack()\n        self.button = tk.Button(self, text='click me', command=self.click)\n        self.button.pack()\n        self.count = 0\n\n    def click(self):\n        self.count += 1\n        self.label['text'] = f'Number of clicks: {self.count}'\nif ('__main__' == __name__):\n    main()\nif ('__main__' == __name__):\n    ClickCounter().mainloop()\nimport tkinter as tk\nfrom functools import partial\nfrom itertools import count\nfrom PyQt5.QtWidgets import QApplication, QLabel, QPushButton, QWidget\nfrom PyQt5.QtCore import QRect\nLABEL_GEOMETRY = QRect(0, 15, 200, 25)\n\ndef main():\n    window = tk.Tk()\n    window.geometry('200x50+100+100')\n    label = tk.Label(master=window, text='There have been no clicks yet')\n    label.pack()\n    counter = tk.IntVar()\n    update_counter = partial(on_click, label=label, counter=counter)\n    button = tk.Button(master=window, text='click me', command=update_counter)\n    window.mainloop()\n    button.pack()\nBUTTON_GEOMETRY = QRect(50, 50, 100, 25)\nif (__name__ == '__main__'):\n    main()\nimport tkinter as tk\n\ndef on_click(label, counter) -> None:\n    counter.set((counter.get() + 1))\n    label['text'] = f'Number of clicks: {counter.get()}'\n\ndef on_click(_, label, counter=count(1)):\n    label.setText(f'Number of clicks: {next(counter)}')\n\ndef main():\n    application = QApplication([])\n    window = QWidget()\n    label = QLabel(text='There have been no clicks yet', parent=window)\n    label.setGeometry(LABEL_GEOMETRY)\n    button = QPushButton(text='click me', parent=window)\n    button.setGeometry(BUTTON_GEOMETRY)\n    update_counter = partial(on_click, label=label)\n    button.clicked.connect(update_counter)\n    window.show()\n    application.lastWindowClosed.connect(window.close)\n    application.exec_()\nimport wx\n\nclass ClickCounter(wx.Frame):\n\n    def __init__(self):\n        super().__init__(parent=None)\n        self.count = 0\n        self.button = wx.Button(parent=self, label='Click me!')\n        self.label = wx.StaticText(parent=self, label='There have been no clicks yet')\n        self.Bind(event=wx.EVT_BUTTON, handler=self.click, source=self.button)\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(window=self.button, proportion=1, flag=wx.EXPAND)\n        self.sizer.Add(window=self.label, proportion=1, flag=wx.EXPAND)\n        self.SetSizer(self.sizer)\n        self.sizer.Fit(self)\n\n    def click(self, _):\n        self.count += 1\n        self.label.SetLabel(f'Count: {self.count}')\nif ('__main__' == __name__):\n    app = wx.App()\n    frame = ClickCounter()\n    frame.Show()\n    app.MainLoop()\n", "incomplete_perturbed_code": "from functools import partial\n\nclass ClickCounter(tk.Frame):\n\n    def __init__(self, master=None):\n        pass\n\n    def click(self):\n        pass\nif '__main__' == __name__:\n    main()\nif '__main__' == __name__:\n    ClickCounter().mainloop()\nimport tkinter as tk\nfrom functools import partial\nfrom itertools import count\nfrom PyQt5.QtWidgets import QApplication, QLabel, QPushButton, QWidget\nfrom PyQt5.QtCore import QRect\nLABEL_GEOMETRY = QRect(0, 15, 200, 25)\n\ndef main():\n    pass\nBUTTON_GEOMETRY = QRect(50, 50, 100, 25)\nif __name__ == '__main__':\n    main()\nimport tkinter as tk\n\ndef on_click(label, counter) -> None:\n    pass\n\ndef on_click(_, label, counter=count(1)):\n    pass\n\ndef main():\n    pass\nimport wx\n\nclass ClickCounter(wx.Frame):\n\n    def __init__(self):\n        pass\n\n    def click(self, _):\n        pass\nif '__main__' == __name__:\n    app = wx.App()\n    frame = ClickCounter()\n    frame.Show()\n    app.MainLoop()", "adversarial_score": 3, "original_score": 4, "search_time": 3790.9698083400726, "stats": {"total_attempts": 100, "unique_perturbations": 97, "cache_hits": 3, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "import tkinter as tk\nfrom functools import partial\nfrom itertools import count\n\nclass ClickCounter(tk.Frame):\n\n    def __init__(self, master=None):\n        super().__init__(master)\n        self.counter = count(1)\n        self.label_text = \"There have been no clicks yet\"\n        self.label = tk.Label(self, text=self.label_text, relief=tk.RIDGE, bd=2)\n        self.label.pack(pady=10)\n        self.button = tk.Button(self, text=\"click me\", command=self.click)\n        self.button.pack(pady=10)\n\n    def click(self):\n        self.label_text = f\"Clicked {next(self.counter)} times\"\n        self.label.config(text=self.label_text)\n\nif '__main__' == __name__:\n    main()\nimport tkinter as tk\nfrom functools import partial\nfrom itertools import count\nfrom PyQt5.QtWidgets import QApplication, QLabel, QPushButton, QWidget\nfrom PyQt5.QtCore import QRect\n\nLABEL_GEOMETRY = QRect(0, 15, 200, 25)\n\ndef main():\n    app = QApplication([])\n    root = QWidget()\n    root.setWindowTitle(\"Click Counter\")\n    label = QLabel(\"There have been no clicks yet\")\n    label.setGeometry(LABEL_GEOMETRY)\n    button = QPushButton(\"click me\")\n    button.setGeometry(QRect(50, 50, 100, 25))\n    button.clicked.connect(lambda: on_click(label, None))\n\n    def on_click(label, counter):\n        label.setText(\"Clicked 0 times\")\n\n    root.show()\n    app.exec_()\n\nBUTTON_GEOMETRY = QRect(50, 50, 100, 25)\nif __name__ == '__main__':\n    main()\nimport tkinter as tk\n\ndef on_click(label, counter) -> None:\n    label.config(text=f\"Clicked {counter}\")\n\ndef on_click(_, label, counter=count(1)):\n    label.config(text=f\"Clicked {counter.next()}\")\n\ndef main():\n    root = tk.Tk()\n    root.title(\"Click Counter\")\n\n    label = tk.Label(root, text=\"There have been no clicks yet\", relief=tk.RAISED, bd=2)\n    label.pack(pady=10)\n\n    button = tk.Button(root, text=\"click me\", command=on_click)\n    button.pack(pady=10)\n\n    root.mainloop()\nimport wx\n\nclass ClickCounter(wx.Frame):\n\n    def __init__(self):\n        super().__init__(None, title=\"Click Counter\")\n        self.panel = wx.Panel(self)\n        self.label = wx.StaticText(self.panel, label=\"There have been no clicks yet\", style=wx.ALIGN_CENTRE)\n        self.label.SetPosition((50, 50))\n        self.button = wx.Button(self.panel, label=\"click me\")\n        self.button.Bind(wx.EVT_BUTTON, self.on_click)\n\n    def click(self, event):\n        self.label.SetLabel(f\"Clicked {self.click_count} times\")\n        self.click_count += 1\n\n    click_count = 0\n\n    def on_click(self, event):\n        self.click(event)\nif '__main__' == __name__:\n    app = wx.App()\n    frame = ClickCounter()\n    frame.Show()\n    app.MainLoop()", "score_distribution": [4, 4, 4, 4, 4, 3, 3, 4, 3, 4, 4, 4, 3, 4, 3, 4, 4, 4, 4, 4, 3, 3, 4, 4, 3, 3, 4, 3, 3, 4, 3, 3, 3, 3, 3, 4, 4, 3, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 3, 4, 3, 4, 4, 4, 4, 4, 3, 3, 4, 4, 4, 3, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 3, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 4, 4, 3, 4, 3, 4, 4]}
{"lang_cluster": "Python", "source_code": "\n# Works with: Python version 3'''Vigenere encryption and decryption'''\n\nfrom itertools import starmap, cycle\n\n\ndef encrypt(message, key):\n    '''Vigenere encryption of message using key.'''\n\n    # Converted to uppercase.\n    # Non-alpha characters stripped out.\n    message = filter(str.isalpha, message.upper())\n\n    def enc(c, k):\n        '''Single letter encryption.'''\n\n        return chr(((ord(k) + ord(c) - 2 * ord('A')) % 26) + ord('A'))\n\n    return ''.join(starmap(enc, zip(message, cycle(key))))\n\n\ndef decrypt(message, key):\n    '''Vigenere decryption of message using key.'''\n\n    def dec(c, k):\n        '''Single letter decryption.'''\n\n        return chr(((ord(c) - ord(k) - 2 * ord('A')) % 26) + ord('A'))\n\n    return ''.join(starmap(dec, zip(message, cycle(key))))\n\n\ndef main():\n    '''Demonstration'''\n\n    text = 'Beware the Jabberwock, my son! The jaws that bite, ' + (\n           'the claws that catch!'\n    )\n    key = 'VIGENERECIPHER'\n\n    encr = encrypt(text, key)\n    decr = decrypt(encr, key)\n\n    print(text)\n    print(encr)\n    print(decr)\n\n\nif __name__ == '__main__':\n    main()\n\n\n", "human_summarization": "Implement both encryption and decryption of a Vigen\u00e8re cipher. The codes handle keys and text of unequal length, capitalize all characters, and discard non-alphabetic characters. Any different handling of non-alphabetic characters is noted.", "id": 4814, "incomplete_code": "from itertools import starmap, cycle\n\ndef encrypt(message, key):\n    \"\"\"Vigenere encryption of message using key.\"\"\"\n    pass\n\ndef decrypt(message, key):\n    \"\"\"Vigenere decryption of message using key.\"\"\"\n    pass\n\ndef main():\n    \"\"\"Demonstration\"\"\"\n    pass\nif __name__ == '__main__':\n    main()", "original_code": "\n# Works with: Python version 3'''Vigenere encryption and decryption'''\n\nfrom itertools import starmap, cycle\n\n\ndef encrypt(message, key):\n    '''Vigenere encryption of message using key.'''\n\n    # Converted to uppercase.\n    # Non-alpha characters stripped out.\n    message = filter(str.isalpha, message.upper())\n\n    def enc(c, k):\n        '''Single letter encryption.'''\n\n        return chr(((ord(k) + ord(c) - 2 * ord('A')) % 26) + ord('A'))\n\n    return ''.join(starmap(enc, zip(message, cycle(key))))\n\n\ndef decrypt(message, key):\n    '''Vigenere decryption of message using key.'''\n\n    def dec(c, k):\n        '''Single letter decryption.'''\n\n        return chr(((ord(c) - ord(k) - 2 * ord('A')) % 26) + ord('A'))\n\n    return ''.join(starmap(dec, zip(message, cycle(key))))\n\n\ndef main():\n    '''Demonstration'''\n\n    text = 'Beware the Jabberwock, my son! The jaws that bite, ' + (\n           'the claws that catch!'\n    )\n    key = 'VIGENERECIPHER'\n\n    encr = encrypt(text, key)\n    decr = decrypt(encr, key)\n\n    print(text)\n    print(encr)\n    print(decr)\n\n\nif __name__ == '__main__':\n    main()\n\n\n", "perturbed_code": "\n\ndef main():\n    'Demonstration'\n    key = 'VIGENERECIPHER'\n    text = ('the claws that catch!' + 'Beware the Jabberwock, my son! The jaws that bite, ')\n    encr = encrypt(text, key)\n    print(text)\n    decr = decrypt(encr, key)\n    print(encr)\n    print(decr)\nif (__name__ == '__main__'):\n    main()\nfrom itertools import starmap, cycle\n\ndef decrypt(message, key):\n    'Vigenere decryption of message using key.'\n\n    def dec(c, k):\n        'Single letter decryption.'\n        return chr((ord('A') + (((ord(c) - ord(k)) - (2 * ord('A'))) % 26)))\n    return ''.join(starmap(dec, zip(message, cycle(key))))\n\ndef encrypt(message, key):\n    'Vigenere encryption of message using key.'\n    message = filter(str.isalpha, message.upper())\n\n    def enc(c, k):\n        'Single letter encryption.'\n        return chr((ord('A') + (((ord(c) + ord(k)) - (ord('A') * 2)) % 26)))\n    return ''.join(starmap(enc, zip(message, cycle(key))))\n", "incomplete_perturbed_code": "def main():\n    \"\"\"Demonstration\"\"\"\n    pass\nif __name__ == '__main__':\n    main()\nfrom itertools import starmap, cycle\n\ndef decrypt(message, key):\n    \"\"\"Vigenere decryption of message using key.\"\"\"\n    pass\n\ndef encrypt(message, key):\n    \"\"\"Vigenere encryption of message using key.\"\"\"\n    pass", "adversarial_score": 2, "original_score": 3, "search_time": 1374.6832103729248, "stats": {"total_attempts": 100, "unique_perturbations": 99, "cache_hits": 1, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "def main():\n    \"\"\"Demonstration\"\"\"\n    pass\nif __name__ == '__main__':\n    main()\nfrom itertools import starmap, cycle\n\ndef decrypt(message, key):\n    \"\"\"Vigenere decryption of message using key.\"\"\"\n    message = ''.join(filter(str.isalpha, message)).upper()\n    key = ''.join(filter(str.isalpha, key)).upper()\n    key_len = len(key)\n    result = ''\n    for i, char in enumerate(message):\n        key_char = key[i % key_len]\n        shift = ord(key_char) - ord('A')\n        decrypted_char = chr(((ord(char) - ord('A') - shift) % 26) + ord('A'))\n        result += decrypted_char\n    return result\n\ndef encrypt(message, key):\n    \"\"\"Vigenere encryption of message using key.\"\"\"\n    message = ''.join(filter(str.isalpha, message)).upper()\n    key = ''.join(filter(str.isalpha, key)).upper()\n    key_len = len(key)\n    result = ''\n    for i, char in enumerate(message):\n        key_char = key[i % key_len]\n        shift = ord(key_char) - ord('A')\n        encrypted_char = chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n        result += encrypted_char\n    return result", "score_distribution": [3, 3, 2, 3, 3, 3, 2, 2, 2, 2, 3, 3, 3, 3, 3, 2, 2, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 2, 2, 3, 2, 3, 3, 2, 2, 2, 3, 3, 3, 3, 3, 3, 2, 3, 3, 2, 3, 3, 2, 3, 2, 3, 3, 3, 2, 2, 3, 2, 2, 3, 3, 3, 3, 2, 3, 2, 3, 3, 3, 2, 3, 2, 3, 2, 3, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 2, 2, 3, 2, 3, 3, 3, 3, 3, 3]}
{"lang_cluster": "Python", "source_code": "\nfrom random import shuffle, randrange\n\ndef make_maze(w = 16, h = 8):\n    vis = [[0] * w + [1] for _ in range(h)] + [[1] * (w + 1)]\n    ver = [[\"|  \"] * w + ['|'] for _ in range(h)] + [[]]\n    hor = [[\"+--\"] * w + ['+'] for _ in range(h + 1)]\n\n    def walk(x, y):\n        vis[y][x] = 1\n\n        d = [(x - 1, y), (x, y + 1), (x + 1, y), (x, y - 1)]\n        shuffle(d)\n        for (xx, yy) in d:\n            if vis[yy][xx]: continue\n            if xx == x: hor[max(y, yy)][x] = \"+  \"\n            if yy == y: ver[y][max(x, xx)] = \"   \"\n            walk(xx, yy)\n\n    walk(randrange(w), randrange(h))\n\n    s = \"\"\n    for (a, b) in zip(hor, ver):\n        s += ''.join(a + ['\\n'] + b + ['\\n'])\n    return s\n\nif __name__ == '__main__':\n    print(make_maze())\n\n\n", "human_summarization": "generate and display a maze using the Depth-first search algorithm. It starts from a random cell, marks it as visited, and gets a list of its neighbors. For each unvisited neighbor, it removes the wall between the current cell and the neighbor, and then recursively continues the process with the neighbor as the current cell.", "id": 4818, "incomplete_code": "from random import shuffle, randrange\n\ndef make_maze(w=16, h=8):\n    pass\nif __name__ == '__main__':\n    print(make_maze())", "original_code": "\nfrom random import shuffle, randrange\n\ndef make_maze(w = 16, h = 8):\n    vis = [[0] * w + [1] for _ in range(h)] + [[1] * (w + 1)]\n    ver = [[\"|  \"] * w + ['|'] for _ in range(h)] + [[]]\n    hor = [[\"+--\"] * w + ['+'] for _ in range(h + 1)]\n\n    def walk(x, y):\n        vis[y][x] = 1\n\n        d = [(x - 1, y), (x, y + 1), (x + 1, y), (x, y - 1)]\n        shuffle(d)\n        for (xx, yy) in d:\n            if vis[yy][xx]: continue\n            if xx == x: hor[max(y, yy)][x] = \"+  \"\n            if yy == y: ver[y][max(x, xx)] = \"   \"\n            walk(xx, yy)\n\n    walk(randrange(w), randrange(h))\n\n    s = \"\"\n    for (a, b) in zip(hor, ver):\n        s += ''.join(a + ['\\n'] + b + ['\\n'])\n    return s\n\nif __name__ == '__main__':\n    print(make_maze())\n\n\n", "perturbed_code": "\nfrom random import shuffle, randrange\n\ndef make_maze(w=16, h=8):\n    vis = ([((w + 1) * [1])] + [([1] + ([0] * w)) for _ in range(h)])\n    ver = ([[]] + [((['|  '] * w) + ['|']) for _ in range(h)])\n    hor = [((w * ['+--']) + ['+']) for _ in range((1 + h))]\n\n    def walk(x, y):\n        vis[y][x] = 1\n        for (xx, yy) in d:\n            if (y == yy):\n                ver[y][max(x, xx)] = '   '\n            if (x == xx):\n                hor[max(y, yy)][x] = '+  '\n            if vis[yy][xx]:\n                continue\n            walk(xx, yy)\n        d = [((x - 1), y), (x, (1 + y)), ((x + 1), y), (x, (y - 1))]\n        shuffle(d)\n    walk(randrange(w), randrange(h))\n    for (a, b) in zip(hor, ver):\n        s += ''.join((['\\n'] + (b + (a + ['\\n']))))\n    s = ''\n    return s\nif ('__main__' == __name__):\n    print(make_maze())\n", "incomplete_perturbed_code": "from random import shuffle, randrange\n\ndef make_maze(w=16, h=8):\n    pass\nif '__main__' == __name__:\n    print(make_maze())", "adversarial_score": 2, "original_score": 2, "search_time": 22.86926507949829, "stats": {"total_attempts": 100, "unique_perturbations": 100, "cache_hits": 0, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "from random import shuffle, randrange\n\ndef make_maze(w=16, h=8):\n    maze = [['#' for _ in range(w)] for _ in range(h)]\n    stack = [(randrange(h), randrange(w))]\n    maze[stack[0][0]][stack[0][1]] = ' '\n    while stack:\n        x, y = stack[-1]\n        neighbors = []\n        if x > 1 and maze[x - 2][y] == '#':\n            neighbors.append((x - 2, y))\n        if x < h - 2 and maze[x + 2][y] == '#':\n            neighbors.append((x + 2, y))\n        if y > 1 and maze[x][y - 2] == '#':\n            neighbors.append((x, y - 2))\n        if y < w - 2 and maze[x][y + 2] == '#':\n            neighbors.append((x, y + 2))\n        if neighbors:\n            nx, ny = shuffle(neighbors)[0]\n            maze[nx][ny] = ' '\n            maze[(x + nx) // 2][(y + ny) // 2] = ' '\n            stack.append((nx, ny))\n        else:\n            stack.pop()\n    return maze\nif '__main__' == __name__:\n    print(make_maze())", "score_distribution": [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]}
{"lang_cluster": "Python", "source_code": "\nfrom itertools import combinations\n\ndef anycomb(items):\n    ' return combinations of any length from the items '\n    return ( comb\n             for r in range(1, len(items)+1)\n             for comb in combinations(items, r)\n             )\n\ndef totalvalue(comb):\n    ' Totalise a particular combination of items'\n    totwt = totval = 0\n    for item, wt, val in comb:\n        totwt  += wt\n        totval += val\n    return (totval, -totwt) if totwt <= 400 else (0, 0)\n\nitems = (\n    (\"map\", 9, 150), (\"compass\", 13, 35), (\"water\", 153, 200), (\"sandwich\", 50, 160),\n    (\"glucose\", 15, 60), (\"tin\", 68, 45), (\"banana\", 27, 60), (\"apple\", 39, 40),\n    (\"cheese\", 23, 30), (\"beer\", 52, 10), (\"suntan cream\", 11, 70), (\"camera\", 32, 30),\n    (\"t-shirt\", 24, 15), (\"trousers\", 48, 10), (\"umbrella\", 73, 40),\n    (\"waterproof trousers\", 42, 70), (\"waterproof overclothes\", 43, 75),\n    (\"note-case\", 22, 80), (\"sunglasses\", 7, 20), (\"towel\", 18, 12),\n    (\"socks\", 4, 50), (\"book\", 30, 10),\n    )\nbagged = max( anycomb(items), key=totalvalue) # max val or min wt if values equal\nprint(\"Bagged the following items\\n  \" +\n      '\\n  '.join(sorted(item for item,_,_ in bagged)))\nval, wt = totalvalue(bagged)\nprint(\"for a total value of %i and a total weight of %i\" % (val, -wt))\n\n\n", "human_summarization": "The code determines the optimal combination of items a tourist can carry in his knapsack, given a maximum weight limit of 4kg (or 400 dag). It considers the weight and value of each item, ensuring the total weight does not exceed the limit and the total value is maximized. The code uses the 0-1 Knapsack problem approach, reducing the number of comparisons from N! to 2^N. It does not allow for cutting or diminishing the items.", "id": 4825, "incomplete_code": "from itertools import combinations\n\ndef anycomb(items):\n    \"\"\" return combinations of any length from the items \"\"\"\n    pass\n\ndef totalvalue(comb):\n    \"\"\" Totalise a particular combination of items\"\"\"\n    pass\nitems = (('map', 9, 150), ('compass', 13, 35), ('water', 153, 200), ('sandwich', 50, 160), ('glucose', 15, 60), ('tin', 68, 45), ('banana', 27, 60), ('apple', 39, 40), ('cheese', 23, 30), ('beer', 52, 10), ('suntan cream', 11, 70), ('camera', 32, 30), ('t-shirt', 24, 15), ('trousers', 48, 10), ('umbrella', 73, 40), ('waterproof trousers', 42, 70), ('waterproof overclothes', 43, 75), ('note-case', 22, 80), ('sunglasses', 7, 20), ('towel', 18, 12), ('socks', 4, 50), ('book', 30, 10))\nbagged = max(anycomb(items), key=totalvalue)\nprint('Bagged the following items\\n  ' + '\\n  '.join(sorted((item for item, _, _ in bagged))))\nval, wt = totalvalue(bagged)\nprint('for a total value of %i and a total weight of %i' % (val, -wt))", "original_code": "\nfrom itertools import combinations\n\ndef anycomb(items):\n    ' return combinations of any length from the items '\n    return ( comb\n             for r in range(1, len(items)+1)\n             for comb in combinations(items, r)\n             )\n\ndef totalvalue(comb):\n    ' Totalise a particular combination of items'\n    totwt = totval = 0\n    for item, wt, val in comb:\n        totwt  += wt\n        totval += val\n    return (totval, -totwt) if totwt <= 400 else (0, 0)\n\nitems = (\n    (\"map\", 9, 150), (\"compass\", 13, 35), (\"water\", 153, 200), (\"sandwich\", 50, 160),\n    (\"glucose\", 15, 60), (\"tin\", 68, 45), (\"banana\", 27, 60), (\"apple\", 39, 40),\n    (\"cheese\", 23, 30), (\"beer\", 52, 10), (\"suntan cream\", 11, 70), (\"camera\", 32, 30),\n    (\"t-shirt\", 24, 15), (\"trousers\", 48, 10), (\"umbrella\", 73, 40),\n    (\"waterproof trousers\", 42, 70), (\"waterproof overclothes\", 43, 75),\n    (\"note-case\", 22, 80), (\"sunglasses\", 7, 20), (\"towel\", 18, 12),\n    (\"socks\", 4, 50), (\"book\", 30, 10),\n    )\nbagged = max( anycomb(items), key=totalvalue) # max val or min wt if values equal\nprint(\"Bagged the following items\\n  \" +\n      '\\n  '.join(sorted(item for item,_,_ in bagged)))\nval, wt = totalvalue(bagged)\nprint(\"for a total value of %i and a total weight of %i\" % (val, -wt))\n\n\n", "perturbed_code": "\nfrom itertools import combinations\n\ndef anycomb(items):\n    ' return combinations of any length from the items '\n    return (comb for r in range(1, (len(items) + 1)) for comb in combinations(items, r))\n\ndef totalvalue(comb):\n    ' Totalise a particular combination of items'\n    for (item, wt, val) in comb:\n        totwt += wt\n        totval += val\n    totwt = totval = 0\n    return ((totval, (- totwt)) if (totwt <= 400) else (0, 0))\nitems = (('map', 9, 150), ('compass', 13, 35), ('water', 153, 200), ('sandwich', 50, 160), ('glucose', 15, 60), ('tin', 68, 45), ('banana', 27, 60), ('apple', 39, 40), ('cheese', 23, 30), ('beer', 52, 10), ('suntan cream', 11, 70), ('camera', 32, 30), ('t-shirt', 24, 15), ('trousers', 48, 10), ('umbrella', 73, 40), ('waterproof trousers', 42, 70), ('waterproof overclothes', 43, 75), ('note-case', 22, 80), ('sunglasses', 7, 20), ('towel', 18, 12), ('socks', 4, 50), ('book', 30, 10))\nprint(('for a total value of %i and a total weight of %i' % (val, (- wt))))\nbagged = max(anycomb(items), key=totalvalue)\nprint(('\\n  '.join(sorted((item for (item, _, _) in bagged))) + 'Bagged the following items\\n  '))\n(val, wt) = totalvalue(bagged)\n", "incomplete_perturbed_code": "from itertools import combinations\n\ndef anycomb(items):\n    \"\"\" return combinations of any length from the items \"\"\"\n    pass\n\ndef totalvalue(comb):\n    \"\"\" Totalise a particular combination of items\"\"\"\n    pass\nitems = (('map', 9, 150), ('compass', 13, 35), ('water', 153, 200), ('sandwich', 50, 160), ('glucose', 15, 60), ('tin', 68, 45), ('banana', 27, 60), ('apple', 39, 40), ('cheese', 23, 30), ('beer', 52, 10), ('suntan cream', 11, 70), ('camera', 32, 30), ('t-shirt', 24, 15), ('trousers', 48, 10), ('umbrella', 73, 40), ('waterproof trousers', 42, 70), ('waterproof overclothes', 43, 75), ('note-case', 22, 80), ('sunglasses', 7, 20), ('towel', 18, 12), ('socks', 4, 50), ('book', 30, 10))\nprint('for a total value of %i and a total weight of %i' % (val, -wt))\nbagged = max(anycomb(items), key=totalvalue)\nprint('\\n  '.join(sorted((item for item, _, _ in bagged))) + 'Bagged the following items\\n  ')\nval, wt = totalvalue(bagged)", "adversarial_score": 2, "original_score": 3, "search_time": 181.23788952827454, "stats": {"total_attempts": 100, "unique_perturbations": 12, "cache_hits": 78, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "from itertools import combinations\n\ndef anycomb(items):\n    \"\"\" return combinations of any length from the items \"\"\"\n    return list(combinations(items, 1))\n\ndef totalvalue(comb):\n    \"\"\" Totalise a particular combination of items\"\"\"\n    total = 0\n    weight = 0\n    for item, w, v in comb:\n        total += v\n        weight += w\n    return total, weight\n\nitems = (('map', 9, 150), ('compass', 13, 35), ('water', 153, 200), ('sandwich', 50, 160), ('glucose', 15, 60), ('tin', 68, 45), ('banana', 27, 60), ('apple', 39, 40), ('cheese', 23, 30), ('beer', 52, 10), ('suntan cream', 11, 70), ('camera', 32, 30), ('t-shirt', 24, 15), ('trousers', 48, 10), ('umbrella', 73, 40), ('waterproof trousers', 42, 70), ('waterproof overclothes', 43, 75), ('note-case', 22, 80), ('sunglasses', 7, 20), ('towel', 18, 12), ('socks', 4, 50), ('book', 30, 10))\nprint('for a total value of %i and a total weight of %i' % (val, -wt))\nbagged = max(anycomb(items), key=totalvalue)\nprint('\\n  '.join(sorted((item for item, _, _ in bagged))) + 'Bagged the following items\\n  ')\nval, wt = totalvalue(bagged)", "score_distribution": [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]}
{"lang_cluster": "Python", "source_code": "\nimport copy\n\nguyprefers = {\n 'abe':  ['abi', 'eve', 'cath', 'ivy', 'jan', 'dee', 'fay', 'bea', 'hope', 'gay'],\n 'bob':  ['cath', 'hope', 'abi', 'dee', 'eve', 'fay', 'bea', 'jan', 'ivy', 'gay'],\n 'col':  ['hope', 'eve', 'abi', 'dee', 'bea', 'fay', 'ivy', 'gay', 'cath', 'jan'],\n 'dan':  ['ivy', 'fay', 'dee', 'gay', 'hope', 'eve', 'jan', 'bea', 'cath', 'abi'],\n 'ed':   ['jan', 'dee', 'bea', 'cath', 'fay', 'eve', 'abi', 'ivy', 'hope', 'gay'],\n 'fred': ['bea', 'abi', 'dee', 'gay', 'eve', 'ivy', 'cath', 'jan', 'hope', 'fay'],\n 'gav':  ['gay', 'eve', 'ivy', 'bea', 'cath', 'abi', 'dee', 'hope', 'jan', 'fay'],\n 'hal':  ['abi', 'eve', 'hope', 'fay', 'ivy', 'cath', 'jan', 'bea', 'gay', 'dee'],\n 'ian':  ['hope', 'cath', 'dee', 'gay', 'bea', 'abi', 'fay', 'ivy', 'jan', 'eve'],\n 'jon':  ['abi', 'fay', 'jan', 'gay', 'eve', 'bea', 'dee', 'cath', 'ivy', 'hope']}\ngalprefers = {\n 'abi':  ['bob', 'fred', 'jon', 'gav', 'ian', 'abe', 'dan', 'ed', 'col', 'hal'],\n 'bea':  ['bob', 'abe', 'col', 'fred', 'gav', 'dan', 'ian', 'ed', 'jon', 'hal'],\n 'cath': ['fred', 'bob', 'ed', 'gav', 'hal', 'col', 'ian', 'abe', 'dan', 'jon'],\n 'dee':  ['fred', 'jon', 'col', 'abe', 'ian', 'hal', 'gav', 'dan', 'bob', 'ed'],\n 'eve':  ['jon', 'hal', 'fred', 'dan', 'abe', 'gav', 'col', 'ed', 'ian', 'bob'],\n 'fay':  ['bob', 'abe', 'ed', 'ian', 'jon', 'dan', 'fred', 'gav', 'col', 'hal'],\n 'gay':  ['jon', 'gav', 'hal', 'fred', 'bob', 'abe', 'col', 'ed', 'dan', 'ian'],\n 'hope': ['gav', 'jon', 'bob', 'abe', 'ian', 'dan', 'hal', 'ed', 'col', 'fred'],\n 'ivy':  ['ian', 'col', 'hal', 'gav', 'fred', 'bob', 'abe', 'ed', 'jon', 'dan'],\n 'jan':  ['ed', 'hal', 'gav', 'abe', 'bob', 'jon', 'col', 'ian', 'fred', 'dan']}\n\nguys = sorted(guyprefers.keys())\ngals = sorted(galprefers.keys())\n\n\ndef check(engaged):\n    inverseengaged = dict((v,k) for k,v in engaged.items())\n    for she, he in engaged.items():\n        shelikes = galprefers[she]\n        shelikesbetter = shelikes[:shelikes.index(he)]\n        helikes = guyprefers[he]\n        helikesbetter = helikes[:helikes.index(she)]\n        for guy in shelikesbetter:\n            guysgirl = inverseengaged[guy]\n            guylikes = guyprefers[guy]\n            if guylikes.index(guysgirl) > guylikes.index(she):\n                print(\"%s and %s like each other better than \"\n                      \"their present partners: %s and %s, respectively\"\n                      % (she, guy, he, guysgirl))\n                return False\n        for gal in helikesbetter:\n            girlsguy = engaged[gal]\n            gallikes = galprefers[gal]\n            if gallikes.index(girlsguy) > gallikes.index(he):\n                print(\"%s and %s like each other better than \"\n                      \"their present partners: %s and %s, respectively\"\n                      % (he, gal, she, girlsguy))\n                return False\n    return True\n\ndef matchmaker():\n    guysfree = guys[:]\n    engaged  = {}\n    guyprefers2 = copy.deepcopy(guyprefers)\n    galprefers2 = copy.deepcopy(galprefers)\n    while guysfree:\n        guy = guysfree.pop(0)\n        guyslist = guyprefers2[guy]\n        gal = guyslist.pop(0)\n        fiance = engaged.get(gal)\n        if not fiance:\n            # She's free\n            engaged[gal] = guy\n            print(\"  %s and %s\" % (guy, gal))\n        else:\n            # The bounder proposes to an engaged lass!\n            galslist = galprefers2[gal]\n            if galslist.index(fiance) > galslist.index(guy):\n                # She prefers new guy\n                engaged[gal] = guy\n                print(\"  %s dumped %s for %s\" % (gal, fiance, guy))\n                if guyprefers2[fiance]:\n                    # Ex has more girls to try\n                    guysfree.append(fiance)\n            else:\n                # She is faithful to old fiance\n                if guyslist:\n                    # Look again\n                    guysfree.append(guy)\n    return engaged\n\n\nprint('\\nEngagements:')\nengaged = matchmaker()\n\nprint('\\nCouples:')\nprint('  ' + ',\\n  '.join('%s is engaged to %s' % couple\n                          for couple in sorted(engaged.items())))\nprint()\nprint('Engagement stability check PASSED'\n      if check(engaged) else 'Engagement stability check FAILED')\n\nprint('\\n\\nSwapping two fiances to introduce an error')\nengaged[gals[0]], engaged[gals[1]] = engaged[gals[1]], engaged[gals[0]]\nfor gal in gals[:2]:\n    print('  %s is now engaged to %s' % (gal, engaged[gal]))\nprint()\nprint('Engagement stability check PASSED'\n      if check(engaged) else 'Engagement stability check FAILED')\n\n\n", "human_summarization": "\"Implement the Gale-Shapley algorithm to solve the Stable Marriage problem. The program takes as input the preferences of ten men and ten women, and outputs a stable set of engagements. It then perturbs this set to form an unstable set of engagements and checks this new set for stability.\"", "id": 4826, "incomplete_code": "import copy\nguyprefers = {'abe': ['abi', 'eve', 'cath', 'ivy', 'jan', 'dee', 'fay', 'bea', 'hope', 'gay'], 'bob': ['cath', 'hope', 'abi', 'dee', 'eve', 'fay', 'bea', 'jan', 'ivy', 'gay'], 'col': ['hope', 'eve', 'abi', 'dee', 'bea', 'fay', 'ivy', 'gay', 'cath', 'jan'], 'dan': ['ivy', 'fay', 'dee', 'gay', 'hope', 'eve', 'jan', 'bea', 'cath', 'abi'], 'ed': ['jan', 'dee', 'bea', 'cath', 'fay', 'eve', 'abi', 'ivy', 'hope', 'gay'], 'fred': ['bea', 'abi', 'dee', 'gay', 'eve', 'ivy', 'cath', 'jan', 'hope', 'fay'], 'gav': ['gay', 'eve', 'ivy', 'bea', 'cath', 'abi', 'dee', 'hope', 'jan', 'fay'], 'hal': ['abi', 'eve', 'hope', 'fay', 'ivy', 'cath', 'jan', 'bea', 'gay', 'dee'], 'ian': ['hope', 'cath', 'dee', 'gay', 'bea', 'abi', 'fay', 'ivy', 'jan', 'eve'], 'jon': ['abi', 'fay', 'jan', 'gay', 'eve', 'bea', 'dee', 'cath', 'ivy', 'hope']}\ngalprefers = {'abi': ['bob', 'fred', 'jon', 'gav', 'ian', 'abe', 'dan', 'ed', 'col', 'hal'], 'bea': ['bob', 'abe', 'col', 'fred', 'gav', 'dan', 'ian', 'ed', 'jon', 'hal'], 'cath': ['fred', 'bob', 'ed', 'gav', 'hal', 'col', 'ian', 'abe', 'dan', 'jon'], 'dee': ['fred', 'jon', 'col', 'abe', 'ian', 'hal', 'gav', 'dan', 'bob', 'ed'], 'eve': ['jon', 'hal', 'fred', 'dan', 'abe', 'gav', 'col', 'ed', 'ian', 'bob'], 'fay': ['bob', 'abe', 'ed', 'ian', 'jon', 'dan', 'fred', 'gav', 'col', 'hal'], 'gay': ['jon', 'gav', 'hal', 'fred', 'bob', 'abe', 'col', 'ed', 'dan', 'ian'], 'hope': ['gav', 'jon', 'bob', 'abe', 'ian', 'dan', 'hal', 'ed', 'col', 'fred'], 'ivy': ['ian', 'col', 'hal', 'gav', 'fred', 'bob', 'abe', 'ed', 'jon', 'dan'], 'jan': ['ed', 'hal', 'gav', 'abe', 'bob', 'jon', 'col', 'ian', 'fred', 'dan']}\nguys = sorted(guyprefers.keys())\ngals = sorted(galprefers.keys())\n\ndef check(engaged):\n    pass\n\ndef matchmaker():\n    pass\nprint('\\nEngagements:')\nengaged = matchmaker()\nprint('\\nCouples:')\nprint('  ' + ',\\n  '.join(('%s is engaged to %s' % couple for couple in sorted(engaged.items()))))\nprint()\nprint('Engagement stability check PASSED' if check(engaged) else 'Engagement stability check FAILED')\nprint('\\n\\nSwapping two fiances to introduce an error')\nengaged[gals[0]], engaged[gals[1]] = (engaged[gals[1]], engaged[gals[0]])\nfor gal in gals[:2]:\n    print('  %s is now engaged to %s' % (gal, engaged[gal]))\nprint()\nprint('Engagement stability check PASSED' if check(engaged) else 'Engagement stability check FAILED')", "original_code": "\nimport copy\n\nguyprefers = {\n 'abe':  ['abi', 'eve', 'cath', 'ivy', 'jan', 'dee', 'fay', 'bea', 'hope', 'gay'],\n 'bob':  ['cath', 'hope', 'abi', 'dee', 'eve', 'fay', 'bea', 'jan', 'ivy', 'gay'],\n 'col':  ['hope', 'eve', 'abi', 'dee', 'bea', 'fay', 'ivy', 'gay', 'cath', 'jan'],\n 'dan':  ['ivy', 'fay', 'dee', 'gay', 'hope', 'eve', 'jan', 'bea', 'cath', 'abi'],\n 'ed':   ['jan', 'dee', 'bea', 'cath', 'fay', 'eve', 'abi', 'ivy', 'hope', 'gay'],\n 'fred': ['bea', 'abi', 'dee', 'gay', 'eve', 'ivy', 'cath', 'jan', 'hope', 'fay'],\n 'gav':  ['gay', 'eve', 'ivy', 'bea', 'cath', 'abi', 'dee', 'hope', 'jan', 'fay'],\n 'hal':  ['abi', 'eve', 'hope', 'fay', 'ivy', 'cath', 'jan', 'bea', 'gay', 'dee'],\n 'ian':  ['hope', 'cath', 'dee', 'gay', 'bea', 'abi', 'fay', 'ivy', 'jan', 'eve'],\n 'jon':  ['abi', 'fay', 'jan', 'gay', 'eve', 'bea', 'dee', 'cath', 'ivy', 'hope']}\ngalprefers = {\n 'abi':  ['bob', 'fred', 'jon', 'gav', 'ian', 'abe', 'dan', 'ed', 'col', 'hal'],\n 'bea':  ['bob', 'abe', 'col', 'fred', 'gav', 'dan', 'ian', 'ed', 'jon', 'hal'],\n 'cath': ['fred', 'bob', 'ed', 'gav', 'hal', 'col', 'ian', 'abe', 'dan', 'jon'],\n 'dee':  ['fred', 'jon', 'col', 'abe', 'ian', 'hal', 'gav', 'dan', 'bob', 'ed'],\n 'eve':  ['jon', 'hal', 'fred', 'dan', 'abe', 'gav', 'col', 'ed', 'ian', 'bob'],\n 'fay':  ['bob', 'abe', 'ed', 'ian', 'jon', 'dan', 'fred', 'gav', 'col', 'hal'],\n 'gay':  ['jon', 'gav', 'hal', 'fred', 'bob', 'abe', 'col', 'ed', 'dan', 'ian'],\n 'hope': ['gav', 'jon', 'bob', 'abe', 'ian', 'dan', 'hal', 'ed', 'col', 'fred'],\n 'ivy':  ['ian', 'col', 'hal', 'gav', 'fred', 'bob', 'abe', 'ed', 'jon', 'dan'],\n 'jan':  ['ed', 'hal', 'gav', 'abe', 'bob', 'jon', 'col', 'ian', 'fred', 'dan']}\n\nguys = sorted(guyprefers.keys())\ngals = sorted(galprefers.keys())\n\n\ndef check(engaged):\n    inverseengaged = dict((v,k) for k,v in engaged.items())\n    for she, he in engaged.items():\n        shelikes = galprefers[she]\n        shelikesbetter = shelikes[:shelikes.index(he)]\n        helikes = guyprefers[he]\n        helikesbetter = helikes[:helikes.index(she)]\n        for guy in shelikesbetter:\n            guysgirl = inverseengaged[guy]\n            guylikes = guyprefers[guy]\n            if guylikes.index(guysgirl) > guylikes.index(she):\n                print(\"%s and %s like each other better than \"\n                      \"their present partners: %s and %s, respectively\"\n                      % (she, guy, he, guysgirl))\n                return False\n        for gal in helikesbetter:\n            girlsguy = engaged[gal]\n            gallikes = galprefers[gal]\n            if gallikes.index(girlsguy) > gallikes.index(he):\n                print(\"%s and %s like each other better than \"\n                      \"their present partners: %s and %s, respectively\"\n                      % (he, gal, she, girlsguy))\n                return False\n    return True\n\ndef matchmaker():\n    guysfree = guys[:]\n    engaged  = {}\n    guyprefers2 = copy.deepcopy(guyprefers)\n    galprefers2 = copy.deepcopy(galprefers)\n    while guysfree:\n        guy = guysfree.pop(0)\n        guyslist = guyprefers2[guy]\n        gal = guyslist.pop(0)\n        fiance = engaged.get(gal)\n        if not fiance:\n            # She's free\n            engaged[gal] = guy\n            print(\"  %s and %s\" % (guy, gal))\n        else:\n            # The bounder proposes to an engaged lass!\n            galslist = galprefers2[gal]\n            if galslist.index(fiance) > galslist.index(guy):\n                # She prefers new guy\n                engaged[gal] = guy\n                print(\"  %s dumped %s for %s\" % (gal, fiance, guy))\n                if guyprefers2[fiance]:\n                    # Ex has more girls to try\n                    guysfree.append(fiance)\n            else:\n                # She is faithful to old fiance\n                if guyslist:\n                    # Look again\n                    guysfree.append(guy)\n    return engaged\n\n\nprint('\\nEngagements:')\nengaged = matchmaker()\n\nprint('\\nCouples:')\nprint('  ' + ',\\n  '.join('%s is engaged to %s' % couple\n                          for couple in sorted(engaged.items())))\nprint()\nprint('Engagement stability check PASSED'\n      if check(engaged) else 'Engagement stability check FAILED')\n\nprint('\\n\\nSwapping two fiances to introduce an error')\nengaged[gals[0]], engaged[gals[1]] = engaged[gals[1]], engaged[gals[0]]\nfor gal in gals[:2]:\n    print('  %s is now engaged to %s' % (gal, engaged[gal]))\nprint()\nprint('Engagement stability check PASSED'\n      if check(engaged) else 'Engagement stability check FAILED')\n\n\n", "perturbed_code": "\nimport copy\nguyprefers = {'abe': ['abi', 'eve', 'cath', 'ivy', 'jan', 'dee', 'fay', 'bea', 'hope', 'gay'], 'bob': ['cath', 'hope', 'abi', 'dee', 'eve', 'fay', 'bea', 'jan', 'ivy', 'gay'], 'col': ['hope', 'eve', 'abi', 'dee', 'bea', 'fay', 'ivy', 'gay', 'cath', 'jan'], 'dan': ['ivy', 'fay', 'dee', 'gay', 'hope', 'eve', 'jan', 'bea', 'cath', 'abi'], 'ed': ['jan', 'dee', 'bea', 'cath', 'fay', 'eve', 'abi', 'ivy', 'hope', 'gay'], 'fred': ['bea', 'abi', 'dee', 'gay', 'eve', 'ivy', 'cath', 'jan', 'hope', 'fay'], 'gav': ['gay', 'eve', 'ivy', 'bea', 'cath', 'abi', 'dee', 'hope', 'jan', 'fay'], 'hal': ['abi', 'eve', 'hope', 'fay', 'ivy', 'cath', 'jan', 'bea', 'gay', 'dee'], 'ian': ['hope', 'cath', 'dee', 'gay', 'bea', 'abi', 'fay', 'ivy', 'jan', 'eve'], 'jon': ['abi', 'fay', 'jan', 'gay', 'eve', 'bea', 'dee', 'cath', 'ivy', 'hope']}\ngalprefers = {'abi': ['bob', 'fred', 'jon', 'gav', 'ian', 'abe', 'dan', 'ed', 'col', 'hal'], 'bea': ['bob', 'abe', 'col', 'fred', 'gav', 'dan', 'ian', 'ed', 'jon', 'hal'], 'cath': ['fred', 'bob', 'ed', 'gav', 'hal', 'col', 'ian', 'abe', 'dan', 'jon'], 'dee': ['fred', 'jon', 'col', 'abe', 'ian', 'hal', 'gav', 'dan', 'bob', 'ed'], 'eve': ['jon', 'hal', 'fred', 'dan', 'abe', 'gav', 'col', 'ed', 'ian', 'bob'], 'fay': ['bob', 'abe', 'ed', 'ian', 'jon', 'dan', 'fred', 'gav', 'col', 'hal'], 'gay': ['jon', 'gav', 'hal', 'fred', 'bob', 'abe', 'col', 'ed', 'dan', 'ian'], 'hope': ['gav', 'jon', 'bob', 'abe', 'ian', 'dan', 'hal', 'ed', 'col', 'fred'], 'ivy': ['ian', 'col', 'hal', 'gav', 'fred', 'bob', 'abe', 'ed', 'jon', 'dan'], 'jan': ['ed', 'hal', 'gav', 'abe', 'bob', 'jon', 'col', 'ian', 'fred', 'dan']}\n\ndef check(engaged):\n    for (she, he) in engaged.items():\n        for gal in helikesbetter:\n            if (gallikes.index(girlsguy) > gallikes.index(he)):\n                print(('%s and %s like each other better than their present partners: %s and %s, respectively' % (he, gal, she, girlsguy)))\n                return False\n            girlsguy = engaged[gal]\n            gallikes = galprefers[gal]\n        for guy in shelikesbetter:\n            if (guylikes.index(guysgirl) > guylikes.index(she)):\n                print(('%s and %s like each other better than their present partners: %s and %s, respectively' % (she, guy, he, guysgirl)))\n                return False\n            guysgirl = inverseengaged[guy]\n            guylikes = guyprefers[guy]\n        shelikes = galprefers[she]\n        shelikesbetter = shelikes[:shelikes.index(he)]\n        helikes = guyprefers[he]\n        helikesbetter = helikes[:helikes.index(she)]\n    return True\n    inverseengaged = dict(((v, k) for (k, v) in engaged.items()))\n\ndef matchmaker():\n    while guysfree:\n        if (not fiance):\n            engaged[gal] = guy\n            print(('  %s and %s' % (guy, gal)))\n        else:\n            if (galslist.index(fiance) > galslist.index(guy)):\n                if guyprefers2[fiance]:\n                    guysfree.append(fiance)\n                engaged[gal] = guy\n                print(('  %s dumped %s for %s' % (gal, fiance, guy)))\n            else:\n                if guyslist:\n                    guysfree.append(guy)\n            galslist = galprefers2[gal]\n        guy = guysfree.pop(0)\n        guyslist = guyprefers2[guy]\n        gal = guyslist.pop(0)\n        fiance = engaged.get(gal)\n    guysfree = guys[:]\n    engaged = {}\n    guyprefers2 = copy.deepcopy(guyprefers)\n    galprefers2 = copy.deepcopy(galprefers)\n    return engaged\nprint('\\nEngagements:')\nprint('\\nCouples:')\nprint()\nprint('\\n\\nSwapping two fiances to introduce an error')\nprint()\nguys = sorted(guyprefers.keys())\ngals = sorted(galprefers.keys())\nengaged = matchmaker()\nprint((',\\n  '.join((('%s is engaged to %s' % couple) for couple in sorted(engaged.items()))) + '  '))\nfor gal in gals[:2]:\n    print(('  %s is now engaged to %s' % (gal, engaged[gal])))\nprint(('Engagement stability check PASSED' if check(engaged) else 'Engagement stability check FAILED'))\n(engaged[gals[0]], engaged[gals[1]]) = (engaged[gals[1]], engaged[gals[0]])\nprint(('Engagement stability check PASSED' if check(engaged) else 'Engagement stability check FAILED'))\n", "incomplete_perturbed_code": "import copy\nguyprefers = {'abe': ['abi', 'eve', 'cath', 'ivy', 'jan', 'dee', 'fay', 'bea', 'hope', 'gay'], 'bob': ['cath', 'hope', 'abi', 'dee', 'eve', 'fay', 'bea', 'jan', 'ivy', 'gay'], 'col': ['hope', 'eve', 'abi', 'dee', 'bea', 'fay', 'ivy', 'gay', 'cath', 'jan'], 'dan': ['ivy', 'fay', 'dee', 'gay', 'hope', 'eve', 'jan', 'bea', 'cath', 'abi'], 'ed': ['jan', 'dee', 'bea', 'cath', 'fay', 'eve', 'abi', 'ivy', 'hope', 'gay'], 'fred': ['bea', 'abi', 'dee', 'gay', 'eve', 'ivy', 'cath', 'jan', 'hope', 'fay'], 'gav': ['gay', 'eve', 'ivy', 'bea', 'cath', 'abi', 'dee', 'hope', 'jan', 'fay'], 'hal': ['abi', 'eve', 'hope', 'fay', 'ivy', 'cath', 'jan', 'bea', 'gay', 'dee'], 'ian': ['hope', 'cath', 'dee', 'gay', 'bea', 'abi', 'fay', 'ivy', 'jan', 'eve'], 'jon': ['abi', 'fay', 'jan', 'gay', 'eve', 'bea', 'dee', 'cath', 'ivy', 'hope']}\ngalprefers = {'abi': ['bob', 'fred', 'jon', 'gav', 'ian', 'abe', 'dan', 'ed', 'col', 'hal'], 'bea': ['bob', 'abe', 'col', 'fred', 'gav', 'dan', 'ian', 'ed', 'jon', 'hal'], 'cath': ['fred', 'bob', 'ed', 'gav', 'hal', 'col', 'ian', 'abe', 'dan', 'jon'], 'dee': ['fred', 'jon', 'col', 'abe', 'ian', 'hal', 'gav', 'dan', 'bob', 'ed'], 'eve': ['jon', 'hal', 'fred', 'dan', 'abe', 'gav', 'col', 'ed', 'ian', 'bob'], 'fay': ['bob', 'abe', 'ed', 'ian', 'jon', 'dan', 'fred', 'gav', 'col', 'hal'], 'gay': ['jon', 'gav', 'hal', 'fred', 'bob', 'abe', 'col', 'ed', 'dan', 'ian'], 'hope': ['gav', 'jon', 'bob', 'abe', 'ian', 'dan', 'hal', 'ed', 'col', 'fred'], 'ivy': ['ian', 'col', 'hal', 'gav', 'fred', 'bob', 'abe', 'ed', 'jon', 'dan'], 'jan': ['ed', 'hal', 'gav', 'abe', 'bob', 'jon', 'col', 'ian', 'fred', 'dan']}\n\ndef check(engaged):\n    pass\n\ndef matchmaker():\n    pass\nprint('\\nEngagements:')\nprint('\\nCouples:')\nprint()\nprint('\\n\\nSwapping two fiances to introduce an error')\nprint()\nguys = sorted(guyprefers.keys())\ngals = sorted(galprefers.keys())\nengaged = matchmaker()\nprint(',\\n  '.join(('%s is engaged to %s' % couple for couple in sorted(engaged.items()))) + '  ')\nfor gal in gals[:2]:\n    print('  %s is now engaged to %s' % (gal, engaged[gal]))\nprint('Engagement stability check PASSED' if check(engaged) else 'Engagement stability check FAILED')\nengaged[gals[0]], engaged[gals[1]] = (engaged[gals[1]], engaged[gals[0]])\nprint('Engagement stability check PASSED' if check(engaged) else 'Engagement stability check FAILED')", "adversarial_score": 3, "original_score": 3, "search_time": 260.93300771713257, "stats": {"total_attempts": 100, "unique_perturbations": 4, "cache_hits": 80, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "import copy\nimport random\n\ndef check(engaged):\n    for guy, girl in engaged.items():\n        for preferred_girl in guyprefers[guy]:\n            if preferred_girl == girl:\n                break\n            if preferred_girl in engaged and engaged[preferred_girl] == guy:\n                return False\n    return True\n\ndef matchmaker():\n    engaged = {}\n    men_available = list(guyprefers.keys())\n    women_engaged = {}\n\n    while men_available:\n        guy = men_available.pop(0)\n        preferred_women = guyprefers[guy]\n        for woman in preferred_women:\n            if woman not in women_engaged:\n                engaged[guy] = woman\n                women_engaged[woman] = guy\n                break\n            else:\n                current_guy = women_engaged[woman]\n                if galprefers[woman].index(guy) < galprefers[woman].index(current_guy):\n                    engaged[guy] = woman\n                    del engaged[current_guy]\n                    men_available.append(current_guy)\n                    women_engaged[woman] = guy\n                    break\n    return engaged\n\nprint('\\nEngagements:')\nprint('\\nCouples:')\nprint()\nprint('\\n\\nSwapping two fiances to introduce an error')\nprint()\nguys = sorted(guyprefers.keys())\ngals = sorted(galprefers.keys())\nengaged = matchmaker()\nprint(',\\n  '.join(('%s is engaged to %s' % couple for couple in sorted(engaged.items()))) + '  ')\nfor gal in gals[:2]:\n    print('  %s is now engaged to %s' % (gal, engaged[gal]))\nprint('Engagement stability check PASSED' if check(engaged) else 'Engagement stability check FAILED')\nengaged[gals[0]], engaged[gals[1]] = (engaged[gals[1]], engaged[gals[0]])\nprint('Engagement stability check PASSED' if check(engaged) else 'Engagement stability check FAILED')", "score_distribution": [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]}
{"lang_cluster": "Python", "source_code": "\nimport time, winsound #, sys\n\nchar2morse = {          \n          \"!\": \"---.\",      \"\\\"\": \".-..-.\",     \"$\": \"...-..-\",    \"'\": \".----.\",  \n          \"(\": \"-.--.\",      \")\": \"-.--.-\",     \"+\": \".-.-.\",      \",\": \"--..--\", \n          \"-\": \"-....-\",     \".\": \".-.-.-\",     \"/\": \"-..-.\", \n          \"0\": \"-----\",      \"1\": \".----\",      \"2\": \"..---\",      \"3\": \"...--\", \n          \"4\": \"....-\",      \"5\": \".....\",      \"6\": \"-....\",      \"7\": \"--...\", \n          \"8\": \"---..\",      \"9\": \"----.\", \n          \":\": \"---...\",     \";\": \"-.-.-.\",     \"=\": \"-...-\",      \"?\": \"..--..\", \n          \"@\": \".--.-.\", \n          \"A\": \".-\",         \"B\": \"-...\",       \"C\": \"-.-.\",       \"D\": \"-..\", \n          \"E\": \".\",          \"F\": \"..-.\",       \"G\": \"--.\",        \"H\": \"....\", \n          \"I\": \"..\",         \"J\": \".---\",       \"K\": \"-.-\",        \"L\": \".-..\", \n          \"M\": \"--\",         \"N\": \"-.\",         \"O\": \"---\",        \"P\": \".--.\", \n          \"Q\": \"--.-\",       \"R\": \".-.\",        \"S\": \"...\",        \"T\": \"-\", \n          \"U\": \"..-\",        \"V\": \"...-\",       \"W\": \".--\",        \"X\": \"-..-\", \n          \"Y\": \"-.--\",       \"Z\": \"--..\", \n          \"[\": \"-.--.\",      \"]\": \"-.--.-\",     \"_\": \"..--.-\",\n }\n\ne = 50      # Element time in ms. one dit is on for e then off for e\nf = 1280    # Tone freq. in hertz\nchargap = 1 # Time between characters of a word, in units of e\nwordgap = 7 # Time between words, in units of e\n\ndef gap(n=1):\n    time.sleep(n * e / 1000)\noff = gap\n\ndef on(n=1):\n    winsound.Beep(f, n * e)\n\ndef dit():\n    on(); off()\n\ndef dah():\n    on(3); off()\n\ndef bloop(n=3):\n    winsound.Beep(f//2, n * e)\n\ndef windowsmorse(text):\n    for word in text.strip().upper().split():\n        for char in word:\n            for element in char2morse.get(char, '?'):\n                if element == '-':\n                    dah()\n                elif element == '.':\n                    dit()\n                else:\n                    bloop()\n            gap(chargap)\n        gap(wordgap)\n\n# Outputs its own source file as Morse. An audible quine!\n#with open(sys.argv[0], 'r') as thisfile:\n#    windowsmorse(thisfile.read())\n    \nwhile True:\n    windowsmorse(input('A string to change into morse: '))\n\n", "human_summarization": "<output> convert a given string into audible Morse code and send it to an audio device such as a PC speaker. It either ignores unknown characters or indicates them with a different pitch. </output>", "id": 4828, "incomplete_code": "import time, winsound\nchar2morse = {'!': '---.', '\"': '.-..-.', '$': '...-..-', \"'\": '.----.', '(': '-.--.', ')': '-.--.-', '+': '.-.-.', ',': '--..--', '-': '-....-', '.': '.-.-.-', '/': '-..-.', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', ':': '---...', ';': '-.-.-.', '=': '-...-', '?': '..--..', '@': '.--.-.', 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '[': '-.--.', ']': '-.--.-', '_': '..--.-'}\ne = 50\nf = 1280\nchargap = 1\nwordgap = 7\n\ndef gap(n=1):\n    pass\noff = gap\n\ndef on(n=1):\n    pass\n\ndef dit():\n    pass\n\ndef dah():\n    pass\n\ndef bloop(n=3):\n    pass\n\ndef windowsmorse(text):\n    pass\nwhile True:\n    windowsmorse(input('A string to change into morse: '))", "original_code": "\nimport time, winsound #, sys\n\nchar2morse = {          \n          \"!\": \"---.\",      \"\\\"\": \".-..-.\",     \"$\": \"...-..-\",    \"'\": \".----.\",  \n          \"(\": \"-.--.\",      \")\": \"-.--.-\",     \"+\": \".-.-.\",      \",\": \"--..--\", \n          \"-\": \"-....-\",     \".\": \".-.-.-\",     \"/\": \"-..-.\", \n          \"0\": \"-----\",      \"1\": \".----\",      \"2\": \"..---\",      \"3\": \"...--\", \n          \"4\": \"....-\",      \"5\": \".....\",      \"6\": \"-....\",      \"7\": \"--...\", \n          \"8\": \"---..\",      \"9\": \"----.\", \n          \":\": \"---...\",     \";\": \"-.-.-.\",     \"=\": \"-...-\",      \"?\": \"..--..\", \n          \"@\": \".--.-.\", \n          \"A\": \".-\",         \"B\": \"-...\",       \"C\": \"-.-.\",       \"D\": \"-..\", \n          \"E\": \".\",          \"F\": \"..-.\",       \"G\": \"--.\",        \"H\": \"....\", \n          \"I\": \"..\",         \"J\": \".---\",       \"K\": \"-.-\",        \"L\": \".-..\", \n          \"M\": \"--\",         \"N\": \"-.\",         \"O\": \"---\",        \"P\": \".--.\", \n          \"Q\": \"--.-\",       \"R\": \".-.\",        \"S\": \"...\",        \"T\": \"-\", \n          \"U\": \"..-\",        \"V\": \"...-\",       \"W\": \".--\",        \"X\": \"-..-\", \n          \"Y\": \"-.--\",       \"Z\": \"--..\", \n          \"[\": \"-.--.\",      \"]\": \"-.--.-\",     \"_\": \"..--.-\",\n }\n\ne = 50      # Element time in ms. one dit is on for e then off for e\nf = 1280    # Tone freq. in hertz\nchargap = 1 # Time between characters of a word, in units of e\nwordgap = 7 # Time between words, in units of e\n\ndef gap(n=1):\n    time.sleep(n * e / 1000)\noff = gap\n\ndef on(n=1):\n    winsound.Beep(f, n * e)\n\ndef dit():\n    on(); off()\n\ndef dah():\n    on(3); off()\n\ndef bloop(n=3):\n    winsound.Beep(f//2, n * e)\n\ndef windowsmorse(text):\n    for word in text.strip().upper().split():\n        for char in word:\n            for element in char2morse.get(char, '?'):\n                if element == '-':\n                    dah()\n                elif element == '.':\n                    dit()\n                else:\n                    bloop()\n            gap(chargap)\n        gap(wordgap)\n\n# Outputs its own source file as Morse. An audible quine!\n#with open(sys.argv[0], 'r') as thisfile:\n#    windowsmorse(thisfile.read())\n    \nwhile True:\n    windowsmorse(input('A string to change into morse: '))\n\n", "perturbed_code": "\nchargap = 1\nwordgap = 7\nf = 1280\n\ndef windowsmorse(text):\n    for word in text.strip().upper().split():\n        for char in word:\n            gap(chargap)\n            for element in char2morse.get(char, '?'):\n                if (element == '-'):\n                    dah()\n                else:\n                    if ('.' == element):\n                        dit()\n                    else:\n                        bloop()\n        gap(wordgap)\nimport time, winsound\ne = 50\nchar2morse = {'!': '---.', '\"': '.-..-.', '$': '...-..-', \"'\": '.----.', '(': '-.--.', ')': '-.--.-', '+': '.-.-.', ',': '--..--', '-': '-....-', '.': '.-.-.-', '/': '-..-.', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', ':': '---...', ';': '-.-.-.', '=': '-...-', '?': '..--..', '@': '.--.-.', 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '[': '-.--.', ']': '-.--.-', '_': '..--.-'}\n\ndef gap(n=1):\n    time.sleep(((n * e) / 1000))\n\ndef dah():\n    on(3)\n    off()\noff = gap\n\ndef bloop(n=3):\n    winsound.Beep((f // 2), (e * n))\n\ndef dit():\n    on()\n    off()\n\ndef on(n=1):\n    winsound.Beep(f, (n * e))\nwhile True:\n    windowsmorse(input('A string to change into morse: '))\n", "incomplete_perturbed_code": "chargap = 1\nwordgap = 7\nf = 1280\n\ndef windowsmorse(text):\n    pass\nimport time, winsound\ne = 50\nchar2morse = {'!': '---.', '\"': '.-..-.', '$': '...-..-', \"'\": '.----.', '(': '-.--.', ')': '-.--.-', '+': '.-.-.', ',': '--..--', '-': '-....-', '.': '.-.-.-', '/': '-..-.', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', ':': '---...', ';': '-.-.-.', '=': '-...-', '?': '..--..', '@': '.--.-.', 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '[': '-.--.', ']': '-.--.-', '_': '..--.-'}\n\ndef gap(n=1):\n    pass\n\ndef dah():\n    pass\noff = gap\n\ndef bloop(n=3):\n    pass\n\ndef dit():\n    pass\n\ndef on(n=1):\n    pass\nwhile True:\n    windowsmorse(input('A string to change into morse: '))", "adversarial_score": 2, "original_score": 2, "search_time": 3895.963998556137, "stats": {"total_attempts": 100, "unique_perturbations": 99, "cache_hits": 0, "failed_perturbations": 0, "failed_evaluations": 1}, "adversarial_completion": "import time, winsound\ne = 50\nchar2morse = {'!': '---.', '\"': '.-..-.', '$': '...-..-', \"'\": '.----.', '(': '-.--.', ')': '-.--.-', '+': '.-.-.', ',': '--..--', '-': '-....-', '.': '.-.-.-', '/': '-..-.', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', ':': '---...', ';': '-.-.-.', '=': '-...-', '?': '..--..', '@': '.--.-.', 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '[': '-.--.', ']': '-.--.-', '_': '..--.-'}\n\ndef gap(n=1):\n    time.sleep(n * 0.3)\n\ndef dah():\n    winsound.Beep(1000, 500)\n    time.sleep(0.1)\n\ndef bloop(n=3):\n    for _ in range(n):\n        winsound.Beep(1500, 250)\n        time.sleep(0.1)\n\ndef dit():\n    winsound.Beep(2000, 250)\n    time.sleep(0.1)\n\ndef on(n=1):\n    for _ in range(n):\n        winsound.Beep(2500, 250)\n        time.sleep(0.1)\n\ndef windowsmorse(text):\n    for char in text:\n        if char in char2morse:\n            morse = char2morse[char]\n            for element in morse:\n                if element == '-':\n                    dit()\n                elif element == '.':\n                    dah()\n                elif element == ' ':\n                    gap()\n            time.sleep(0.1)\n        else:\n            bloop()\n\nwhile True:\n    windowsmorse(input('A string to change into morse: '))", "score_distribution": [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]}
{"lang_cluster": "Python", "source_code": "\n'''\nNote that this code is broken, e.g., it won't work when \nblocks = [(\"A\", \"B\"), (\"A\",\"C\")] and the word is \"AB\", where the answer\nshould be True, but the code returns False.\n'''\nblocks = [(\"B\", \"O\"),\n          (\"X\", \"K\"),\n          (\"D\", \"Q\"),\n          (\"C\", \"P\"),\n          (\"N\", \"A\"),\n          (\"G\", \"T\"),\n          (\"R\", \"E\"),\n          (\"T\", \"G\"),\n          (\"Q\", \"D\"),\n          (\"F\", \"S\"),\n          (\"J\", \"W\"),\n          (\"H\", \"U\"),\n          (\"V\", \"I\"),\n          (\"A\", \"N\"),\n          (\"O\", \"B\"),\n          (\"E\", \"R\"),\n          (\"F\", \"S\"),\n          (\"L\", \"Y\"),\n          (\"P\", \"C\"),\n          (\"Z\", \"M\")]\n\n\ndef can_make_word(word, block_collection=blocks):\n    \"\"\"\n    Return True if `word` can be made from the blocks in `block_collection`.\n\n    >>> can_make_word(\"\")\n    False\n    >>> can_make_word(\"a\")\n    True\n    >>> can_make_word(\"bark\")\n    True\n    >>> can_make_word(\"book\")\n    False\n    >>> can_make_word(\"treat\")\n    True\n    >>> can_make_word(\"common\")\n    False\n    >>> can_make_word(\"squad\")\n    True\n    >>> can_make_word(\"coNFused\")\n    True\n    \"\"\"\n    if not word:\n        return False\n\n    blocks_remaining = block_collection[:]\n    for char in word.upper():\n        for block in blocks_remaining:\n            if char in block:\n                blocks_remaining.remove(block)\n                break\n        else:\n            return False\n    return True\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n    print(\", \".join(\"'%s': %s\" % (w, can_make_word(w)) for w in\n                    [\"\", \"a\", \"baRk\", \"booK\", \"treat\", \n                     \"COMMON\", \"squad\", \"Confused\"]))\n\n\n", "human_summarization": "The code implements a function that checks if a given word can be spelled using a predefined collection of ABC blocks. Each block contains two letters and can only be used once. The function is case-insensitive and returns a boolean value based on whether the word can be formed or not. It also handles the case of an empty string input.", "id": 4829, "incomplete_code": "\"\"\"\nNote that this code is broken, e.g., it won't work when \nblocks = [(\"A\", \"B\"), (\"A\",\"C\")] and the word is \"AB\", where the answer\nshould be True, but the code returns False.\n\"\"\"\nblocks = [('B', 'O'), ('X', 'K'), ('D', 'Q'), ('C', 'P'), ('N', 'A'), ('G', 'T'), ('R', 'E'), ('T', 'G'), ('Q', 'D'), ('F', 'S'), ('J', 'W'), ('H', 'U'), ('V', 'I'), ('A', 'N'), ('O', 'B'), ('E', 'R'), ('F', 'S'), ('L', 'Y'), ('P', 'C'), ('Z', 'M')]\n\ndef can_make_word(word, block_collection=blocks):\n    \"\"\"\n    Return True if `word` can be made from the blocks in `block_collection`.\n\n    >>> can_make_word(\"\")\n    False\n    >>> can_make_word(\"a\")\n    True\n    >>> can_make_word(\"bark\")\n    True\n    >>> can_make_word(\"book\")\n    False\n    >>> can_make_word(\"treat\")\n    True\n    >>> can_make_word(\"common\")\n    False\n    >>> can_make_word(\"squad\")\n    True\n    >>> can_make_word(\"coNFused\")\n    True\n    \"\"\"\n    pass\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n    print(', '.join((\"'%s': %s\" % (w, can_make_word(w)) for w in ['', 'a', 'baRk', 'booK', 'treat', 'COMMON', 'squad', 'Confused'])))", "original_code": "\n'''\nNote that this code is broken, e.g., it won't work when \nblocks = [(\"A\", \"B\"), (\"A\",\"C\")] and the word is \"AB\", where the answer\nshould be True, but the code returns False.\n'''\nblocks = [(\"B\", \"O\"),\n          (\"X\", \"K\"),\n          (\"D\", \"Q\"),\n          (\"C\", \"P\"),\n          (\"N\", \"A\"),\n          (\"G\", \"T\"),\n          (\"R\", \"E\"),\n          (\"T\", \"G\"),\n          (\"Q\", \"D\"),\n          (\"F\", \"S\"),\n          (\"J\", \"W\"),\n          (\"H\", \"U\"),\n          (\"V\", \"I\"),\n          (\"A\", \"N\"),\n          (\"O\", \"B\"),\n          (\"E\", \"R\"),\n          (\"F\", \"S\"),\n          (\"L\", \"Y\"),\n          (\"P\", \"C\"),\n          (\"Z\", \"M\")]\n\n\ndef can_make_word(word, block_collection=blocks):\n    \"\"\"\n    Return True if `word` can be made from the blocks in `block_collection`.\n\n    >>> can_make_word(\"\")\n    False\n    >>> can_make_word(\"a\")\n    True\n    >>> can_make_word(\"bark\")\n    True\n    >>> can_make_word(\"book\")\n    False\n    >>> can_make_word(\"treat\")\n    True\n    >>> can_make_word(\"common\")\n    False\n    >>> can_make_word(\"squad\")\n    True\n    >>> can_make_word(\"coNFused\")\n    True\n    \"\"\"\n    if not word:\n        return False\n\n    blocks_remaining = block_collection[:]\n    for char in word.upper():\n        for block in blocks_remaining:\n            if char in block:\n                blocks_remaining.remove(block)\n                break\n        else:\n            return False\n    return True\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n    print(\", \".join(\"'%s': %s\" % (w, can_make_word(w)) for w in\n                    [\"\", \"a\", \"baRk\", \"booK\", \"treat\", \n                     \"COMMON\", \"squad\", \"Confused\"]))\n\n\n", "perturbed_code": "\n\ndef can_make_word(word, block_collection=blocks):\n    '\\n    Return True if `word` can be made from the blocks in `block_collection`.\\n\\n    >>> can_make_word(\"\")\\n    False\\n    >>> can_make_word(\"a\")\\n    True\\n    >>> can_make_word(\"bark\")\\n    True\\n    >>> can_make_word(\"book\")\\n    False\\n    >>> can_make_word(\"treat\")\\n    True\\n    >>> can_make_word(\"common\")\\n    False\\n    >>> can_make_word(\"squad\")\\n    True\\n    >>> can_make_word(\"coNFused\")\\n    True\\n    '\n    for char in word.upper():\n        for block in blocks_remaining:\n            if (char in block):\n                blocks_remaining.remove(block)\n                break\n        else:\n            return False\n    return True\n    if (not word):\n        return False\n    blocks_remaining = block_collection[:]\n'\\nNote that this code is broken, e.g., it won\\'t work when \\nblocks = [(\"A\", \"B\"), (\"A\",\"C\")] and the word is \"AB\", where the answer\\nshould be True, but the code returns False.\\n'\nblocks = [('B', 'O'), ('X', 'K'), ('D', 'Q'), ('C', 'P'), ('N', 'A'), ('G', 'T'), ('R', 'E'), ('T', 'G'), ('Q', 'D'), ('F', 'S'), ('J', 'W'), ('H', 'U'), ('V', 'I'), ('A', 'N'), ('O', 'B'), ('E', 'R'), ('F', 'S'), ('L', 'Y'), ('P', 'C'), ('Z', 'M')]\nif ('__main__' == __name__):\n    print(', '.join(((\"'%s': %s\" % (w, can_make_word(w))) for w in ['', 'a', 'baRk', 'booK', 'treat', 'COMMON', 'squad', 'Confused'])))\n    import doctest\n    doctest.testmod()\n", "incomplete_perturbed_code": "def can_make_word(word, block_collection=blocks):\n    \"\"\"\n    Return True if `word` can be made from the blocks in `block_collection`.\n\n    >>> can_make_word(\"\")\n    False\n    >>> can_make_word(\"a\")\n    True\n    >>> can_make_word(\"bark\")\n    True\n    >>> can_make_word(\"book\")\n    False\n    >>> can_make_word(\"treat\")\n    True\n    >>> can_make_word(\"common\")\n    False\n    >>> can_make_word(\"squad\")\n    True\n    >>> can_make_word(\"coNFused\")\n    True\n    \"\"\"\n    pass\n'\\nNote that this code is broken, e.g., it won\\'t work when \\nblocks = [(\"A\", \"B\"), (\"A\",\"C\")] and the word is \"AB\", where the answer\\nshould be True, but the code returns False.\\n'\nblocks = [('B', 'O'), ('X', 'K'), ('D', 'Q'), ('C', 'P'), ('N', 'A'), ('G', 'T'), ('R', 'E'), ('T', 'G'), ('Q', 'D'), ('F', 'S'), ('J', 'W'), ('H', 'U'), ('V', 'I'), ('A', 'N'), ('O', 'B'), ('E', 'R'), ('F', 'S'), ('L', 'Y'), ('P', 'C'), ('Z', 'M')]\nif '__main__' == __name__:\n    print(', '.join((\"'%s': %s\" % (w, can_make_word(w)) for w in ['', 'a', 'baRk', 'booK', 'treat', 'COMMON', 'squad', 'Confused'])))\n    import doctest\n    doctest.testmod()", "adversarial_score": 2, "original_score": 2, "search_time": 409.87521958351135, "stats": {"total_attempts": 100, "unique_perturbations": 22, "cache_hits": 69, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "def can_make_word(word, block_collection=blocks):\n    \"\"\"\n    Return True if `word` can be made from the blocks in `block_collection`.\n\n    >>> can_make_word(\"\")\n    False\n    >>> can_make_word(\"a\")\n    True\n    >>> can_make_word(\"bark\")\n    True\n    >>> can_make_word(\"book\")\n    False\n    >>> can_make_word(\"treat\")\n    True\n    >>> can_make_word(\"common\")\n    False\n    >>> can_make_word(\"squad\")\n    True\n    >>> can_make_word(\"coNFused\")\n    True\n    \"\"\"\n    word = word.upper()\n    if not word:\n        return False\n\n    available_blocks = set(block_collection)\n    for i in range(0, len(word), 2):\n        pair = word[i:i+2]\n        if pair in available_blocks:\n            available_blocks.remove(pair)\n        else:\n            return False\n\n    return True\n\nif '__main__' == __name__:\n    print(', '.join((\"'%s': %s\" % (w, can_make_word(w)) for w in ['', 'a', 'baRk', 'booK', 'treat', 'COMMON', 'squad', 'Confused'])))\n    import doctest\n    doctest.testmod()", "score_distribution": [2, 2, 2, 2, 2, 3, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]}
