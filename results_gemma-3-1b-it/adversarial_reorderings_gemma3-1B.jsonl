{"lang_cluster": "Python", "source_code": "\n# Works with: Python version 2.5\n\nfrom collections import deque\nstack = deque()\nstack.append(value) # pushing\nvalue = stack.pop()\nnot stack # is empty?\n\nfrom collections import deque\n\nclass Stack:\n    def __init__(self):\n        self._items = deque()\n    def append(self, item):\n        self._items.append(item)\n    def pop(self):\n        return self._items.pop()\n    def __nonzero__(self):\n        return bool(self._items)\n\nclass Stack:\n    def __init__(self):\n        self._first = None\n    def __nonzero__(self):\n        return self._first is not None \n    def append(self, value):\n        self._first = (value, self._first)\n    def pop(self):\n        if self._first is None:\n            raise IndexError(\"pop from empty stack\")\n        value, self._first = self._first\n        return value\n\nwhile not stack.empty():\n pass \nwhile stack:\n pass\n", "human_summarization": "implement a stack data structure supporting basic operations such as push, pop, and empty check. The stack follows a last in, first out (LIFO) access policy. The implementation can be done using a deque for faster performance or a linked list for a simpler interface.", "id": 4672, "incomplete_code": "from collections import deque\nstack = deque()\nstack.append(value)\nvalue = stack.pop()\nnot stack\nfrom collections import deque\n\nclass Stack:\n\n    def __init__(self):\n        pass\n\n    def append(self, item):\n        pass\n\n    def pop(self):\n        pass\n\n    def __nonzero__(self):\n        pass\n\nclass Stack:\n\n    def __init__(self):\n        pass\n\n    def __nonzero__(self):\n        pass\n\n    def append(self, value):\n        pass\n\n    def pop(self):\n        pass\nwhile not stack.empty():\n    pass\nwhile stack:\n    pass", "original_code": "\n# Works with: Python version 2.5\n\nfrom collections import deque\nstack = deque()\nstack.append(value) # pushing\nvalue = stack.pop()\nnot stack # is empty?\n\nfrom collections import deque\n\nclass Stack:\n    def __init__(self):\n        self._items = deque()\n    def append(self, item):\n        self._items.append(item)\n    def pop(self):\n        return self._items.pop()\n    def __nonzero__(self):\n        return bool(self._items)\n\nclass Stack:\n    def __init__(self):\n        self._first = None\n    def __nonzero__(self):\n        return self._first is not None \n    def append(self, value):\n        self._first = (value, self._first)\n    def pop(self):\n        if self._first is None:\n            raise IndexError(\"pop from empty stack\")\n        value, self._first = self._first\n        return value\n\nwhile not stack.empty():\n pass \nwhile stack:\n pass\n", "perturbed_code": "\nfrom collections import deque\nwhile stack:\n    pass\nstack = deque()\nstack.append(value)\nvalue = stack.pop()\n(not stack)\nfrom collections import deque\n\nclass Stack():\n\n    def __init__(self):\n        self._items = deque()\n\n    def append(self, item):\n        self._items.append(item)\n\n    def pop(self):\n        return self._items.pop()\n\n    def __nonzero__(self):\n        return bool(self._items)\n\nclass Stack():\n\n    def __init__(self):\n        self._first = None\n\n    def __nonzero__(self):\n        return (self._first is not None)\n\n    def append(self, value):\n        self._first = (value, self._first)\n\n    def pop(self):\n        if (self._first is None):\n            raise IndexError('pop from empty stack')\n        (value, self._first) = self._first\n        return value\nwhile (not stack.empty()):\n    pass\n", "incomplete_perturbed_code": "from collections import deque\nwhile stack:\n    pass\nstack = deque()\nstack.append(value)\nvalue = stack.pop()\nnot stack\nfrom collections import deque\n\nclass Stack:\n\n    def __init__(self):\n        pass\n\n    def append(self, item):\n        pass\n\n    def pop(self):\n        pass\n\n    def __nonzero__(self):\n        pass\n\nclass Stack:\n\n    def __init__(self):\n        pass\n\n    def __nonzero__(self):\n        pass\n\n    def append(self, value):\n        pass\n\n    def pop(self):\n        pass\nwhile not stack.empty():\n    pass", "adversarial_score": 2, "original_score": 4, "search_time": 3.1464920043945312, "stats": {"total_attempts": 2, "unique_perturbations": 1, "cache_hits": 1, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "from collections import deque\nwhile not stack.empty():\n    value = stack.pop()\n    if not stack:\n        stack.append(value)\n    else:\n        pass", "score_distribution": [2, 2]}
{"lang_cluster": "Python", "source_code": "\n\nfrom collections import namedtuple, deque\nfrom pprint import pprint as pp\n \n \ninf = float('inf')\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\n \nclass Graph():\n    def __init__(self, edges):\n        self.edges = [Edge(*edge) for edge in edges]\n        # print(dir(self.edges[0]))\n        self.vertices = {e.start for e in self.edges} | {e.end for e in self.edges}\n \n    def dijkstra(self, source, dest):\n        assert source in self.vertices\n        dist = {vertex: inf for vertex in self.vertices}\n        previous = {vertex: None for vertex in self.vertices}\n        dist[source] = 0\n        q = self.vertices.copy()\n        neighbours = {vertex: set() for vertex in self.vertices}\n        for start, end, cost in self.edges:\n            neighbours[start].add((end, cost))\n            neighbours[end].add((start, cost))\n\n        #pp(neighbours)\n \n        while q:\n            # pp(q)\n            u = min(q, key=lambda vertex: dist[vertex])\n            q.remove(u)\n            if dist[u] == inf or u == dest:\n                break\n            for v, cost in neighbours[u]:\n                alt = dist[u] + cost\n                if alt < dist[v]:                                  # Relax (u,v,a)\n                    dist[v] = alt\n                    previous[v] = u\n        #pp(previous)\n        s, u = deque(), dest\n        while previous[u]:\n            s.appendleft(u)\n            u = previous[u]\n        s.appendleft(u)\n        return s\n \n \ngraph = Graph([(\"a\", \"b\", 7),  (\"a\", \"c\", 9),  (\"a\", \"f\", 14), (\"b\", \"c\", 10),\n               (\"b\", \"d\", 15), (\"c\", \"d\", 11), (\"c\", \"f\", 2),  (\"d\", \"e\", 6),\n               (\"e\", \"f\", 9)])\npp(graph.dijkstra(\"a\", \"e\"))\n\n\n", "human_summarization": "Implement Dijkstra's algorithm to find the shortest path from a given source node to all other nodes in a graph. The graph is represented by an adjacency matrix or list and a start node. The algorithm outputs a set of edges that depict the shortest path to each reachable node from the origin. The code also includes functionality to interpret the output and display the shortest path from the source node to specific nodes.", "id": 4678, "incomplete_code": "from collections import namedtuple, deque\nfrom pprint import pprint as pp\ninf = float('inf')\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\n\nclass Graph:\n\n    def __init__(self, edges):\n        pass\n\n    def dijkstra(self, source, dest):\n        pass\ngraph = Graph([('a', 'b', 7), ('a', 'c', 9), ('a', 'f', 14), ('b', 'c', 10), ('b', 'd', 15), ('c', 'd', 11), ('c', 'f', 2), ('d', 'e', 6), ('e', 'f', 9)])\npp(graph.dijkstra('a', 'e'))", "original_code": "\n\nfrom collections import namedtuple, deque\nfrom pprint import pprint as pp\n \n \ninf = float('inf')\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\n \nclass Graph():\n    def __init__(self, edges):\n        self.edges = [Edge(*edge) for edge in edges]\n        # print(dir(self.edges[0]))\n        self.vertices = {e.start for e in self.edges} | {e.end for e in self.edges}\n \n    def dijkstra(self, source, dest):\n        assert source in self.vertices\n        dist = {vertex: inf for vertex in self.vertices}\n        previous = {vertex: None for vertex in self.vertices}\n        dist[source] = 0\n        q = self.vertices.copy()\n        neighbours = {vertex: set() for vertex in self.vertices}\n        for start, end, cost in self.edges:\n            neighbours[start].add((end, cost))\n            neighbours[end].add((start, cost))\n\n        #pp(neighbours)\n \n        while q:\n            # pp(q)\n            u = min(q, key=lambda vertex: dist[vertex])\n            q.remove(u)\n            if dist[u] == inf or u == dest:\n                break\n            for v, cost in neighbours[u]:\n                alt = dist[u] + cost\n                if alt < dist[v]:                                  # Relax (u,v,a)\n                    dist[v] = alt\n                    previous[v] = u\n        #pp(previous)\n        s, u = deque(), dest\n        while previous[u]:\n            s.appendleft(u)\n            u = previous[u]\n        s.appendleft(u)\n        return s\n \n \ngraph = Graph([(\"a\", \"b\", 7),  (\"a\", \"c\", 9),  (\"a\", \"f\", 14), (\"b\", \"c\", 10),\n               (\"b\", \"d\", 15), (\"c\", \"d\", 11), (\"c\", \"f\", 2),  (\"d\", \"e\", 6),\n               (\"e\", \"f\", 9)])\npp(graph.dijkstra(\"a\", \"e\"))\n\n\n", "perturbed_code": "\nfrom collections import namedtuple, deque\ngraph = Graph([('a', 'b', 7), ('a', 'c', 9), ('a', 'f', 14), ('b', 'c', 10), ('b', 'd', 15), ('c', 'd', 11), ('c', 'f', 2), ('d', 'e', 6), ('e', 'f', 9)])\nfrom pprint import pprint as pp\ninf = float('inf')\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\npp(graph.dijkstra('a', 'e'))\n\nclass Graph():\n\n    def __init__(self, edges):\n        self.edges = [Edge(*edge) for edge in edges]\n        self.vertices = ({e.start for e in self.edges} | {e.end for e in self.edges})\n\n    def dijkstra(self, source, dest):\n        while previous[u]:\n            s.appendleft(u)\n            u = previous[u]\n        assert (source in self.vertices)\n        while q:\n            for (v, cost) in neighbours[u]:\n                alt = (dist[u] + cost)\n                if (alt < dist[v]):\n                    dist[v] = alt\n                    previous[v] = u\n            if ((dist[u] == inf) or (u == dest)):\n                break\n            u = min(q, key=(lambda vertex: dist[vertex]))\n            q.remove(u)\n        for (start, end, cost) in self.edges:\n            neighbours[start].add((end, cost))\n            neighbours[end].add((start, cost))\n        dist = {vertex: inf for vertex in self.vertices}\n        previous = {vertex: None for vertex in self.vertices}\n        dist[source] = 0\n        q = self.vertices.copy()\n        neighbours = {vertex: set() for vertex in self.vertices}\n        (s, u) = (deque(), dest)\n        s.appendleft(u)\n        return s\n", "incomplete_perturbed_code": "from collections import namedtuple, deque\ngraph = Graph([('a', 'b', 7), ('a', 'c', 9), ('a', 'f', 14), ('b', 'c', 10), ('b', 'd', 15), ('c', 'd', 11), ('c', 'f', 2), ('d', 'e', 6), ('e', 'f', 9)])\nfrom pprint import pprint as pp\ninf = float('inf')\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\npp(graph.dijkstra('a', 'e'))\n\nclass Graph:\n\n    def __init__(self, edges):\n        pass\n\n    def dijkstra(self, source, dest):\n        pass", "adversarial_score": 2, "original_score": 2, "search_time": 22.543469667434692, "stats": {"total_attempts": 2, "unique_perturbations": 2, "cache_hits": 0, "failed_perturbations": 0, "failed_evaluations": 0}, "adversarial_completion": "from collections import namedtuple, deque\ngraph = Graph([('a', 'b', 7), ('a', 'c', 9), ('a', 'f', 14), ('b', 'c', 10), ('b', 'd', 15), ('c', 'd', 11), ('c', 'f', 2), ('d', 'e', 6), ('e', 'f', 9)])\nfrom pprint import pprint as pp\ninf = float('inf')\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\npp(graph.dijkstra('a', 'e'))\n\nclass Graph:\n\n    def __init__(self, edges):\n        self.edges = edges\n\n    def dijkstra(self, source, dest):\n        distances = {node: float('inf') for node in self.edges}\n        distances[source] = 0\n        queue = deque([source])\n\n        while queue:\n            u = queue.popleft()\n            for v, cost in self.edges:\n                if distances[u] + cost < distances[v]:\n                    distances[v] = distances[u] + cost\n                    queue.append(v)\n\n        return distances\n\n    def get_shortest_path(self, source, dest):\n        distances = self.dijkstra(source, dest)\n        path = []\n        current = dest\n        while current != source:\n            path.append(current)\n            current = distances[current]\n        path.append(source)\n        return path[::-1]", "score_distribution": [2, 2]}
