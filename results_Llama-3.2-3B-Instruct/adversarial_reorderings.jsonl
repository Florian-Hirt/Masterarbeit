{"lang_cluster": "Python", "source_code": "\n# Works with: Python version 2.5\n\nfrom collections import deque\nstack = deque()\nstack.append(value) # pushing\nvalue = stack.pop()\nnot stack # is empty?\n\nfrom collections import deque\n\nclass Stack:\n    def __init__(self):\n        self._items = deque()\n    def append(self, item):\n        self._items.append(item)\n    def pop(self):\n        return self._items.pop()\n    def __nonzero__(self):\n        return bool(self._items)\n\nclass Stack:\n    def __init__(self):\n        self._first = None\n    def __nonzero__(self):\n        return self._first is not None \n    def append(self, value):\n        self._first = (value, self._first)\n    def pop(self):\n        if self._first is None:\n            raise IndexError(\"pop from empty stack\")\n        value, self._first = self._first\n        return value\n\nwhile not stack.empty():\n pass \nwhile stack:\n pass\n", "human_summarization": "implement a stack data structure supporting basic operations such as push, pop, and empty check. The stack follows a last in, first out (LIFO) access policy. The implementation can be done using a deque for faster performance or a linked list for a simpler interface.", "id": "4672", "incomplete_code": "from collections import deque\nstack = deque()\nstack.append(value)\nvalue = stack.pop()\nnot stack\nfrom collections import deque\n\nclass Stack:\n\n    def __init__(self):\n        pass\n\n    def append(self, item):\n        pass\n\n    def pop(self):\n        pass\n\n    def __nonzero__(self):\n        pass\n\nclass Stack:\n\n    def __init__(self):\n        pass\n\n    def __nonzero__(self):\n        pass\n\n    def append(self, value):\n        pass\n\n    def pop(self):\n        pass\nwhile not stack.empty():\n    pass\nwhile stack:\n    pass", "original_code": "\n# Works with: Python version 2.5\n\nfrom collections import deque\nstack = deque()\nstack.append(value) # pushing\nvalue = stack.pop()\nnot stack # is empty?\n\nfrom collections import deque\n\nclass Stack:\n    def __init__(self):\n        self._items = deque()\n    def append(self, item):\n        self._items.append(item)\n    def pop(self):\n        return self._items.pop()\n    def __nonzero__(self):\n        return bool(self._items)\n\nclass Stack:\n    def __init__(self):\n        self._first = None\n    def __nonzero__(self):\n        return self._first is not None \n    def append(self, value):\n        self._first = (value, self._first)\n    def pop(self):\n        if self._first is None:\n            raise IndexError(\"pop from empty stack\")\n        value, self._first = self._first\n        return value\n\nwhile not stack.empty():\n pass \nwhile stack:\n pass\n", "perturbed_code": "\nfrom collections import deque\nstack = deque()\nstack.append(value)\nvalue = stack.pop()\n(not stack)\nfrom collections import deque\n\nclass Stack():\n\n    def __init__(self):\n        self._items = deque()\n\n    def append(self, item):\n        self._items.append(item)\n\n    def pop(self):\n        return self._items.pop()\n\n    def __nonzero__(self):\n        return bool(self._items)\n\nclass Stack():\n\n    def __init__(self):\n        self._first = None\n\n    def __nonzero__(self):\n        return (self._first is not None)\n\n    def append(self, value):\n        self._first = (value, self._first)\n\n    def pop(self):\n        if (self._first is None):\n            raise IndexError('pop from empty stack')\n        (value, self._first) = self._first\n        return value\nwhile stack:\n    pass\nwhile (not stack.empty()):\n    pass\n", "incomplete_perturbed_code": "from collections import deque\nstack = deque()\nstack.append(value)\nvalue = stack.pop()\nnot stack\nfrom collections import deque\n\nclass Stack:\n\n    def __init__(self):\n        pass\n\n    def append(self, item):\n        pass\n\n    def pop(self):\n        pass\n\n    def __nonzero__(self):\n        pass\n\nclass Stack:\n\n    def __init__(self):\n        pass\n\n    def __nonzero__(self):\n        pass\n\n    def append(self, value):\n        pass\n\n    def pop(self):\n        pass\nwhile stack:\n    pass\nwhile not stack.empty():\n    pass", "adversarial_score": 4, "original_score": 4, "search_time_seconds": 50.56589865684509, "search_stats": {"total_reordering_attempts": 2, "unique_reorderings_generated": 2, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 2, "successful_llm_evaluations": 2, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 0, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 2, "unique_perturbations": 2}, "adversarial_completion": "from collections import deque\n\nclass Stack:\n\n    def __init__(self):\n        self.stack = deque()\n\n    def append(self, value):\n        self.stack.append(value)\n\n    def pop(self):\n        if self.is_empty():\n            raise IndexError(\"Cannot pop from an empty stack\")\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\n    def __nonzero__(self):\n        return bool(self.is_empty())\n\n    def __len__(self):\n        return len(self.stack)\n\n    def __iter__(self):\n        return iter(self.stack)\n\n    def __repr__(self):\n        return str(list(self.stack))\n\n    def __str__(self):\n        return str(self.stack)\n\n    def peek(self):\n        if self.is_empty():\n            raise IndexError(\"Cannot peek into an empty stack\")\n        return self.stack[-1]\n\nwhile Stack():\n    pass\n\nwhile not Stack().is_empty():\n    pass", "score_distribution_all_attempts": [4, 4]}
{"lang_cluster": "Python", "source_code": "\n\nfrom collections import namedtuple, deque\nfrom pprint import pprint as pp\n \n \ninf = float('inf')\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\n \nclass Graph():\n    def __init__(self, edges):\n        self.edges = [Edge(*edge) for edge in edges]\n        # print(dir(self.edges[0]))\n        self.vertices = {e.start for e in self.edges} | {e.end for e in self.edges}\n \n    def dijkstra(self, source, dest):\n        assert source in self.vertices\n        dist = {vertex: inf for vertex in self.vertices}\n        previous = {vertex: None for vertex in self.vertices}\n        dist[source] = 0\n        q = self.vertices.copy()\n        neighbours = {vertex: set() for vertex in self.vertices}\n        for start, end, cost in self.edges:\n            neighbours[start].add((end, cost))\n            neighbours[end].add((start, cost))\n\n        #pp(neighbours)\n \n        while q:\n            # pp(q)\n            u = min(q, key=lambda vertex: dist[vertex])\n            q.remove(u)\n            if dist[u] == inf or u == dest:\n                break\n            for v, cost in neighbours[u]:\n                alt = dist[u] + cost\n                if alt < dist[v]:                                  # Relax (u,v,a)\n                    dist[v] = alt\n                    previous[v] = u\n        #pp(previous)\n        s, u = deque(), dest\n        while previous[u]:\n            s.appendleft(u)\n            u = previous[u]\n        s.appendleft(u)\n        return s\n \n \ngraph = Graph([(\"a\", \"b\", 7),  (\"a\", \"c\", 9),  (\"a\", \"f\", 14), (\"b\", \"c\", 10),\n               (\"b\", \"d\", 15), (\"c\", \"d\", 11), (\"c\", \"f\", 2),  (\"d\", \"e\", 6),\n               (\"e\", \"f\", 9)])\npp(graph.dijkstra(\"a\", \"e\"))\n\n\n", "human_summarization": "Implement Dijkstra's algorithm to find the shortest path from a given source node to all other nodes in a graph. The graph is represented by an adjacency matrix or list and a start node. The algorithm outputs a set of edges that depict the shortest path to each reachable node from the origin. The code also includes functionality to interpret the output and display the shortest path from the source node to specific nodes.", "id": 4678, "incomplete_code": "from collections import namedtuple, deque\nfrom pprint import pprint as pp\ninf = float('inf')\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\n\nclass Graph:\n\n    def __init__(self, edges):\n        pass\n\n    def dijkstra(self, source, dest):\n        pass\ngraph = Graph([('a', 'b', 7), ('a', 'c', 9), ('a', 'f', 14), ('b', 'c', 10), ('b', 'd', 15), ('c', 'd', 11), ('c', 'f', 2), ('d', 'e', 6), ('e', 'f', 9)])\npp(graph.dijkstra('a', 'e'))", "original_code": "\n\nfrom collections import namedtuple, deque\nfrom pprint import pprint as pp\n \n \ninf = float('inf')\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\n \nclass Graph():\n    def __init__(self, edges):\n        self.edges = [Edge(*edge) for edge in edges]\n        # print(dir(self.edges[0]))\n        self.vertices = {e.start for e in self.edges} | {e.end for e in self.edges}\n \n    def dijkstra(self, source, dest):\n        assert source in self.vertices\n        dist = {vertex: inf for vertex in self.vertices}\n        previous = {vertex: None for vertex in self.vertices}\n        dist[source] = 0\n        q = self.vertices.copy()\n        neighbours = {vertex: set() for vertex in self.vertices}\n        for start, end, cost in self.edges:\n            neighbours[start].add((end, cost))\n            neighbours[end].add((start, cost))\n\n        #pp(neighbours)\n \n        while q:\n            # pp(q)\n            u = min(q, key=lambda vertex: dist[vertex])\n            q.remove(u)\n            if dist[u] == inf or u == dest:\n                break\n            for v, cost in neighbours[u]:\n                alt = dist[u] + cost\n                if alt < dist[v]:                                  # Relax (u,v,a)\n                    dist[v] = alt\n                    previous[v] = u\n        #pp(previous)\n        s, u = deque(), dest\n        while previous[u]:\n            s.appendleft(u)\n            u = previous[u]\n        s.appendleft(u)\n        return s\n \n \ngraph = Graph([(\"a\", \"b\", 7),  (\"a\", \"c\", 9),  (\"a\", \"f\", 14), (\"b\", \"c\", 10),\n               (\"b\", \"d\", 15), (\"c\", \"d\", 11), (\"c\", \"f\", 2),  (\"d\", \"e\", 6),\n               (\"e\", \"f\", 9)])\npp(graph.dijkstra(\"a\", \"e\"))\n\n\n", "perturbed_code": "\n\nfrom collections import namedtuple, deque\nfrom pprint import pprint as pp\n \n \ninf = float('inf')\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\n \nclass Graph():\n    def __init__(self, edges):\n        self.edges = [Edge(*edge) for edge in edges]\n        # print(dir(self.edges[0]))\n        self.vertices = {e.start for e in self.edges} | {e.end for e in self.edges}\n \n    def dijkstra(self, source, dest):\n        assert source in self.vertices\n        dist = {vertex: inf for vertex in self.vertices}\n        previous = {vertex: None for vertex in self.vertices}\n        dist[source] = 0\n        q = self.vertices.copy()\n        neighbours = {vertex: set() for vertex in self.vertices}\n        for start, end, cost in self.edges:\n            neighbours[start].add((end, cost))\n            neighbours[end].add((start, cost))\n\n        #pp(neighbours)\n \n        while q:\n            # pp(q)\n            u = min(q, key=lambda vertex: dist[vertex])\n            q.remove(u)\n            if dist[u] == inf or u == dest:\n                break\n            for v, cost in neighbours[u]:\n                alt = dist[u] + cost\n                if alt < dist[v]:                                  # Relax (u,v,a)\n                    dist[v] = alt\n                    previous[v] = u\n        #pp(previous)\n        s, u = deque(), dest\n        while previous[u]:\n            s.appendleft(u)\n            u = previous[u]\n        s.appendleft(u)\n        return s\n \n \ngraph = Graph([(\"a\", \"b\", 7),  (\"a\", \"c\", 9),  (\"a\", \"f\", 14), (\"b\", \"c\", 10),\n               (\"b\", \"d\", 15), (\"c\", \"d\", 11), (\"c\", \"f\", 2),  (\"d\", \"e\", 6),\n               (\"e\", \"f\", 9)])\npp(graph.dijkstra(\"a\", \"e\"))\n\n\n", "adversarial_score": Infinity, "original_score": 3, "notes": "No valid adversarial evaluations"}
{"lang_cluster": "Python", "source_code": "\n\nfrom collections import namedtuple\nfrom math import sqrt\n\nPt = namedtuple('Pt', 'x, y')\nCircle = Cir = namedtuple('Circle', 'x, y, r')\n\ndef circles_from_p1p2r(p1, p2, r):\n    'Following explanation at http://mathforum.org/library/drmath/view/53027.html'\n    if r == 0.0:\n        raise ValueError('radius of zero')\n    (x1, y1), (x2, y2) = p1, p2\n    if p1 == p2:\n        raise ValueError('coincident points gives infinite number of Circles')\n    # delta x, delta y between points\n    dx, dy = x2 - x1, y2 - y1\n    # dist between points\n    q = sqrt(dx**2 + dy**2)\n    if q > 2.0*r:\n        raise ValueError('separation of points > diameter')\n    # halfway point\n    x3, y3 = (x1+x2)/2, (y1+y2)/2\n    # distance along the mirror line\n    d = sqrt(r**2-(q/2)**2)\n    # One answer\n    c1 = Cir(x = x3 - d*dy/q,\n             y = y3 + d*dx/q,\n             r = abs(r))\n    # The other answer\n    c2 = Cir(x = x3 + d*dy/q,\n             y = y3 - d*dx/q,\n             r = abs(r))\n    return c1, c2\n\nif __name__ == '__main__':\n    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0),\n                      (Pt(0.0000, 2.0000), Pt(0.0000, 0.0000), 1.0),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0),\n                      (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:\n        print('Through points:\\n  %r,\\n  %r\\n  and radius %f\\nYou can construct the following circles:'\n              % (p1, p2, r))\n        try:\n            print('  %r\\n  %r\\n' % circles_from_p1p2r(p1, p2, r))\n        except ValueError as v:\n            print('  ERROR: %s\\n' % (v.args[0],))\n\n\n", "human_summarization": "The code defines a function that calculates and returns two circles that can be drawn through two given points with a specified radius. The function handles special cases such as when the radius is zero, the points are coincident, the points form a diameter, or the points are too far apart. The function raises a ValueError for these special cases and uses try-except to handle these exceptions. It also includes a task to calculate the total area of the circles. The function's output for specific inputs is also demonstrated.", "id": "4679", "incomplete_code": "from collections import namedtuple\nfrom math import sqrt\nPt = namedtuple('Pt', 'x, y')\nCircle = Cir = namedtuple('Circle', 'x, y, r')\n\ndef circles_from_p1p2r(p1, p2, r):\n    \"\"\"Following explanation at http://mathforum.org/library/drmath/view/53027.html\"\"\"\n    pass\nif __name__ == '__main__':\n    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0), (Pt(0.0, 2.0), Pt(0.0, 0.0), 1.0), (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0), (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5), (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:\n        print('Through points:\\n  %r,\\n  %r\\n  and radius %f\\nYou can construct the following circles:' % (p1, p2, r))\n        try:\n            print('  %r\\n  %r\\n' % circles_from_p1p2r(p1, p2, r))\n        except ValueError as v:\n            print('  ERROR: %s\\n' % (v.args[0],))", "original_code": "\n\nfrom collections import namedtuple\nfrom math import sqrt\n\nPt = namedtuple('Pt', 'x, y')\nCircle = Cir = namedtuple('Circle', 'x, y, r')\n\ndef circles_from_p1p2r(p1, p2, r):\n    'Following explanation at http://mathforum.org/library/drmath/view/53027.html'\n    if r == 0.0:\n        raise ValueError('radius of zero')\n    (x1, y1), (x2, y2) = p1, p2\n    if p1 == p2:\n        raise ValueError('coincident points gives infinite number of Circles')\n    # delta x, delta y between points\n    dx, dy = x2 - x1, y2 - y1\n    # dist between points\n    q = sqrt(dx**2 + dy**2)\n    if q > 2.0*r:\n        raise ValueError('separation of points > diameter')\n    # halfway point\n    x3, y3 = (x1+x2)/2, (y1+y2)/2\n    # distance along the mirror line\n    d = sqrt(r**2-(q/2)**2)\n    # One answer\n    c1 = Cir(x = x3 - d*dy/q,\n             y = y3 + d*dx/q,\n             r = abs(r))\n    # The other answer\n    c2 = Cir(x = x3 + d*dy/q,\n             y = y3 - d*dx/q,\n             r = abs(r))\n    return c1, c2\n\nif __name__ == '__main__':\n    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0),\n                      (Pt(0.0000, 2.0000), Pt(0.0000, 0.0000), 1.0),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0),\n                      (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:\n        print('Through points:\\n  %r,\\n  %r\\n  and radius %f\\nYou can construct the following circles:'\n              % (p1, p2, r))\n        try:\n            print('  %r\\n  %r\\n' % circles_from_p1p2r(p1, p2, r))\n        except ValueError as v:\n            print('  ERROR: %s\\n' % (v.args[0],))\n\n\n", "perturbed_code": "\nfrom collections import namedtuple\nPt = namedtuple('Pt', 'x, y')\nCircle = Cir = namedtuple('Circle', 'x, y, r')\nfrom math import sqrt\n\ndef circles_from_p1p2r(p1, p2, r):\n    if (q > (r * 2.0)):\n        raise ValueError('separation of points > diameter')\n    if (p2 == p1):\n        raise ValueError('coincident points gives infinite number of Circles')\n    'Following explanation at http://mathforum.org/library/drmath/view/53027.html'\n    if (r == 0.0):\n        raise ValueError('radius of zero')\n    ((x1, y1), (x2, y2)) = (p1, p2)\n    (dx, dy) = ((x2 - x1), (y2 - y1))\n    q = sqrt(((dy ** 2) + (dx ** 2)))\n    (x3, y3) = (((x1 + x2) / 2), ((y1 + y2) / 2))\n    d = sqrt(((r ** 2) - ((q / 2) ** 2)))\n    c1 = Cir(x=(x3 - ((d * dy) / q)), y=(((dx * d) / q) + y3), r=abs(r))\n    c2 = Cir(x=(x3 + ((dy * d) / q)), y=(y3 - ((dx * d) / q)), r=abs(r))\n    return (c1, c2)\nif ('__main__' == __name__):\n    for (p1, p2, r) in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0), (Pt(0.0, 2.0), Pt(0.0, 0.0), 1.0), (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0), (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5), (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:\n        print(('Through points:\\n  %r,\\n  %r\\n  and radius %f\\nYou can construct the following circles:' % (p1, p2, r)))\n        try:\n            print(('  %r\\n  %r\\n' % circles_from_p1p2r(p1, p2, r)))\n        except ValueError as v:\n            print(('  ERROR: %s\\n' % (v.args[0],)))\n", "incomplete_perturbed_code": "from collections import namedtuple\nPt = namedtuple('Pt', 'x, y')\nCircle = Cir = namedtuple('Circle', 'x, y, r')\nfrom math import sqrt\n\ndef circles_from_p1p2r(p1, p2, r):\n    pass\nif '__main__' == __name__:\n    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0), (Pt(0.0, 2.0), Pt(0.0, 0.0), 1.0), (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0), (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5), (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:\n        print('Through points:\\n  %r,\\n  %r\\n  and radius %f\\nYou can construct the following circles:' % (p1, p2, r))\n        try:\n            print('  %r\\n  %r\\n' % circles_from_p1p2r(p1, p2, r))\n        except ValueError as v:\n            print('  ERROR: %s\\n' % (v.args[0],))", "adversarial_score": 2, "original_score": 2, "search_time_seconds": 37.29186749458313, "search_stats": {"total_reordering_attempts": 2, "unique_reorderings_generated": 2, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 2, "successful_llm_evaluations": 2, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 0, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 2, "unique_perturbations": 2}, "adversarial_completion": "from collections import namedtuple\nPt = namedtuple('Pt', 'x, y')\nCircle = Cir = namedtuple('Circle', 'x, y, r')\nfrom math import sqrt\n\ndef circles_from_p1p2r(p1, p2, r):\n    \"\"\"\n    Calculate two circles that can be drawn through two given points with a specified radius.\n\n    Args:\n        p1 (Pt): The first point.\n        p2 (Pt): The second point.\n        r (float): The radius of the circles.\n\n    Returns:\n        list[Cir]: A list of two circles that can be drawn through the two points with the specified radius.\n\n    Raises:\n        ValueError: If the radius is zero, the points are coincident, the points form a diameter, or the points are too far apart.\n    \"\"\"\n    # Calculate the distance between the two points\n    d = sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2)\n\n    # Check for special cases\n    if r == 0:\n        raise ValueError(\"Radius cannot be zero\")\n    elif d == 0:\n        raise ValueError(\"Points are coincident\")\n    elif d == 2 * r:\n        raise ValueError(\"Points form a diameter\")\n    elif d > 2 * r:\n        raise ValueError(\"Points are too far apart\")\n\n    # Calculate the centers of the two circles\n    x1 = (p1.x + p2.x) / 2\n    y1 = (p1.y + p2.y) / 2\n    x2 = (p1.x + p2.x) / 2 + r * (p2.x - p1.x) / d\n    y2 = (p1.y + p2.y) / 2 + r * (p2.y - p1.y) / d\n\n    # Calculate the radii of the two circles\n    r1 = r\n    r2 = r\n\n    # Return the two circles\n    return [Circle(x1, y1, r1), Circle(x2, y2, r2)]\n\nif '__main__' == __name__:\n    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0), (Pt(0.0, 2.0), Pt(0.0, 0.0), 1.0), (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0), (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5), (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:\n        print('Through points:\\n  %r,\\n  %r\\n  and radius %f\\nYou can construct the following circles:' % (p1, p2, r))\n        try:\n            print('  %r\\n  %r\\n' % (circles_from_p1p2r(p1, p2, r)[0], circles_from_p1p2r(p1, p2, r)[1]))\n        except ValueError as v:\n            print('  ERROR: %s\\n' % (v.args[0],))", "score_distribution_all_attempts": [2, 2]}
{"lang_cluster": "Python", "source_code": "k8 = [\t14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7 ] \nk7 = [\t15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10 ]\nk6 = [\t10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8 ]\nk5 = [\t 7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15 ]\nk4 = [\t 2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9 ]\nk3 = [\t12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11 ]\nk2 = [\t 4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1 ]\nk1 = [\t13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7 ]\n \nk87 = [0] * 256\nk65 = [0] * 256\nk43 = [0] * 256\nk21 = [0] * 256\n \ndef kboxinit():\n\tfor i in range(256):\n\t\tk87[i] = k8[i >> 4] << 4 | k7[i & 15]\n\t\tk65[i] = k6[i >> 4] << 4 | k5[i & 15]\n\t\tk43[i] = k4[i >> 4] << 4 | k3[i & 15]\n\t\tk21[i] = k2[i >> 4] << 4 | k1[i & 15]\n \ndef f(x):\n\tx = ( k87[x>>24 & 255] << 24 | k65[x>>16 & 255] << 16 |\n\t      k43[x>> 8 & 255] <<  8 | k21[x & 255] )\n\treturn x<<11 | x>>(32-11)\n\n", "human_summarization": "Implement the main step of the GOST 28147-89 symmetric encryption algorithm, which involves taking a 64-bit block of text and one of the eight 32-bit encryption key elements, using a replacement table, and returning an encrypted block.", "id": "4680", "incomplete_code": "k8 = [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7]\nk7 = [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10]\nk6 = [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8]\nk5 = [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15]\nk4 = [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9]\nk3 = [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11]\nk2 = [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1]\nk1 = [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7]\nk87 = [0] * 256\nk65 = [0] * 256\nk43 = [0] * 256\nk21 = [0] * 256\n\ndef kboxinit():\n    pass\n\ndef f(x):\n    pass", "original_code": "k8 = [\t14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7 ] \nk7 = [\t15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10 ]\nk6 = [\t10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8 ]\nk5 = [\t 7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15 ]\nk4 = [\t 2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9 ]\nk3 = [\t12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11 ]\nk2 = [\t 4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1 ]\nk1 = [\t13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7 ]\n \nk87 = [0] * 256\nk65 = [0] * 256\nk43 = [0] * 256\nk21 = [0] * 256\n \ndef kboxinit():\n\tfor i in range(256):\n\t\tk87[i] = k8[i >> 4] << 4 | k7[i & 15]\n\t\tk65[i] = k6[i >> 4] << 4 | k5[i & 15]\n\t\tk43[i] = k4[i >> 4] << 4 | k3[i & 15]\n\t\tk21[i] = k2[i >> 4] << 4 | k1[i & 15]\n \ndef f(x):\n\tx = ( k87[x>>24 & 255] << 24 | k65[x>>16 & 255] << 16 |\n\t      k43[x>> 8 & 255] <<  8 | k21[x & 255] )\n\treturn x<<11 | x>>(32-11)\n\n", "perturbed_code": "\nk8 = [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7]\nk3 = [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11]\nk5 = [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15]\nk4 = [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9]\nk87 = (256 * [0])\nk6 = [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8]\n\ndef kboxinit():\n    for i in range(256):\n        k65[i] = ((k6[(i >> 4)] << 4) | k5[(i & 15)])\n        k87[i] = ((k8[(i >> 4)] << 4) | k7[(15 & i)])\n        k21[i] = ((k2[(i >> 4)] << 4) | k1[(i & 15)])\n        k43[i] = ((k4[(i >> 4)] << 4) | k3[(15 & i)])\nk43 = (256 * [0])\nk1 = [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7]\nk7 = [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10]\nk2 = [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1]\nk65 = (256 * [0])\nk21 = ([0] * 256)\n\ndef f(x):\n    x = ((((k65[(255 & (x >> 16))] << 16) | (k87[((x >> 24) & 255)] << 24)) | (k43[((x >> 8) & 255)] << 8)) | k21[(x & 255)])\n    return ((x >> (32 - 11)) | (x << 11))\n", "incomplete_perturbed_code": "k8 = [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7]\nk3 = [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11]\nk5 = [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15]\nk4 = [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9]\nk87 = 256 * [0]\nk6 = [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8]\n\ndef kboxinit():\n    pass\nk43 = 256 * [0]\nk1 = [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7]\nk7 = [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10]\nk2 = [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1]\nk65 = 256 * [0]\nk21 = [0] * 256\n\ndef f(x):\n    pass", "adversarial_score": 2, "original_score": 2, "search_time_seconds": 38.60413908958435, "search_stats": {"total_reordering_attempts": 2, "unique_reorderings_generated": 2, "failed_reorderings": 0, "transform_to_incomplete_failed": 0, "evaluation_attempts_for_new_reorderings": 2, "successful_llm_evaluations": 2, "failed_llm_evaluations": 0, "cache_hits_reordering_score": 0, "cache_hits_reordering_failed_eval": 0, "total_topo_sorts_generated": 2, "unique_perturbations": 2}, "adversarial_completion": "k8 = [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7]\nk3 = [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11]\nk5 = [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15]\nk4 = [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9]\nk87 = 256 * [0]\nk6 = [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8]\n\ndef kboxinit():\n    return k8 + k3 + k5 + k4 + k87 + k6\n\nk43 = 256 * [0]\nk1 = [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7]\nk7 = [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10]\nk2 = [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1]\nk65 = 256 * [0]\nk21 = [0] * 256\n\ndef f(x, k):\n    table = [0] * 256\n    for i in range(256):\n        table[i] = (k[i] + x) % 256\n    return table\n\ndef encrypt(block, key):\n    key = key[:16]\n    key = key + [0] * (16 - len(key))\n    table = f(block, key)\n    return table\n\ndef main():\n    key = kboxinit()\n    block = [0] * 64\n    encrypted = encrypt(block, key)\n    return encrypted\n\nprint(main())", "score_distribution_all_attempts": [2, 2]}
{"lang_cluster": "Python", "source_code": "\nLibrary: NumPy\n\n#!/usr/bin/env python3\n\nimport numpy as np\n\ndef qr(A):\n    m, n = A.shape\n    Q = np.eye(m)\n    for i in range(n - (m == n)):\n        H = np.eye(m)\n        H[i:, i:] = make_householder(A[i:, i])\n        Q = np.dot(Q, H)\n        A = np.dot(H, A)\n    return Q, A\n\ndef make_householder(a):\n    v = a / (a[0] + np.copysign(np.linalg.norm(a), a[0]))\n    v[0] = 1\n    H = np.eye(a.shape[0])\n    H -= (2 / np.dot(v, v)) * np.dot(v[:, None], v[None, :])\n    return H\n\n# task 1: show qr decomp of wp example\na = np.array(((\n    (12, -51,   4),\n    ( 6, 167, -68),\n    (-4,  24, -41),\n)))\n\nq, r = qr(a)\nprint('q:\\n', q.round(6))\nprint('r:\\n', r.round(6))\n\n# task 2: use qr decomp for polynomial regression example\ndef polyfit(x, y, n):\n    return lsqr(x[:, None]**np.arange(n + 1), y.T)\n\ndef lsqr(a, b):\n    q, r = qr(a)\n    _, n = r.shape\n    return np.linalg.solve(r[:n, :], np.dot(q.T, b)[:n])\n\nx = np.array((0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\ny = np.array((1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321))\n\nprint('\\npolyfit:\\n', polyfit(x, y, 2))\n\n\n", "human_summarization": "implement QR decomposition of a matrix using the method of Householder reflections. The code demonstrates the decomposition on a given example matrix and shows its usage for solving linear least squares problems. The code also includes a reimplementation of the Numpy's QR function to illustrate the construction and use of Householder reflections.", "id": 4686, "incomplete_code": "Library: NumPy\nimport numpy as np\n\ndef qr(A):\n    pass\n\ndef make_householder(a):\n    pass\na = np.array(((12, -51, 4), (6, 167, -68), (-4, 24, -41)))\nq, r = qr(a)\nprint('q:\\n', q.round(6))\nprint('r:\\n', r.round(6))\n\ndef polyfit(x, y, n):\n    pass\n\ndef lsqr(a, b):\n    pass\nx = np.array((0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\ny = np.array((1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321))\nprint('\\npolyfit:\\n', polyfit(x, y, 2))", "original_code": "\nLibrary: NumPy\n\n#!/usr/bin/env python3\n\nimport numpy as np\n\ndef qr(A):\n    m, n = A.shape\n    Q = np.eye(m)\n    for i in range(n - (m == n)):\n        H = np.eye(m)\n        H[i:, i:] = make_householder(A[i:, i])\n        Q = np.dot(Q, H)\n        A = np.dot(H, A)\n    return Q, A\n\ndef make_householder(a):\n    v = a / (a[0] + np.copysign(np.linalg.norm(a), a[0]))\n    v[0] = 1\n    H = np.eye(a.shape[0])\n    H -= (2 / np.dot(v, v)) * np.dot(v[:, None], v[None, :])\n    return H\n\n# task 1: show qr decomp of wp example\na = np.array(((\n    (12, -51,   4),\n    ( 6, 167, -68),\n    (-4,  24, -41),\n)))\n\nq, r = qr(a)\nprint('q:\\n', q.round(6))\nprint('r:\\n', r.round(6))\n\n# task 2: use qr decomp for polynomial regression example\ndef polyfit(x, y, n):\n    return lsqr(x[:, None]**np.arange(n + 1), y.T)\n\ndef lsqr(a, b):\n    q, r = qr(a)\n    _, n = r.shape\n    return np.linalg.solve(r[:n, :], np.dot(q.T, b)[:n])\n\nx = np.array((0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\ny = np.array((1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321))\n\nprint('\\npolyfit:\\n', polyfit(x, y, 2))\n\n\n", "perturbed_code": "\nLibrary: NumPy\n\n#!/usr/bin/env python3\n\nimport numpy as np\n\ndef qr(A):\n    m, n = A.shape\n    Q = np.eye(m)\n    for i in range(n - (m == n)):\n        H = np.eye(m)\n        H[i:, i:] = make_householder(A[i:, i])\n        Q = np.dot(Q, H)\n        A = np.dot(H, A)\n    return Q, A\n\ndef make_householder(a):\n    v = a / (a[0] + np.copysign(np.linalg.norm(a), a[0]))\n    v[0] = 1\n    H = np.eye(a.shape[0])\n    H -= (2 / np.dot(v, v)) * np.dot(v[:, None], v[None, :])\n    return H\n\n# task 1: show qr decomp of wp example\na = np.array(((\n    (12, -51,   4),\n    ( 6, 167, -68),\n    (-4,  24, -41),\n)))\n\nq, r = qr(a)\nprint('q:\\n', q.round(6))\nprint('r:\\n', r.round(6))\n\n# task 2: use qr decomp for polynomial regression example\ndef polyfit(x, y, n):\n    return lsqr(x[:, None]**np.arange(n + 1), y.T)\n\ndef lsqr(a, b):\n    q, r = qr(a)\n    _, n = r.shape\n    return np.linalg.solve(r[:n, :], np.dot(q.T, b)[:n])\n\nx = np.array((0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\ny = np.array((1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321))\n\nprint('\\npolyfit:\\n', polyfit(x, y, 2))\n\n\n", "adversarial_score": Infinity, "original_score": 3, "notes": "No valid adversarial evaluations"}
